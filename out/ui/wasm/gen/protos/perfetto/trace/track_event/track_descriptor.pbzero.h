// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class ChromeProcessDescriptor;
class ChromeThreadDescriptor;
class CounterDescriptor;
class ProcessDescriptor;
class ThreadDescriptor;
namespace perfetto_pbzero_enum_TrackDescriptor {
enum ChildTracksOrdering : int32_t;
}  // namespace perfetto_pbzero_enum_TrackDescriptor
using TrackDescriptor_ChildTracksOrdering = perfetto_pbzero_enum_TrackDescriptor::ChildTracksOrdering;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_TrackDescriptor {
enum ChildTracksOrdering : int32_t {
  UNKNOWN = 0,
  LEXICOGRAPHIC = 1,
  CHRONOLOGICAL = 2,
  EXPLICIT = 3,
};
} // namespace perfetto_pbzero_enum_TrackDescriptor
using TrackDescriptor_ChildTracksOrdering = perfetto_pbzero_enum_TrackDescriptor::ChildTracksOrdering;


constexpr TrackDescriptor_ChildTracksOrdering TrackDescriptor_ChildTracksOrdering_MIN = TrackDescriptor_ChildTracksOrdering::UNKNOWN;
constexpr TrackDescriptor_ChildTracksOrdering TrackDescriptor_ChildTracksOrdering_MAX = TrackDescriptor_ChildTracksOrdering::EXPLICIT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* TrackDescriptor_ChildTracksOrdering_Name(::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering value) {
  switch (value) {
  case ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering::UNKNOWN:
    return "UNKNOWN";

  case ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering::LEXICOGRAPHIC:
    return "LEXICOGRAPHIC";

  case ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering::CHRONOLOGICAL:
    return "CHRONOLOGICAL";

  case ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering::EXPLICIT:
    return "EXPLICIT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class TrackDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/13, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_uuid() const { return at<1>().valid(); }
  uint64_t uuid() const { return at<1>().as_uint64(); }
  bool has_parent_uuid() const { return at<5>().valid(); }
  uint64_t parent_uuid() const { return at<5>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_static_name() const { return at<10>().valid(); }
  ::protozero::ConstChars static_name() const { return at<10>().as_string(); }
  bool has_atrace_name() const { return at<13>().valid(); }
  ::protozero::ConstChars atrace_name() const { return at<13>().as_string(); }
  bool has_process() const { return at<3>().valid(); }
  ::protozero::ConstBytes process() const { return at<3>().as_bytes(); }
  bool has_chrome_process() const { return at<6>().valid(); }
  ::protozero::ConstBytes chrome_process() const { return at<6>().as_bytes(); }
  bool has_thread() const { return at<4>().valid(); }
  ::protozero::ConstBytes thread() const { return at<4>().as_bytes(); }
  bool has_chrome_thread() const { return at<7>().valid(); }
  ::protozero::ConstBytes chrome_thread() const { return at<7>().as_bytes(); }
  bool has_counter() const { return at<8>().valid(); }
  ::protozero::ConstBytes counter() const { return at<8>().as_bytes(); }
  bool has_disallow_merging_with_system_tracks() const { return at<9>().valid(); }
  bool disallow_merging_with_system_tracks() const { return at<9>().as_bool(); }
  bool has_child_ordering() const { return at<11>().valid(); }
  int32_t child_ordering() const { return at<11>().as_int32(); }
  bool has_sibling_order_rank() const { return at<12>().valid(); }
  int32_t sibling_order_rank() const { return at<12>().as_int32(); }
};

class TrackDescriptor : public ::protozero::Message {
 public:
  using Decoder = TrackDescriptor_Decoder;
  enum : int32_t {
    kUuidFieldNumber = 1,
    kParentUuidFieldNumber = 5,
    kNameFieldNumber = 2,
    kStaticNameFieldNumber = 10,
    kAtraceNameFieldNumber = 13,
    kProcessFieldNumber = 3,
    kChromeProcessFieldNumber = 6,
    kThreadFieldNumber = 4,
    kChromeThreadFieldNumber = 7,
    kCounterFieldNumber = 8,
    kDisallowMergingWithSystemTracksFieldNumber = 9,
    kChildOrderingFieldNumber = 11,
    kSiblingOrderRankFieldNumber = 12,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TrackDescriptor"; }


  using ChildTracksOrdering = ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering;
  static inline const char* ChildTracksOrdering_Name(ChildTracksOrdering value) {
    return ::perfetto::protos::pbzero::TrackDescriptor_ChildTracksOrdering_Name(value);
  }
  static inline const ChildTracksOrdering UNKNOWN = ChildTracksOrdering::UNKNOWN;
  static inline const ChildTracksOrdering LEXICOGRAPHIC = ChildTracksOrdering::LEXICOGRAPHIC;
  static inline const ChildTracksOrdering CHRONOLOGICAL = ChildTracksOrdering::CHRONOLOGICAL;
  static inline const ChildTracksOrdering EXPLICIT = ChildTracksOrdering::EXPLICIT;

  using FieldMetadata_Uuid =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrackDescriptor>;

  static constexpr FieldMetadata_Uuid kUuid{};
  void set_uuid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Uuid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ParentUuid =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kUint64,
      uint64_t,
      TrackDescriptor>;

  static constexpr FieldMetadata_ParentUuid kParentUuid{};
  void set_parent_uuid(uint64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ParentUuid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kUint64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrackDescriptor>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StaticName =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrackDescriptor>;

  static constexpr FieldMetadata_StaticName kStaticName{};
  void set_static_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_StaticName::kFieldId, data, size);
  }
  void set_static_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_StaticName::kFieldId, chars.data, chars.size);
  }
  void set_static_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_StaticName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AtraceName =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TrackDescriptor>;

  static constexpr FieldMetadata_AtraceName kAtraceName{};
  void set_atrace_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_AtraceName::kFieldId, data, size);
  }
  void set_atrace_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_AtraceName::kFieldId, chars.data, chars.size);
  }
  void set_atrace_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_AtraceName::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Process =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ProcessDescriptor,
      TrackDescriptor>;

  static constexpr FieldMetadata_Process kProcess{};
  template <typename T = ProcessDescriptor> T* set_process() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_ChromeProcess =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeProcessDescriptor,
      TrackDescriptor>;

  static constexpr FieldMetadata_ChromeProcess kChromeProcess{};
  template <typename T = ChromeProcessDescriptor> T* set_chrome_process() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_Thread =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ThreadDescriptor,
      TrackDescriptor>;

  static constexpr FieldMetadata_Thread kThread{};
  template <typename T = ThreadDescriptor> T* set_thread() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_ChromeThread =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ChromeThreadDescriptor,
      TrackDescriptor>;

  static constexpr FieldMetadata_ChromeThread kChromeThread{};
  template <typename T = ChromeThreadDescriptor> T* set_chrome_thread() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_Counter =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      CounterDescriptor,
      TrackDescriptor>;

  static constexpr FieldMetadata_Counter kCounter{};
  template <typename T = CounterDescriptor> T* set_counter() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_DisallowMergingWithSystemTracks =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TrackDescriptor>;

  static constexpr FieldMetadata_DisallowMergingWithSystemTracks kDisallowMergingWithSystemTracks{};
  void set_disallow_merging_with_system_tracks(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_DisallowMergingWithSystemTracks::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChildOrdering =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TrackDescriptor_ChildTracksOrdering,
      TrackDescriptor>;

  static constexpr FieldMetadata_ChildOrdering kChildOrdering{};
  void set_child_ordering(TrackDescriptor_ChildTracksOrdering value) {
    static constexpr uint32_t field_id = FieldMetadata_ChildOrdering::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SiblingOrderRank =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TrackDescriptor>;

  static constexpr FieldMetadata_SiblingOrderRank kSiblingOrderRank{};
  void set_sibling_order_rank(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SiblingOrderRank::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
