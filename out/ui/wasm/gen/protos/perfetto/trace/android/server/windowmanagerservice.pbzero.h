// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SERVER_WINDOWMANAGERSERVICE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_SERVER_WINDOWMANAGERSERVICE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

#include "perfetto/protozero/field_writer.h"
#include "perfetto/protozero/message.h"
#include "perfetto/protozero/packed_repeated_fields.h"
#include "perfetto/protozero/proto_decoder.h"
#include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {
class ActivityRecordProto;
class AppTransitionProto;
class BackNavigationProto;
class BarControllerProto;
class ConfigurationContainerProto;
class ConfigurationProto;
class DisplayAreaChildProto;
class DisplayAreaProto;
class DisplayContentProto;
class DisplayCutoutProto;
class DisplayFramesProto;
class DisplayInfoProto;
class DisplayRotationProto;
class DockedTaskDividerControllerProto;
class IdentifierProto;
class ImeInsetsSourceProviderProto;
class InsetsSourceControlProto;
class InsetsSourceProto;
class InsetsSourceProviderProto;
class KeyguardControllerProto;
class KeyguardOccludedProto;
class KeyguardPerDisplayProto;
class KeyguardServiceDelegateProto;
class PinnedTaskControllerProto;
class RectProto;
class RootWindowContainerProto;
class ScreenRotationAnimationProto;
class SurfaceAnimatorProto;
class SurfaceControlProto;
class TaskFragmentProto;
class TaskProto;
class WindowContainerChildProto;
class WindowContainerProto;
class WindowContainerThumbnailProto;
class WindowFramesProto;
class WindowLayoutParamsProto;
class WindowManagerPolicyProto;
class WindowOrientationListenerProto;
class WindowStateAnimatorProto;
class WindowStateProto;
class WindowSurfaceControllerProto;
class WindowTokenProto;
namespace perfetto_pbzero_enum_ActivityInfoProto {
enum ScreenOrientation : int32_t;
}  // namespace perfetto_pbzero_enum_ActivityInfoProto
using ActivityInfoProto_ScreenOrientation = perfetto_pbzero_enum_ActivityInfoProto::ScreenOrientation;
namespace perfetto_pbzero_enum_AppTransitionProto {
enum AppState : int32_t;
}  // namespace perfetto_pbzero_enum_AppTransitionProto
using AppTransitionProto_AppState = perfetto_pbzero_enum_AppTransitionProto::AppState;
namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto {
enum InteractiveState : int32_t;
}  // namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto
using KeyguardServiceDelegateProto_InteractiveState = perfetto_pbzero_enum_KeyguardServiceDelegateProto::InteractiveState;
namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto {
enum ScreenState : int32_t;
}  // namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto
using KeyguardServiceDelegateProto_ScreenState = perfetto_pbzero_enum_KeyguardServiceDelegateProto::ScreenState;
namespace perfetto_pbzero_enum_StatusBarManagerProto {
enum TransientWindowState : int32_t;
}  // namespace perfetto_pbzero_enum_StatusBarManagerProto
using StatusBarManagerProto_TransientWindowState = perfetto_pbzero_enum_StatusBarManagerProto::TransientWindowState;
namespace perfetto_pbzero_enum_StatusBarManagerProto {
enum WindowState : int32_t;
}  // namespace perfetto_pbzero_enum_StatusBarManagerProto
using StatusBarManagerProto_WindowState = perfetto_pbzero_enum_StatusBarManagerProto::WindowState;
namespace perfetto_pbzero_enum_SurfaceProto {
enum Rotation : int32_t;
}  // namespace perfetto_pbzero_enum_SurfaceProto
using SurfaceProto_Rotation = perfetto_pbzero_enum_SurfaceProto::Rotation;
enum TransitionTypeEnum : int32_t;
namespace perfetto_pbzero_enum_WindowManagerPolicyProto {
enum UserRotationMode : int32_t;
}  // namespace perfetto_pbzero_enum_WindowManagerPolicyProto
using WindowManagerPolicyProto_UserRotationMode = perfetto_pbzero_enum_WindowManagerPolicyProto::UserRotationMode;
namespace perfetto_pbzero_enum_WindowStateAnimatorProto {
enum DrawState : int32_t;
}  // namespace perfetto_pbzero_enum_WindowStateAnimatorProto
using WindowStateAnimatorProto_DrawState = perfetto_pbzero_enum_WindowStateAnimatorProto::DrawState;
} // Namespace pbzero.
} // Namespace protos.
} // Namespace perfetto.

namespace perfetto {
namespace protos {
namespace pbzero {

namespace perfetto_pbzero_enum_WindowStateAnimatorProto {
enum DrawState : int32_t {
  NO_SURFACE = 0,
  DRAW_PENDING = 1,
  COMMIT_DRAW_PENDING = 2,
  READY_TO_SHOW = 3,
  HAS_DRAWN = 4,
};
} // namespace perfetto_pbzero_enum_WindowStateAnimatorProto
using WindowStateAnimatorProto_DrawState = perfetto_pbzero_enum_WindowStateAnimatorProto::DrawState;


constexpr WindowStateAnimatorProto_DrawState WindowStateAnimatorProto_DrawState_MIN = WindowStateAnimatorProto_DrawState::NO_SURFACE;
constexpr WindowStateAnimatorProto_DrawState WindowStateAnimatorProto_DrawState_MAX = WindowStateAnimatorProto_DrawState::HAS_DRAWN;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* WindowStateAnimatorProto_DrawState_Name(::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState::NO_SURFACE:
    return "NO_SURFACE";

  case ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState::DRAW_PENDING:
    return "DRAW_PENDING";

  case ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState::COMMIT_DRAW_PENDING:
    return "COMMIT_DRAW_PENDING";

  case ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState::READY_TO_SHOW:
    return "READY_TO_SHOW";

  case ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState::HAS_DRAWN:
    return "HAS_DRAWN";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_AppTransitionProto {
enum AppState : int32_t {
  APP_STATE_IDLE = 0,
  APP_STATE_READY = 1,
  APP_STATE_RUNNING = 2,
  APP_STATE_TIMEOUT = 3,
};
} // namespace perfetto_pbzero_enum_AppTransitionProto
using AppTransitionProto_AppState = perfetto_pbzero_enum_AppTransitionProto::AppState;


constexpr AppTransitionProto_AppState AppTransitionProto_AppState_MIN = AppTransitionProto_AppState::APP_STATE_IDLE;
constexpr AppTransitionProto_AppState AppTransitionProto_AppState_MAX = AppTransitionProto_AppState::APP_STATE_TIMEOUT;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* AppTransitionProto_AppState_Name(::perfetto::protos::pbzero::AppTransitionProto_AppState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::AppTransitionProto_AppState::APP_STATE_IDLE:
    return "APP_STATE_IDLE";

  case ::perfetto::protos::pbzero::AppTransitionProto_AppState::APP_STATE_READY:
    return "APP_STATE_READY";

  case ::perfetto::protos::pbzero::AppTransitionProto_AppState::APP_STATE_RUNNING:
    return "APP_STATE_RUNNING";

  case ::perfetto::protos::pbzero::AppTransitionProto_AppState::APP_STATE_TIMEOUT:
    return "APP_STATE_TIMEOUT";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_WindowManagerPolicyProto {
enum UserRotationMode : int32_t {
  USER_ROTATION_FREE = 0,
  USER_ROTATION_LOCKED = 1,
};
} // namespace perfetto_pbzero_enum_WindowManagerPolicyProto
using WindowManagerPolicyProto_UserRotationMode = perfetto_pbzero_enum_WindowManagerPolicyProto::UserRotationMode;


constexpr WindowManagerPolicyProto_UserRotationMode WindowManagerPolicyProto_UserRotationMode_MIN = WindowManagerPolicyProto_UserRotationMode::USER_ROTATION_FREE;
constexpr WindowManagerPolicyProto_UserRotationMode WindowManagerPolicyProto_UserRotationMode_MAX = WindowManagerPolicyProto_UserRotationMode::USER_ROTATION_LOCKED;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* WindowManagerPolicyProto_UserRotationMode_Name(::perfetto::protos::pbzero::WindowManagerPolicyProto_UserRotationMode value) {
  switch (value) {
  case ::perfetto::protos::pbzero::WindowManagerPolicyProto_UserRotationMode::USER_ROTATION_FREE:
    return "USER_ROTATION_FREE";

  case ::perfetto::protos::pbzero::WindowManagerPolicyProto_UserRotationMode::USER_ROTATION_LOCKED:
    return "USER_ROTATION_LOCKED";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto {
enum ScreenState : int32_t {
  SCREEN_STATE_OFF = 0,
  SCREEN_STATE_TURNING_ON = 1,
  SCREEN_STATE_ON = 2,
  SCREEN_STATE_TURNING_OFF = 3,
};
} // namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto
using KeyguardServiceDelegateProto_ScreenState = perfetto_pbzero_enum_KeyguardServiceDelegateProto::ScreenState;


constexpr KeyguardServiceDelegateProto_ScreenState KeyguardServiceDelegateProto_ScreenState_MIN = KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_OFF;
constexpr KeyguardServiceDelegateProto_ScreenState KeyguardServiceDelegateProto_ScreenState_MAX = KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_TURNING_OFF;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* KeyguardServiceDelegateProto_ScreenState_Name(::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_OFF:
    return "SCREEN_STATE_OFF";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_TURNING_ON:
    return "SCREEN_STATE_TURNING_ON";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_ON:
    return "SCREEN_STATE_ON";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState::SCREEN_STATE_TURNING_OFF:
    return "SCREEN_STATE_TURNING_OFF";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto {
enum InteractiveState : int32_t {
  INTERACTIVE_STATE_SLEEP = 0,
  INTERACTIVE_STATE_WAKING = 1,
  INTERACTIVE_STATE_AWAKE = 2,
  INTERACTIVE_STATE_GOING_TO_SLEEP = 3,
};
} // namespace perfetto_pbzero_enum_KeyguardServiceDelegateProto
using KeyguardServiceDelegateProto_InteractiveState = perfetto_pbzero_enum_KeyguardServiceDelegateProto::InteractiveState;


constexpr KeyguardServiceDelegateProto_InteractiveState KeyguardServiceDelegateProto_InteractiveState_MIN = KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_SLEEP;
constexpr KeyguardServiceDelegateProto_InteractiveState KeyguardServiceDelegateProto_InteractiveState_MAX = KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_GOING_TO_SLEEP;


PERFETTO_PROTOZERO_CONSTEXPR14_OR_INLINE
const char* KeyguardServiceDelegateProto_InteractiveState_Name(::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState value) {
  switch (value) {
  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_SLEEP:
    return "INTERACTIVE_STATE_SLEEP";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_WAKING:
    return "INTERACTIVE_STATE_WAKING";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_AWAKE:
    return "INTERACTIVE_STATE_AWAKE";

  case ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState::INTERACTIVE_STATE_GOING_TO_SLEEP:
    return "INTERACTIVE_STATE_GOING_TO_SLEEP";
  }
  return "PBZERO_UNKNOWN_ENUM_VALUE";
}

class BackNavigationProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackNavigationProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackNavigationProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackNavigationProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_animation_in_progress() const { return at<1>().valid(); }
  bool animation_in_progress() const { return at<1>().as_bool(); }
  bool has_last_back_type() const { return at<2>().valid(); }
  int32_t last_back_type() const { return at<2>().as_int32(); }
  bool has_show_wallpaper() const { return at<3>().valid(); }
  bool show_wallpaper() const { return at<3>().as_bool(); }
  bool has_main_open_activity() const { return at<4>().valid(); }
  ::protozero::ConstChars main_open_activity() const { return at<4>().as_string(); }
  bool has_animation_running() const { return at<5>().valid(); }
  bool animation_running() const { return at<5>().as_bool(); }
};

class BackNavigationProto : public ::protozero::Message {
 public:
  using Decoder = BackNavigationProto_Decoder;
  enum : int32_t {
    kAnimationInProgressFieldNumber = 1,
    kLastBackTypeFieldNumber = 2,
    kShowWallpaperFieldNumber = 3,
    kMainOpenActivityFieldNumber = 4,
    kAnimationRunningFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BackNavigationProto"; }


  using FieldMetadata_AnimationInProgress =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      BackNavigationProto>;

  static constexpr FieldMetadata_AnimationInProgress kAnimationInProgress{};
  void set_animation_in_progress(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimationInProgress::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastBackType =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      BackNavigationProto>;

  static constexpr FieldMetadata_LastBackType kLastBackType{};
  void set_last_back_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastBackType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShowWallpaper =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      BackNavigationProto>;

  static constexpr FieldMetadata_ShowWallpaper kShowWallpaper{};
  void set_show_wallpaper(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShowWallpaper::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MainOpenActivity =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      BackNavigationProto>;

  static constexpr FieldMetadata_MainOpenActivity kMainOpenActivity{};
  void set_main_open_activity(const char* data, size_t size) {
    AppendBytes(FieldMetadata_MainOpenActivity::kFieldId, data, size);
  }
  void set_main_open_activity(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_MainOpenActivity::kFieldId, chars.data, chars.size);
  }
  void set_main_open_activity(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_MainOpenActivity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnimationRunning =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      BackNavigationProto>;

  static constexpr FieldMetadata_AnimationRunning kAnimationRunning{};
  void set_animation_running(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimationRunning::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class ImeInsetsSourceProviderProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ImeInsetsSourceProviderProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ImeInsetsSourceProviderProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ImeInsetsSourceProviderProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_insets_source_provider() const { return at<1>().valid(); }
  ::protozero::ConstBytes insets_source_provider() const { return at<1>().as_bytes(); }
  bool has_ime_target_from_ime() const { return at<2>().valid(); }
  ::protozero::ConstBytes ime_target_from_ime() const { return at<2>().as_bytes(); }
  bool has_is_ime_layout_drawn() const { return at<3>().valid(); }
  bool is_ime_layout_drawn() const { return at<3>().as_bool(); }
};

class ImeInsetsSourceProviderProto : public ::protozero::Message {
 public:
  using Decoder = ImeInsetsSourceProviderProto_Decoder;
  enum : int32_t {
    kInsetsSourceProviderFieldNumber = 1,
    kImeTargetFromImeFieldNumber = 2,
    kIsImeLayoutDrawnFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ImeInsetsSourceProviderProto"; }


  using FieldMetadata_InsetsSourceProvider =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceProviderProto,
      ImeInsetsSourceProviderProto>;

  static constexpr FieldMetadata_InsetsSourceProvider kInsetsSourceProvider{};
  template <typename T = InsetsSourceProviderProto> T* set_insets_source_provider() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_ImeTargetFromIme =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      ImeInsetsSourceProviderProto>;

  static constexpr FieldMetadata_ImeTargetFromIme kImeTargetFromIme{};
  template <typename T = WindowStateProto> T* set_ime_target_from_ime() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_IsImeLayoutDrawn =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ImeInsetsSourceProviderProto>;

  static constexpr FieldMetadata_IsImeLayoutDrawn kIsImeLayoutDrawn{};
  void set_is_ime_layout_drawn(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsImeLayoutDrawn::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class InsetsSourceProviderProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InsetsSourceProviderProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InsetsSourceProviderProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InsetsSourceProviderProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source() const { return at<1>().valid(); }
  ::protozero::ConstBytes source() const { return at<1>().as_bytes(); }
  bool has_frame() const { return at<2>().valid(); }
  ::protozero::ConstBytes frame() const { return at<2>().as_bytes(); }
  bool has_fake_control() const { return at<3>().valid(); }
  ::protozero::ConstBytes fake_control() const { return at<3>().as_bytes(); }
  bool has_control() const { return at<4>().valid(); }
  ::protozero::ConstBytes control() const { return at<4>().as_bytes(); }
  bool has_control_target() const { return at<5>().valid(); }
  ::protozero::ConstBytes control_target() const { return at<5>().as_bytes(); }
  bool has_pending_control_target() const { return at<6>().valid(); }
  ::protozero::ConstBytes pending_control_target() const { return at<6>().as_bytes(); }
  bool has_fake_control_target() const { return at<7>().valid(); }
  ::protozero::ConstBytes fake_control_target() const { return at<7>().as_bytes(); }
  bool has_captured_leash() const { return at<8>().valid(); }
  ::protozero::ConstBytes captured_leash() const { return at<8>().as_bytes(); }
  bool has_ime_overridden_frame() const { return at<9>().valid(); }
  ::protozero::ConstBytes ime_overridden_frame() const { return at<9>().as_bytes(); }
  bool has_is_leash_ready_for_dispatching() const { return at<10>().valid(); }
  bool is_leash_ready_for_dispatching() const { return at<10>().as_bool(); }
  bool has_client_visible() const { return at<11>().valid(); }
  bool client_visible() const { return at<11>().as_bool(); }
  bool has_server_visible() const { return at<12>().valid(); }
  bool server_visible() const { return at<12>().as_bool(); }
  bool has_seamless_rotating() const { return at<13>().valid(); }
  bool seamless_rotating() const { return at<13>().as_bool(); }
  bool has_finish_seamless_rotate_frame_number() const { return at<14>().valid(); }
  int64_t finish_seamless_rotate_frame_number() const { return at<14>().as_int64(); }
  bool has_controllable() const { return at<15>().valid(); }
  bool controllable() const { return at<15>().as_bool(); }
  bool has_source_window_state() const { return at<16>().valid(); }
  ::protozero::ConstBytes source_window_state() const { return at<16>().as_bytes(); }
};

class InsetsSourceProviderProto : public ::protozero::Message {
 public:
  using Decoder = InsetsSourceProviderProto_Decoder;
  enum : int32_t {
    kSourceFieldNumber = 1,
    kFrameFieldNumber = 2,
    kFakeControlFieldNumber = 3,
    kControlFieldNumber = 4,
    kControlTargetFieldNumber = 5,
    kPendingControlTargetFieldNumber = 6,
    kFakeControlTargetFieldNumber = 7,
    kCapturedLeashFieldNumber = 8,
    kImeOverriddenFrameFieldNumber = 9,
    kIsLeashReadyForDispatchingFieldNumber = 10,
    kClientVisibleFieldNumber = 11,
    kServerVisibleFieldNumber = 12,
    kSeamlessRotatingFieldNumber = 13,
    kFinishSeamlessRotateFrameNumberFieldNumber = 14,
    kControllableFieldNumber = 15,
    kSourceWindowStateFieldNumber = 16,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.InsetsSourceProviderProto"; }


  using FieldMetadata_Source =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_Source kSource{};
  template <typename T = InsetsSourceProto> T* set_source() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Frame =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_Frame kFrame{};
  template <typename T = RectProto> T* set_frame() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_FakeControl =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceControlProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_FakeControl kFakeControl{};
  template <typename T = InsetsSourceControlProto> T* set_fake_control() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_Control =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceControlProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_Control kControl{};
  template <typename T = InsetsSourceControlProto> T* set_control() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_ControlTarget =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_ControlTarget kControlTarget{};
  template <typename T = WindowStateProto> T* set_control_target() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_PendingControlTarget =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_PendingControlTarget kPendingControlTarget{};
  template <typename T = WindowStateProto> T* set_pending_control_target() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_FakeControlTarget =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_FakeControlTarget kFakeControlTarget{};
  template <typename T = WindowStateProto> T* set_fake_control_target() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_CapturedLeash =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SurfaceControlProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_CapturedLeash kCapturedLeash{};
  template <typename T = SurfaceControlProto> T* set_captured_leash() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_ImeOverriddenFrame =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_ImeOverriddenFrame kImeOverriddenFrame{};
  template <typename T = RectProto> T* set_ime_overridden_frame() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_IsLeashReadyForDispatching =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_IsLeashReadyForDispatching kIsLeashReadyForDispatching{};
  void set_is_leash_ready_for_dispatching(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsLeashReadyForDispatching::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ClientVisible =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_ClientVisible kClientVisible{};
  void set_client_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ClientVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ServerVisible =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_ServerVisible kServerVisible{};
  void set_server_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ServerVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SeamlessRotating =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_SeamlessRotating kSeamlessRotating{};
  void set_seamless_rotating(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SeamlessRotating::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FinishSeamlessRotateFrameNumber =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_FinishSeamlessRotateFrameNumber kFinishSeamlessRotateFrameNumber{};
  void set_finish_seamless_rotate_frame_number(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FinishSeamlessRotateFrameNumber::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Controllable =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_Controllable kControllable{};
  void set_controllable(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Controllable::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SourceWindowState =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      InsetsSourceProviderProto>;

  static constexpr FieldMetadata_SourceWindowState kSourceWindowState{};
  template <typename T = WindowStateProto> T* set_source_window_state() {
    return BeginNestedMessage<T>(16);
  }

};

class WindowFramesProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowFramesProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowFramesProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowFramesProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_containing_frame() const { return at<1>().valid(); }
  ::protozero::ConstBytes containing_frame() const { return at<1>().as_bytes(); }
  bool has_content_frame() const { return at<2>().valid(); }
  ::protozero::ConstBytes content_frame() const { return at<2>().as_bytes(); }
  bool has_decor_frame() const { return at<3>().valid(); }
  ::protozero::ConstBytes decor_frame() const { return at<3>().as_bytes(); }
  bool has_display_frame() const { return at<4>().valid(); }
  ::protozero::ConstBytes display_frame() const { return at<4>().as_bytes(); }
  bool has_frame() const { return at<5>().valid(); }
  ::protozero::ConstBytes frame() const { return at<5>().as_bytes(); }
  bool has_outset_frame() const { return at<6>().valid(); }
  ::protozero::ConstBytes outset_frame() const { return at<6>().as_bytes(); }
  bool has_overscan_frame() const { return at<7>().valid(); }
  ::protozero::ConstBytes overscan_frame() const { return at<7>().as_bytes(); }
  bool has_parent_frame() const { return at<8>().valid(); }
  ::protozero::ConstBytes parent_frame() const { return at<8>().as_bytes(); }
  bool has_visible_frame() const { return at<9>().valid(); }
  ::protozero::ConstBytes visible_frame() const { return at<9>().as_bytes(); }
  bool has_cutout() const { return at<10>().valid(); }
  ::protozero::ConstBytes cutout() const { return at<10>().as_bytes(); }
  bool has_content_insets() const { return at<11>().valid(); }
  ::protozero::ConstBytes content_insets() const { return at<11>().as_bytes(); }
  bool has_overscan_insets() const { return at<12>().valid(); }
  ::protozero::ConstBytes overscan_insets() const { return at<12>().as_bytes(); }
  bool has_visible_insets() const { return at<13>().valid(); }
  ::protozero::ConstBytes visible_insets() const { return at<13>().as_bytes(); }
  bool has_stable_insets() const { return at<14>().valid(); }
  ::protozero::ConstBytes stable_insets() const { return at<14>().as_bytes(); }
  bool has_outsets() const { return at<15>().valid(); }
  ::protozero::ConstBytes outsets() const { return at<15>().as_bytes(); }
  bool has_compat_frame() const { return at<16>().valid(); }
  ::protozero::ConstBytes compat_frame() const { return at<16>().as_bytes(); }
};

class WindowFramesProto : public ::protozero::Message {
 public:
  using Decoder = WindowFramesProto_Decoder;
  enum : int32_t {
    kContainingFrameFieldNumber = 1,
    kContentFrameFieldNumber = 2,
    kDecorFrameFieldNumber = 3,
    kDisplayFrameFieldNumber = 4,
    kFrameFieldNumber = 5,
    kOutsetFrameFieldNumber = 6,
    kOverscanFrameFieldNumber = 7,
    kParentFrameFieldNumber = 8,
    kVisibleFrameFieldNumber = 9,
    kCutoutFieldNumber = 10,
    kContentInsetsFieldNumber = 11,
    kOverscanInsetsFieldNumber = 12,
    kVisibleInsetsFieldNumber = 13,
    kStableInsetsFieldNumber = 14,
    kOutsetsFieldNumber = 15,
    kCompatFrameFieldNumber = 16,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowFramesProto"; }


  using FieldMetadata_ContainingFrame =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_ContainingFrame kContainingFrame{};
  template <typename T = RectProto> T* set_containing_frame() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_ContentFrame =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_ContentFrame kContentFrame{};
  template <typename T = RectProto> T* set_content_frame() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_DecorFrame =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_DecorFrame kDecorFrame{};
  template <typename T = RectProto> T* set_decor_frame() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_DisplayFrame =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_DisplayFrame kDisplayFrame{};
  template <typename T = RectProto> T* set_display_frame() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_Frame =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_Frame kFrame{};
  template <typename T = RectProto> T* set_frame() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_OutsetFrame =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_OutsetFrame kOutsetFrame{};
  template <typename T = RectProto> T* set_outset_frame() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_OverscanFrame =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_OverscanFrame kOverscanFrame{};
  template <typename T = RectProto> T* set_overscan_frame() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_ParentFrame =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_ParentFrame kParentFrame{};
  template <typename T = RectProto> T* set_parent_frame() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_VisibleFrame =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_VisibleFrame kVisibleFrame{};
  template <typename T = RectProto> T* set_visible_frame() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_Cutout =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayCutoutProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_Cutout kCutout{};
  template <typename T = DisplayCutoutProto> T* set_cutout() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_ContentInsets =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_ContentInsets kContentInsets{};
  template <typename T = RectProto> T* set_content_insets() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_OverscanInsets =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_OverscanInsets kOverscanInsets{};
  template <typename T = RectProto> T* set_overscan_insets() {
    return BeginNestedMessage<T>(12);
  }


  using FieldMetadata_VisibleInsets =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_VisibleInsets kVisibleInsets{};
  template <typename T = RectProto> T* set_visible_insets() {
    return BeginNestedMessage<T>(13);
  }


  using FieldMetadata_StableInsets =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_StableInsets kStableInsets{};
  template <typename T = RectProto> T* set_stable_insets() {
    return BeginNestedMessage<T>(14);
  }


  using FieldMetadata_Outsets =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_Outsets kOutsets{};
  template <typename T = RectProto> T* set_outsets() {
    return BeginNestedMessage<T>(15);
  }


  using FieldMetadata_CompatFrame =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowFramesProto>;

  static constexpr FieldMetadata_CompatFrame kCompatFrame{};
  template <typename T = RectProto> T* set_compat_frame() {
    return BeginNestedMessage<T>(16);
  }

};

class ConfigurationContainerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ConfigurationContainerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ConfigurationContainerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ConfigurationContainerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_override_configuration() const { return at<1>().valid(); }
  ::protozero::ConstBytes override_configuration() const { return at<1>().as_bytes(); }
  bool has_full_configuration() const { return at<2>().valid(); }
  ::protozero::ConstBytes full_configuration() const { return at<2>().as_bytes(); }
  bool has_merged_override_configuration() const { return at<3>().valid(); }
  ::protozero::ConstBytes merged_override_configuration() const { return at<3>().as_bytes(); }
};

class ConfigurationContainerProto : public ::protozero::Message {
 public:
  using Decoder = ConfigurationContainerProto_Decoder;
  enum : int32_t {
    kOverrideConfigurationFieldNumber = 1,
    kFullConfigurationFieldNumber = 2,
    kMergedOverrideConfigurationFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ConfigurationContainerProto"; }


  using FieldMetadata_OverrideConfiguration =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ConfigurationProto,
      ConfigurationContainerProto>;

  static constexpr FieldMetadata_OverrideConfiguration kOverrideConfiguration{};
  template <typename T = ConfigurationProto> T* set_override_configuration() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_FullConfiguration =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ConfigurationProto,
      ConfigurationContainerProto>;

  static constexpr FieldMetadata_FullConfiguration kFullConfiguration{};
  template <typename T = ConfigurationProto> T* set_full_configuration() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_MergedOverrideConfiguration =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ConfigurationProto,
      ConfigurationContainerProto>;

  static constexpr FieldMetadata_MergedOverrideConfiguration kMergedOverrideConfiguration{};
  template <typename T = ConfigurationProto> T* set_merged_override_configuration() {
    return BeginNestedMessage<T>(3);
  }

};

class WindowContainerChildProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowContainerChildProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowContainerChildProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowContainerChildProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<2>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<2>().as_bytes(); }
  bool has_display_content() const { return at<3>().valid(); }
  ::protozero::ConstBytes display_content() const { return at<3>().as_bytes(); }
  bool has_display_area() const { return at<4>().valid(); }
  ::protozero::ConstBytes display_area() const { return at<4>().as_bytes(); }
  bool has_task() const { return at<5>().valid(); }
  ::protozero::ConstBytes task() const { return at<5>().as_bytes(); }
  bool has_activity() const { return at<6>().valid(); }
  ::protozero::ConstBytes activity() const { return at<6>().as_bytes(); }
  bool has_window_token() const { return at<7>().valid(); }
  ::protozero::ConstBytes window_token() const { return at<7>().as_bytes(); }
  bool has_window() const { return at<8>().valid(); }
  ::protozero::ConstBytes window() const { return at<8>().as_bytes(); }
  bool has_task_fragment() const { return at<9>().valid(); }
  ::protozero::ConstBytes task_fragment() const { return at<9>().as_bytes(); }
};

class WindowContainerChildProto : public ::protozero::Message {
 public:
  using Decoder = WindowContainerChildProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 2,
    kDisplayContentFieldNumber = 3,
    kDisplayAreaFieldNumber = 4,
    kTaskFieldNumber = 5,
    kActivityFieldNumber = 6,
    kWindowTokenFieldNumber = 7,
    kWindowFieldNumber = 8,
    kTaskFragmentFieldNumber = 9,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowContainerChildProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_DisplayContent =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayContentProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_DisplayContent kDisplayContent{};
  template <typename T = DisplayContentProto> T* set_display_content() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_DisplayArea =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayAreaProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_DisplayArea kDisplayArea{};
  template <typename T = DisplayAreaProto> T* set_display_area() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_Task =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_Task kTask{};
  template <typename T = TaskProto> T* set_task() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_Activity =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ActivityRecordProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_Activity kActivity{};
  template <typename T = ActivityRecordProto> T* set_activity() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_WindowToken =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_WindowToken kWindowToken{};
  template <typename T = WindowTokenProto> T* set_window_token() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_Window =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_Window kWindow{};
  template <typename T = WindowStateProto> T* set_window() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_TaskFragment =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskFragmentProto,
      WindowContainerChildProto>;

  static constexpr FieldMetadata_TaskFragment kTaskFragment{};
  template <typename T = TaskFragmentProto> T* set_task_fragment() {
    return BeginNestedMessage<T>(9);
  }

};

class WindowContainerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  WindowContainerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowContainerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowContainerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_configuration_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes configuration_container() const { return at<1>().as_bytes(); }
  bool has_orientation() const { return at<2>().valid(); }
  int32_t orientation() const { return at<2>().as_int32(); }
  bool has_visible() const { return at<3>().valid(); }
  bool visible() const { return at<3>().as_bool(); }
  bool has_surface_animator() const { return at<4>().valid(); }
  ::protozero::ConstBytes surface_animator() const { return at<4>().as_bytes(); }
  bool has_children() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> children() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_identifier() const { return at<6>().valid(); }
  ::protozero::ConstBytes identifier() const { return at<6>().as_bytes(); }
  bool has_surface_control() const { return at<7>().valid(); }
  ::protozero::ConstBytes surface_control() const { return at<7>().as_bytes(); }
};

class WindowContainerProto : public ::protozero::Message {
 public:
  using Decoder = WindowContainerProto_Decoder;
  enum : int32_t {
    kConfigurationContainerFieldNumber = 1,
    kOrientationFieldNumber = 2,
    kVisibleFieldNumber = 3,
    kSurfaceAnimatorFieldNumber = 4,
    kChildrenFieldNumber = 5,
    kIdentifierFieldNumber = 6,
    kSurfaceControlFieldNumber = 7,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowContainerProto"; }


  using FieldMetadata_ConfigurationContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ConfigurationContainerProto,
      WindowContainerProto>;

  static constexpr FieldMetadata_ConfigurationContainer kConfigurationContainer{};
  template <typename T = ConfigurationContainerProto> T* set_configuration_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Orientation =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowContainerProto>;

  static constexpr FieldMetadata_Orientation kOrientation{};
  void set_orientation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Orientation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Visible =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowContainerProto>;

  static constexpr FieldMetadata_Visible kVisible{};
  void set_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Visible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SurfaceAnimator =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SurfaceAnimatorProto,
      WindowContainerProto>;

  static constexpr FieldMetadata_SurfaceAnimator kSurfaceAnimator{};
  template <typename T = SurfaceAnimatorProto> T* set_surface_animator() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_Children =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerChildProto,
      WindowContainerProto>;

  static constexpr FieldMetadata_Children kChildren{};
  template <typename T = WindowContainerChildProto> T* add_children() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_Identifier =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowContainerProto>;

  static constexpr FieldMetadata_Identifier kIdentifier{};
  template <typename T = IdentifierProto> T* set_identifier() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_SurfaceControl =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      SurfaceControlProto,
      WindowContainerProto>;

  static constexpr FieldMetadata_SurfaceControl kSurfaceControl{};
  template <typename T = SurfaceControlProto> T* set_surface_control() {
    return BeginNestedMessage<T>(7);
  }

};

class ScreenRotationAnimationProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ScreenRotationAnimationProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ScreenRotationAnimationProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ScreenRotationAnimationProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_started() const { return at<1>().valid(); }
  bool started() const { return at<1>().as_bool(); }
  bool has_animation_running() const { return at<2>().valid(); }
  bool animation_running() const { return at<2>().as_bool(); }
};

class ScreenRotationAnimationProto : public ::protozero::Message {
 public:
  using Decoder = ScreenRotationAnimationProto_Decoder;
  enum : int32_t {
    kStartedFieldNumber = 1,
    kAnimationRunningFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ScreenRotationAnimationProto"; }


  using FieldMetadata_Started =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ScreenRotationAnimationProto>;

  static constexpr FieldMetadata_Started kStarted{};
  void set_started(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Started::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnimationRunning =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ScreenRotationAnimationProto>;

  static constexpr FieldMetadata_AnimationRunning kAnimationRunning{};
  void set_animation_running(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimationRunning::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class WindowSurfaceControllerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowSurfaceControllerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowSurfaceControllerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowSurfaceControllerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_shown() const { return at<1>().valid(); }
  bool shown() const { return at<1>().as_bool(); }
  bool has_layer() const { return at<2>().valid(); }
  int32_t layer() const { return at<2>().as_int32(); }
};

class WindowSurfaceControllerProto : public ::protozero::Message {
 public:
  using Decoder = WindowSurfaceControllerProto_Decoder;
  enum : int32_t {
    kShownFieldNumber = 1,
    kLayerFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowSurfaceControllerProto"; }


  using FieldMetadata_Shown =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowSurfaceControllerProto>;

  static constexpr FieldMetadata_Shown kShown{};
  void set_shown(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Shown::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Layer =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowSurfaceControllerProto>;

  static constexpr FieldMetadata_Layer kLayer{};
  void set_layer(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Layer::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class WindowStateAnimatorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowStateAnimatorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowStateAnimatorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowStateAnimatorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_last_clip_rect() const { return at<1>().valid(); }
  ::protozero::ConstBytes last_clip_rect() const { return at<1>().as_bytes(); }
  bool has_surface() const { return at<2>().valid(); }
  ::protozero::ConstBytes surface() const { return at<2>().as_bytes(); }
  bool has_draw_state() const { return at<3>().valid(); }
  int32_t draw_state() const { return at<3>().as_int32(); }
  bool has_system_decor_rect() const { return at<4>().valid(); }
  ::protozero::ConstBytes system_decor_rect() const { return at<4>().as_bytes(); }
};

class WindowStateAnimatorProto : public ::protozero::Message {
 public:
  using Decoder = WindowStateAnimatorProto_Decoder;
  enum : int32_t {
    kLastClipRectFieldNumber = 1,
    kSurfaceFieldNumber = 2,
    kDrawStateFieldNumber = 3,
    kSystemDecorRectFieldNumber = 4,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowStateAnimatorProto"; }


  using DrawState = ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState;
  static inline const char* DrawState_Name(DrawState value) {
    return ::perfetto::protos::pbzero::WindowStateAnimatorProto_DrawState_Name(value);
  }
  static inline const DrawState NO_SURFACE = DrawState::NO_SURFACE;
  static inline const DrawState DRAW_PENDING = DrawState::DRAW_PENDING;
  static inline const DrawState COMMIT_DRAW_PENDING = DrawState::COMMIT_DRAW_PENDING;
  static inline const DrawState READY_TO_SHOW = DrawState::READY_TO_SHOW;
  static inline const DrawState HAS_DRAWN = DrawState::HAS_DRAWN;

  using FieldMetadata_LastClipRect =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateAnimatorProto>;

  static constexpr FieldMetadata_LastClipRect kLastClipRect{};
  template <typename T = RectProto> T* set_last_clip_rect() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Surface =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowSurfaceControllerProto,
      WindowStateAnimatorProto>;

  static constexpr FieldMetadata_Surface kSurface{};
  template <typename T = WindowSurfaceControllerProto> T* set_surface() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_DrawState =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      WindowStateAnimatorProto_DrawState,
      WindowStateAnimatorProto>;

  static constexpr FieldMetadata_DrawState kDrawState{};
  void set_draw_state(WindowStateAnimatorProto_DrawState value) {
    static constexpr uint32_t field_id = FieldMetadata_DrawState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemDecorRect =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateAnimatorProto>;

  static constexpr FieldMetadata_SystemDecorRect kSystemDecorRect{};
  template <typename T = RectProto> T* set_system_decor_rect() {
    return BeginNestedMessage<T>(4);
  }

};

class IdentifierProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IdentifierProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IdentifierProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IdentifierProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_hash_code() const { return at<1>().valid(); }
  int32_t hash_code() const { return at<1>().as_int32(); }
  bool has_user_id() const { return at<2>().valid(); }
  int32_t user_id() const { return at<2>().as_int32(); }
  bool has_title() const { return at<3>().valid(); }
  ::protozero::ConstChars title() const { return at<3>().as_string(); }
};

class IdentifierProto : public ::protozero::Message {
 public:
  using Decoder = IdentifierProto_Decoder;
  enum : int32_t {
    kHashCodeFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kTitleFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.IdentifierProto"; }


  using FieldMetadata_HashCode =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      IdentifierProto>;

  static constexpr FieldMetadata_HashCode kHashCode{};
  void set_hash_code(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HashCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_UserId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      IdentifierProto>;

  static constexpr FieldMetadata_UserId kUserId{};
  void set_user_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_UserId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Title =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      IdentifierProto>;

  static constexpr FieldMetadata_Title kTitle{};
  void set_title(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Title::kFieldId, data, size);
  }
  void set_title(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Title::kFieldId, chars.data, chars.size);
  }
  void set_title(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Title::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class WindowStateProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/49, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  WindowStateProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowStateProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowStateProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_identifier() const { return at<2>().valid(); }
  ::protozero::ConstBytes identifier() const { return at<2>().as_bytes(); }
  bool has_display_id() const { return at<3>().valid(); }
  int32_t display_id() const { return at<3>().as_int32(); }
  bool has_stack_id() const { return at<4>().valid(); }
  int32_t stack_id() const { return at<4>().as_int32(); }
  bool has_attributes() const { return at<5>().valid(); }
  ::protozero::ConstBytes attributes() const { return at<5>().as_bytes(); }
  bool has_given_content_insets() const { return at<6>().valid(); }
  ::protozero::ConstBytes given_content_insets() const { return at<6>().as_bytes(); }
  bool has_frame() const { return at<7>().valid(); }
  ::protozero::ConstBytes frame() const { return at<7>().as_bytes(); }
  bool has_containing_frame() const { return at<8>().valid(); }
  ::protozero::ConstBytes containing_frame() const { return at<8>().as_bytes(); }
  bool has_parent_frame() const { return at<9>().valid(); }
  ::protozero::ConstBytes parent_frame() const { return at<9>().as_bytes(); }
  bool has_content_frame() const { return at<10>().valid(); }
  ::protozero::ConstBytes content_frame() const { return at<10>().as_bytes(); }
  bool has_content_insets() const { return at<11>().valid(); }
  ::protozero::ConstBytes content_insets() const { return at<11>().as_bytes(); }
  bool has_surface_insets() const { return at<12>().valid(); }
  ::protozero::ConstBytes surface_insets() const { return at<12>().as_bytes(); }
  bool has_animator() const { return at<13>().valid(); }
  ::protozero::ConstBytes animator() const { return at<13>().as_bytes(); }
  bool has_animating_exit() const { return at<14>().valid(); }
  bool animating_exit() const { return at<14>().as_bool(); }
  bool has_child_windows() const { return at<15>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> child_windows() const { return GetRepeated<::protozero::ConstBytes>(15); }
  bool has_surface_position() const { return at<16>().valid(); }
  ::protozero::ConstBytes surface_position() const { return at<16>().as_bytes(); }
  bool has_requested_width() const { return at<18>().valid(); }
  int32_t requested_width() const { return at<18>().as_int32(); }
  bool has_requested_height() const { return at<19>().valid(); }
  int32_t requested_height() const { return at<19>().as_int32(); }
  bool has_view_visibility() const { return at<20>().valid(); }
  int32_t view_visibility() const { return at<20>().as_int32(); }
  bool has_system_ui_visibility() const { return at<21>().valid(); }
  int32_t system_ui_visibility() const { return at<21>().as_int32(); }
  bool has_has_surface() const { return at<22>().valid(); }
  bool has_surface() const { return at<22>().as_bool(); }
  bool has_is_ready_for_display() const { return at<23>().valid(); }
  bool is_ready_for_display() const { return at<23>().as_bool(); }
  bool has_display_frame() const { return at<24>().valid(); }
  ::protozero::ConstBytes display_frame() const { return at<24>().as_bytes(); }
  bool has_overscan_frame() const { return at<25>().valid(); }
  ::protozero::ConstBytes overscan_frame() const { return at<25>().as_bytes(); }
  bool has_visible_frame() const { return at<26>().valid(); }
  ::protozero::ConstBytes visible_frame() const { return at<26>().as_bytes(); }
  bool has_decor_frame() const { return at<27>().valid(); }
  ::protozero::ConstBytes decor_frame() const { return at<27>().as_bytes(); }
  bool has_outset_frame() const { return at<28>().valid(); }
  ::protozero::ConstBytes outset_frame() const { return at<28>().as_bytes(); }
  bool has_overscan_insets() const { return at<29>().valid(); }
  ::protozero::ConstBytes overscan_insets() const { return at<29>().as_bytes(); }
  bool has_visible_insets() const { return at<30>().valid(); }
  ::protozero::ConstBytes visible_insets() const { return at<30>().as_bytes(); }
  bool has_stable_insets() const { return at<31>().valid(); }
  ::protozero::ConstBytes stable_insets() const { return at<31>().as_bytes(); }
  bool has_outsets() const { return at<32>().valid(); }
  ::protozero::ConstBytes outsets() const { return at<32>().as_bytes(); }
  bool has_cutout() const { return at<33>().valid(); }
  ::protozero::ConstBytes cutout() const { return at<33>().as_bytes(); }
  bool has_remove_on_exit() const { return at<34>().valid(); }
  bool remove_on_exit() const { return at<34>().as_bool(); }
  bool has_destroying() const { return at<35>().valid(); }
  bool destroying() const { return at<35>().as_bool(); }
  bool has_removed() const { return at<36>().valid(); }
  bool removed() const { return at<36>().as_bool(); }
  bool has_is_on_screen() const { return at<37>().valid(); }
  bool is_on_screen() const { return at<37>().as_bool(); }
  bool has_is_visible() const { return at<38>().valid(); }
  bool is_visible() const { return at<38>().as_bool(); }
  bool has_pending_seamless_rotation() const { return at<39>().valid(); }
  bool pending_seamless_rotation() const { return at<39>().as_bool(); }
  bool has_finished_seamless_rotation_frame() const { return at<40>().valid(); }
  int64_t finished_seamless_rotation_frame() const { return at<40>().as_int64(); }
  bool has_window_frames() const { return at<41>().valid(); }
  ::protozero::ConstBytes window_frames() const { return at<41>().as_bytes(); }
  bool has_force_seamless_rotation() const { return at<42>().valid(); }
  bool force_seamless_rotation() const { return at<42>().as_bool(); }
  bool has_has_compat_scale() const { return at<43>().valid(); }
  bool has_compat_scale() const { return at<43>().as_bool(); }
  bool has_global_scale() const { return at<44>().valid(); }
  float global_scale() const { return at<44>().as_float(); }
  bool has_keep_clear_areas() const { return at<45>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> keep_clear_areas() const { return GetRepeated<::protozero::ConstBytes>(45); }
  bool has_unrestricted_keep_clear_areas() const { return at<46>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> unrestricted_keep_clear_areas() const { return GetRepeated<::protozero::ConstBytes>(46); }
  bool has_mergedlocalinsetssources() const { return at<47>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mergedlocalinsetssources() const { return GetRepeated<::protozero::ConstBytes>(47); }
  bool has_requested_visible_types() const { return at<48>().valid(); }
  int32_t requested_visible_types() const { return at<48>().as_int32(); }
  bool has_dim_bounds() const { return at<49>().valid(); }
  ::protozero::ConstBytes dim_bounds() const { return at<49>().as_bytes(); }
};

class WindowStateProto : public ::protozero::Message {
 public:
  using Decoder = WindowStateProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kIdentifierFieldNumber = 2,
    kDisplayIdFieldNumber = 3,
    kStackIdFieldNumber = 4,
    kAttributesFieldNumber = 5,
    kGivenContentInsetsFieldNumber = 6,
    kFrameFieldNumber = 7,
    kContainingFrameFieldNumber = 8,
    kParentFrameFieldNumber = 9,
    kContentFrameFieldNumber = 10,
    kContentInsetsFieldNumber = 11,
    kSurfaceInsetsFieldNumber = 12,
    kAnimatorFieldNumber = 13,
    kAnimatingExitFieldNumber = 14,
    kChildWindowsFieldNumber = 15,
    kSurfacePositionFieldNumber = 16,
    kRequestedWidthFieldNumber = 18,
    kRequestedHeightFieldNumber = 19,
    kViewVisibilityFieldNumber = 20,
    kSystemUiVisibilityFieldNumber = 21,
    kHasSurfaceFieldNumber = 22,
    kIsReadyForDisplayFieldNumber = 23,
    kDisplayFrameFieldNumber = 24,
    kOverscanFrameFieldNumber = 25,
    kVisibleFrameFieldNumber = 26,
    kDecorFrameFieldNumber = 27,
    kOutsetFrameFieldNumber = 28,
    kOverscanInsetsFieldNumber = 29,
    kVisibleInsetsFieldNumber = 30,
    kStableInsetsFieldNumber = 31,
    kOutsetsFieldNumber = 32,
    kCutoutFieldNumber = 33,
    kRemoveOnExitFieldNumber = 34,
    kDestroyingFieldNumber = 35,
    kRemovedFieldNumber = 36,
    kIsOnScreenFieldNumber = 37,
    kIsVisibleFieldNumber = 38,
    kPendingSeamlessRotationFieldNumber = 39,
    kFinishedSeamlessRotationFrameFieldNumber = 40,
    kWindowFramesFieldNumber = 41,
    kForceSeamlessRotationFieldNumber = 42,
    kHasCompatScaleFieldNumber = 43,
    kGlobalScaleFieldNumber = 44,
    kKeepClearAreasFieldNumber = 45,
    kUnrestrictedKeepClearAreasFieldNumber = 46,
    kMergedLocalInsetsSourcesFieldNumber = 47,
    kRequestedVisibleTypesFieldNumber = 48,
    kDimBoundsFieldNumber = 49,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowStateProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      WindowStateProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Identifier =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Identifier kIdentifier{};
  template <typename T = IdentifierProto> T* set_identifier() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_DisplayId =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_DisplayId kDisplayId{};
  void set_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StackId =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_StackId kStackId{};
  void set_stack_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_StackId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Attributes =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowLayoutParamsProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Attributes kAttributes{};
  template <typename T = WindowLayoutParamsProto> T* set_attributes() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_GivenContentInsets =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_GivenContentInsets kGivenContentInsets{};
  template <typename T = RectProto> T* set_given_content_insets() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_Frame =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Frame kFrame{};
  template <typename T = RectProto> T* set_frame() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_ContainingFrame =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_ContainingFrame kContainingFrame{};
  template <typename T = RectProto> T* set_containing_frame() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_ParentFrame =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_ParentFrame kParentFrame{};
  template <typename T = RectProto> T* set_parent_frame() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_ContentFrame =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_ContentFrame kContentFrame{};
  template <typename T = RectProto> T* set_content_frame() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_ContentInsets =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_ContentInsets kContentInsets{};
  template <typename T = RectProto> T* set_content_insets() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_SurfaceInsets =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_SurfaceInsets kSurfaceInsets{};
  template <typename T = RectProto> T* set_surface_insets() {
    return BeginNestedMessage<T>(12);
  }


  using FieldMetadata_Animator =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateAnimatorProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Animator kAnimator{};
  template <typename T = WindowStateAnimatorProto> T* set_animator() {
    return BeginNestedMessage<T>(13);
  }


  using FieldMetadata_AnimatingExit =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_AnimatingExit kAnimatingExit{};
  void set_animating_exit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimatingExit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ChildWindows =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      WindowStateProto>;

  static constexpr FieldMetadata_ChildWindows kChildWindows{};
  template <typename T = WindowStateProto> T* add_child_windows() {
    return BeginNestedMessage<T>(15);
  }


  using FieldMetadata_SurfacePosition =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_SurfacePosition kSurfacePosition{};
  template <typename T = RectProto> T* set_surface_position() {
    return BeginNestedMessage<T>(16);
  }


  using FieldMetadata_RequestedWidth =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_RequestedWidth kRequestedWidth{};
  void set_requested_width(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RequestedWidth::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RequestedHeight =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_RequestedHeight kRequestedHeight{};
  void set_requested_height(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RequestedHeight::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ViewVisibility =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_ViewVisibility kViewVisibility{};
  void set_view_visibility(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ViewVisibility::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SystemUiVisibility =
    ::protozero::proto_utils::FieldMetadata<
      21,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_SystemUiVisibility kSystemUiVisibility{};
  void set_system_ui_visibility(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SystemUiVisibility::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasSurface =
    ::protozero::proto_utils::FieldMetadata<
      22,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_HasSurface kHasSurface{};
  void set_has_surface(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasSurface::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsReadyForDisplay =
    ::protozero::proto_utils::FieldMetadata<
      23,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_IsReadyForDisplay kIsReadyForDisplay{};
  void set_is_ready_for_display(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsReadyForDisplay::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayFrame =
    ::protozero::proto_utils::FieldMetadata<
      24,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_DisplayFrame kDisplayFrame{};
  template <typename T = RectProto> T* set_display_frame() {
    return BeginNestedMessage<T>(24);
  }


  using FieldMetadata_OverscanFrame =
    ::protozero::proto_utils::FieldMetadata<
      25,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_OverscanFrame kOverscanFrame{};
  template <typename T = RectProto> T* set_overscan_frame() {
    return BeginNestedMessage<T>(25);
  }


  using FieldMetadata_VisibleFrame =
    ::protozero::proto_utils::FieldMetadata<
      26,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_VisibleFrame kVisibleFrame{};
  template <typename T = RectProto> T* set_visible_frame() {
    return BeginNestedMessage<T>(26);
  }


  using FieldMetadata_DecorFrame =
    ::protozero::proto_utils::FieldMetadata<
      27,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_DecorFrame kDecorFrame{};
  template <typename T = RectProto> T* set_decor_frame() {
    return BeginNestedMessage<T>(27);
  }


  using FieldMetadata_OutsetFrame =
    ::protozero::proto_utils::FieldMetadata<
      28,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_OutsetFrame kOutsetFrame{};
  template <typename T = RectProto> T* set_outset_frame() {
    return BeginNestedMessage<T>(28);
  }


  using FieldMetadata_OverscanInsets =
    ::protozero::proto_utils::FieldMetadata<
      29,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_OverscanInsets kOverscanInsets{};
  template <typename T = RectProto> T* set_overscan_insets() {
    return BeginNestedMessage<T>(29);
  }


  using FieldMetadata_VisibleInsets =
    ::protozero::proto_utils::FieldMetadata<
      30,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_VisibleInsets kVisibleInsets{};
  template <typename T = RectProto> T* set_visible_insets() {
    return BeginNestedMessage<T>(30);
  }


  using FieldMetadata_StableInsets =
    ::protozero::proto_utils::FieldMetadata<
      31,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_StableInsets kStableInsets{};
  template <typename T = RectProto> T* set_stable_insets() {
    return BeginNestedMessage<T>(31);
  }


  using FieldMetadata_Outsets =
    ::protozero::proto_utils::FieldMetadata<
      32,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Outsets kOutsets{};
  template <typename T = RectProto> T* set_outsets() {
    return BeginNestedMessage<T>(32);
  }


  using FieldMetadata_Cutout =
    ::protozero::proto_utils::FieldMetadata<
      33,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayCutoutProto,
      WindowStateProto>;

  static constexpr FieldMetadata_Cutout kCutout{};
  template <typename T = DisplayCutoutProto> T* set_cutout() {
    return BeginNestedMessage<T>(33);
  }


  using FieldMetadata_RemoveOnExit =
    ::protozero::proto_utils::FieldMetadata<
      34,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_RemoveOnExit kRemoveOnExit{};
  void set_remove_on_exit(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_RemoveOnExit::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Destroying =
    ::protozero::proto_utils::FieldMetadata<
      35,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_Destroying kDestroying{};
  void set_destroying(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Destroying::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Removed =
    ::protozero::proto_utils::FieldMetadata<
      36,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_Removed kRemoved{};
  void set_removed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Removed::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsOnScreen =
    ::protozero::proto_utils::FieldMetadata<
      37,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_IsOnScreen kIsOnScreen{};
  void set_is_on_screen(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsOnScreen::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsVisible =
    ::protozero::proto_utils::FieldMetadata<
      38,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_IsVisible kIsVisible{};
  void set_is_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PendingSeamlessRotation =
    ::protozero::proto_utils::FieldMetadata<
      39,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_PendingSeamlessRotation kPendingSeamlessRotation{};
  void set_pending_seamless_rotation(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_PendingSeamlessRotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FinishedSeamlessRotationFrame =
    ::protozero::proto_utils::FieldMetadata<
      40,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt64,
      int64_t,
      WindowStateProto>;

  static constexpr FieldMetadata_FinishedSeamlessRotationFrame kFinishedSeamlessRotationFrame{};
  void set_finished_seamless_rotation_frame(int64_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FinishedSeamlessRotationFrame::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt64>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowFrames =
    ::protozero::proto_utils::FieldMetadata<
      41,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowFramesProto,
      WindowStateProto>;

  static constexpr FieldMetadata_WindowFrames kWindowFrames{};
  template <typename T = WindowFramesProto> T* set_window_frames() {
    return BeginNestedMessage<T>(41);
  }


  using FieldMetadata_ForceSeamlessRotation =
    ::protozero::proto_utils::FieldMetadata<
      42,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_ForceSeamlessRotation kForceSeamlessRotation{};
  void set_force_seamless_rotation(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ForceSeamlessRotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasCompatScale =
    ::protozero::proto_utils::FieldMetadata<
      43,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowStateProto>;

  static constexpr FieldMetadata_HasCompatScale kHasCompatScale{};
  void set_has_compat_scale(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasCompatScale::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_GlobalScale =
    ::protozero::proto_utils::FieldMetadata<
      44,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      WindowStateProto>;

  static constexpr FieldMetadata_GlobalScale kGlobalScale{};
  void set_global_scale(float value) {
    static constexpr uint32_t field_id = FieldMetadata_GlobalScale::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeepClearAreas =
    ::protozero::proto_utils::FieldMetadata<
      45,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_KeepClearAreas kKeepClearAreas{};
  template <typename T = RectProto> T* add_keep_clear_areas() {
    return BeginNestedMessage<T>(45);
  }


  using FieldMetadata_UnrestrictedKeepClearAreas =
    ::protozero::proto_utils::FieldMetadata<
      46,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_UnrestrictedKeepClearAreas kUnrestrictedKeepClearAreas{};
  template <typename T = RectProto> T* add_unrestricted_keep_clear_areas() {
    return BeginNestedMessage<T>(46);
  }


  using FieldMetadata_MergedLocalInsetsSources =
    ::protozero::proto_utils::FieldMetadata<
      47,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceProto,
      WindowStateProto>;

  static constexpr FieldMetadata_MergedLocalInsetsSources kMergedLocalInsetsSources{};
  template <typename T = InsetsSourceProto> T* add_mergedlocalinsetssources() {
    return BeginNestedMessage<T>(47);
  }


  using FieldMetadata_RequestedVisibleTypes =
    ::protozero::proto_utils::FieldMetadata<
      48,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowStateProto>;

  static constexpr FieldMetadata_RequestedVisibleTypes kRequestedVisibleTypes{};
  void set_requested_visible_types(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RequestedVisibleTypes::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DimBounds =
    ::protozero::proto_utils::FieldMetadata<
      49,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      WindowStateProto>;

  static constexpr FieldMetadata_DimBounds kDimBounds{};
  template <typename T = RectProto> T* set_dim_bounds() {
    return BeginNestedMessage<T>(49);
  }

};

class WindowTokenProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  WindowTokenProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowTokenProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowTokenProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_hash_code() const { return at<2>().valid(); }
  int32_t hash_code() const { return at<2>().as_int32(); }
  bool has_windows() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> windows() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_waiting_to_show() const { return at<5>().valid(); }
  bool waiting_to_show() const { return at<5>().as_bool(); }
  bool has_paused() const { return at<6>().valid(); }
  bool paused() const { return at<6>().as_bool(); }
};

class WindowTokenProto : public ::protozero::Message {
 public:
  using Decoder = WindowTokenProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kHashCodeFieldNumber = 2,
    kWindowsFieldNumber = 3,
    kWaitingToShowFieldNumber = 5,
    kPausedFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowTokenProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      WindowTokenProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_HashCode =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowTokenProto>;

  static constexpr FieldMetadata_HashCode kHashCode{};
  void set_hash_code(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_HashCode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Windows =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      WindowTokenProto>;

  static constexpr FieldMetadata_Windows kWindows{};
  template <typename T = WindowStateProto> T* add_windows() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_WaitingToShow =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowTokenProto>;

  static constexpr FieldMetadata_WaitingToShow kWaitingToShow{};
  void set_waiting_to_show(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_WaitingToShow::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Paused =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowTokenProto>;

  static constexpr FieldMetadata_Paused kPaused{};
  void set_paused(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Paused::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class ActivityRecordProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/201, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ActivityRecordProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ActivityRecordProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ActivityRecordProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_window_token() const { return at<2>().valid(); }
  ::protozero::ConstBytes window_token() const { return at<2>().as_bytes(); }
  bool has_last_surface_showing() const { return at<3>().valid(); }
  bool last_surface_showing() const { return at<3>().as_bool(); }
  bool has_is_waiting_for_transition_start() const { return at<4>().valid(); }
  bool is_waiting_for_transition_start() const { return at<4>().as_bool(); }
  bool has_is_animating() const { return at<5>().valid(); }
  bool is_animating() const { return at<5>().as_bool(); }
  bool has_thumbnail() const { return at<6>().valid(); }
  ::protozero::ConstBytes thumbnail() const { return at<6>().as_bytes(); }
  bool has_fills_parent() const { return at<7>().valid(); }
  bool fills_parent() const { return at<7>().as_bool(); }
  bool has_app_stopped() const { return at<8>().valid(); }
  bool app_stopped() const { return at<8>().as_bool(); }
  bool has_visible_requested() const { return at<9>().valid(); }
  bool visible_requested() const { return at<9>().as_bool(); }
  bool has_client_visible() const { return at<10>().valid(); }
  bool client_visible() const { return at<10>().as_bool(); }
  bool has_defer_hiding_client() const { return at<11>().valid(); }
  bool defer_hiding_client() const { return at<11>().as_bool(); }
  bool has_reported_drawn() const { return at<12>().valid(); }
  bool reported_drawn() const { return at<12>().as_bool(); }
  bool has_reported_visible() const { return at<13>().valid(); }
  bool reported_visible() const { return at<13>().as_bool(); }
  bool has_num_interesting_windows() const { return at<14>().valid(); }
  int32_t num_interesting_windows() const { return at<14>().as_int32(); }
  bool has_num_drawn_windows() const { return at<15>().valid(); }
  int32_t num_drawn_windows() const { return at<15>().as_int32(); }
  bool has_all_drawn() const { return at<16>().valid(); }
  bool all_drawn() const { return at<16>().as_bool(); }
  bool has_last_all_drawn() const { return at<17>().valid(); }
  bool last_all_drawn() const { return at<17>().as_bool(); }
  bool has_starting_window() const { return at<19>().valid(); }
  ::protozero::ConstBytes starting_window() const { return at<19>().as_bytes(); }
  bool has_starting_displayed() const { return at<20>().valid(); }
  bool starting_displayed() const { return at<20>().as_bool(); }
  bool has_starting_moved() const { return at<201>().valid(); }
  bool starting_moved() const { return at<201>().as_bool(); }
  bool has_visible_set_from_transferred_starting_window() const { return at<22>().valid(); }
  bool visible_set_from_transferred_starting_window() const { return at<22>().as_bool(); }
  bool has_frozen_bounds() const { return at<23>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> frozen_bounds() const { return GetRepeated<::protozero::ConstBytes>(23); }
  bool has_visible() const { return at<24>().valid(); }
  bool visible() const { return at<24>().as_bool(); }
  bool has_identifier() const { return at<26>().valid(); }
  ::protozero::ConstBytes identifier() const { return at<26>().as_bytes(); }
  bool has_state() const { return at<27>().valid(); }
  ::protozero::ConstChars state() const { return at<27>().as_string(); }
  bool has_front_of_task() const { return at<28>().valid(); }
  bool front_of_task() const { return at<28>().as_bool(); }
  bool has_proc_id() const { return at<29>().valid(); }
  int32_t proc_id() const { return at<29>().as_int32(); }
  bool has_translucent() const { return at<30>().valid(); }
  bool translucent() const { return at<30>().as_bool(); }
  bool has_pip_auto_enter_enabled() const { return at<31>().valid(); }
  bool pip_auto_enter_enabled() const { return at<31>().as_bool(); }
  bool has_in_size_compat_mode() const { return at<32>().valid(); }
  bool in_size_compat_mode() const { return at<32>().as_bool(); }
  bool has_min_aspect_ratio() const { return at<33>().valid(); }
  float min_aspect_ratio() const { return at<33>().as_float(); }
  bool has_provides_max_bounds() const { return at<34>().valid(); }
  bool provides_max_bounds() const { return at<34>().as_bool(); }
  bool has_enable_recents_screenshot() const { return at<35>().valid(); }
  bool enable_recents_screenshot() const { return at<35>().as_bool(); }
  bool has_last_drop_input_mode() const { return at<36>().valid(); }
  int32_t last_drop_input_mode() const { return at<36>().as_int32(); }
  bool has_override_orientation() const { return at<37>().valid(); }
  int32_t override_orientation() const { return at<37>().as_int32(); }
  bool has_should_send_compat_fake_focus() const { return at<38>().valid(); }
  bool should_send_compat_fake_focus() const { return at<38>().as_bool(); }
  bool has_should_force_rotate_for_camera_compat() const { return at<39>().valid(); }
  bool should_force_rotate_for_camera_compat() const { return at<39>().as_bool(); }
  bool has_should_refresh_activity_for_camera_compat() const { return at<40>().valid(); }
  bool should_refresh_activity_for_camera_compat() const { return at<40>().as_bool(); }
  bool has_should_refresh_activity_via_pause_for_camera_compat() const { return at<41>().valid(); }
  bool should_refresh_activity_via_pause_for_camera_compat() const { return at<41>().as_bool(); }
  bool has_should_override_min_aspect_ratio() const { return at<42>().valid(); }
  bool should_override_min_aspect_ratio() const { return at<42>().as_bool(); }
  bool has_should_ignore_orientation_request_loop() const { return at<43>().valid(); }
  bool should_ignore_orientation_request_loop() const { return at<43>().as_bool(); }
  bool has_should_override_force_resize_app() const { return at<44>().valid(); }
  bool should_override_force_resize_app() const { return at<44>().as_bool(); }
  bool has_should_enable_user_aspect_ratio_settings() const { return at<45>().valid(); }
  bool should_enable_user_aspect_ratio_settings() const { return at<45>().as_bool(); }
  bool has_is_user_fullscreen_override_enabled() const { return at<46>().valid(); }
  bool is_user_fullscreen_override_enabled() const { return at<46>().as_bool(); }
};

class ActivityRecordProto : public ::protozero::Message {
 public:
  using Decoder = ActivityRecordProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kWindowTokenFieldNumber = 2,
    kLastSurfaceShowingFieldNumber = 3,
    kIsWaitingForTransitionStartFieldNumber = 4,
    kIsAnimatingFieldNumber = 5,
    kThumbnailFieldNumber = 6,
    kFillsParentFieldNumber = 7,
    kAppStoppedFieldNumber = 8,
    kVisibleRequestedFieldNumber = 9,
    kClientVisibleFieldNumber = 10,
    kDeferHidingClientFieldNumber = 11,
    kReportedDrawnFieldNumber = 12,
    kReportedVisibleFieldNumber = 13,
    kNumInterestingWindowsFieldNumber = 14,
    kNumDrawnWindowsFieldNumber = 15,
    kAllDrawnFieldNumber = 16,
    kLastAllDrawnFieldNumber = 17,
    kStartingWindowFieldNumber = 19,
    kStartingDisplayedFieldNumber = 20,
    kStartingMovedFieldNumber = 201,
    kVisibleSetFromTransferredStartingWindowFieldNumber = 22,
    kFrozenBoundsFieldNumber = 23,
    kVisibleFieldNumber = 24,
    kIdentifierFieldNumber = 26,
    kStateFieldNumber = 27,
    kFrontOfTaskFieldNumber = 28,
    kProcIdFieldNumber = 29,
    kTranslucentFieldNumber = 30,
    kPipAutoEnterEnabledFieldNumber = 31,
    kInSizeCompatModeFieldNumber = 32,
    kMinAspectRatioFieldNumber = 33,
    kProvidesMaxBoundsFieldNumber = 34,
    kEnableRecentsScreenshotFieldNumber = 35,
    kLastDropInputModeFieldNumber = 36,
    kOverrideOrientationFieldNumber = 37,
    kShouldSendCompatFakeFocusFieldNumber = 38,
    kShouldForceRotateForCameraCompatFieldNumber = 39,
    kShouldRefreshActivityForCameraCompatFieldNumber = 40,
    kShouldRefreshActivityViaPauseForCameraCompatFieldNumber = 41,
    kShouldOverrideMinAspectRatioFieldNumber = 42,
    kShouldIgnoreOrientationRequestLoopFieldNumber = 43,
    kShouldOverrideForceResizeAppFieldNumber = 44,
    kShouldEnableUserAspectRatioSettingsFieldNumber = 45,
    kIsUserFullscreenOverrideEnabledFieldNumber = 46,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.ActivityRecordProto"; }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ActivityRecordProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowToken =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      ActivityRecordProto>;

  static constexpr FieldMetadata_WindowToken kWindowToken{};
  template <typename T = WindowTokenProto> T* set_window_token() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_LastSurfaceShowing =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_LastSurfaceShowing kLastSurfaceShowing{};
  void set_last_surface_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_LastSurfaceShowing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsWaitingForTransitionStart =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_IsWaitingForTransitionStart kIsWaitingForTransitionStart{};
  void set_is_waiting_for_transition_start(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsWaitingForTransitionStart::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsAnimating =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_IsAnimating kIsAnimating{};
  void set_is_animating(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsAnimating::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Thumbnail =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerThumbnailProto,
      ActivityRecordProto>;

  static constexpr FieldMetadata_Thumbnail kThumbnail{};
  template <typename T = WindowContainerThumbnailProto> T* set_thumbnail() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_FillsParent =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_FillsParent kFillsParent{};
  void set_fills_parent(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FillsParent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppStopped =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_AppStopped kAppStopped{};
  void set_app_stopped(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AppStopped::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_VisibleRequested =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_VisibleRequested kVisibleRequested{};
  void set_visible_requested(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_VisibleRequested::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ClientVisible =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ClientVisible kClientVisible{};
  void set_client_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ClientVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DeferHidingClient =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_DeferHidingClient kDeferHidingClient{};
  void set_defer_hiding_client(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_DeferHidingClient::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ReportedDrawn =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ReportedDrawn kReportedDrawn{};
  void set_reported_drawn(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ReportedDrawn::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ReportedVisible =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ReportedVisible kReportedVisible{};
  void set_reported_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ReportedVisible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NumInterestingWindows =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActivityRecordProto>;

  static constexpr FieldMetadata_NumInterestingWindows kNumInterestingWindows{};
  void set_num_interesting_windows(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NumInterestingWindows::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_NumDrawnWindows =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActivityRecordProto>;

  static constexpr FieldMetadata_NumDrawnWindows kNumDrawnWindows{};
  void set_num_drawn_windows(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_NumDrawnWindows::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AllDrawn =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_AllDrawn kAllDrawn{};
  void set_all_drawn(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AllDrawn::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastAllDrawn =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_LastAllDrawn kLastAllDrawn{};
  void set_last_all_drawn(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_LastAllDrawn::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartingWindow =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      ActivityRecordProto>;

  static constexpr FieldMetadata_StartingWindow kStartingWindow{};
  template <typename T = IdentifierProto> T* set_starting_window() {
    return BeginNestedMessage<T>(19);
  }


  using FieldMetadata_StartingDisplayed =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_StartingDisplayed kStartingDisplayed{};
  void set_starting_displayed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_StartingDisplayed::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StartingMoved =
    ::protozero::proto_utils::FieldMetadata<
      201,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_StartingMoved kStartingMoved{};
  void set_starting_moved(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_StartingMoved::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_VisibleSetFromTransferredStartingWindow =
    ::protozero::proto_utils::FieldMetadata<
      22,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_VisibleSetFromTransferredStartingWindow kVisibleSetFromTransferredStartingWindow{};
  void set_visible_set_from_transferred_starting_window(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_VisibleSetFromTransferredStartingWindow::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrozenBounds =
    ::protozero::proto_utils::FieldMetadata<
      23,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      ActivityRecordProto>;

  static constexpr FieldMetadata_FrozenBounds kFrozenBounds{};
  template <typename T = RectProto> T* add_frozen_bounds() {
    return BeginNestedMessage<T>(23);
  }


  using FieldMetadata_Visible =
    ::protozero::proto_utils::FieldMetadata<
      24,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_Visible kVisible{};
  void set_visible(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Visible::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Identifier =
    ::protozero::proto_utils::FieldMetadata<
      26,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      ActivityRecordProto>;

  static constexpr FieldMetadata_Identifier kIdentifier{};
  template <typename T = IdentifierProto> T* set_identifier() {
    return BeginNestedMessage<T>(26);
  }


  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      27,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      ActivityRecordProto>;

  static constexpr FieldMetadata_State kState{};
  void set_state(const char* data, size_t size) {
    AppendBytes(FieldMetadata_State::kFieldId, data, size);
  }
  void set_state(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_State::kFieldId, chars.data, chars.size);
  }
  void set_state(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrontOfTask =
    ::protozero::proto_utils::FieldMetadata<
      28,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_FrontOfTask kFrontOfTask{};
  void set_front_of_task(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FrontOfTask::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProcId =
    ::protozero::proto_utils::FieldMetadata<
      29,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ProcId kProcId{};
  void set_proc_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ProcId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Translucent =
    ::protozero::proto_utils::FieldMetadata<
      30,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_Translucent kTranslucent{};
  void set_translucent(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Translucent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PipAutoEnterEnabled =
    ::protozero::proto_utils::FieldMetadata<
      31,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_PipAutoEnterEnabled kPipAutoEnterEnabled{};
  void set_pip_auto_enter_enabled(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_PipAutoEnterEnabled::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InSizeCompatMode =
    ::protozero::proto_utils::FieldMetadata<
      32,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_InSizeCompatMode kInSizeCompatMode{};
  void set_in_size_compat_mode(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_InSizeCompatMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinAspectRatio =
    ::protozero::proto_utils::FieldMetadata<
      33,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      ActivityRecordProto>;

  static constexpr FieldMetadata_MinAspectRatio kMinAspectRatio{};
  void set_min_aspect_ratio(float value) {
    static constexpr uint32_t field_id = FieldMetadata_MinAspectRatio::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ProvidesMaxBounds =
    ::protozero::proto_utils::FieldMetadata<
      34,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ProvidesMaxBounds kProvidesMaxBounds{};
  void set_provides_max_bounds(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ProvidesMaxBounds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_EnableRecentsScreenshot =
    ::protozero::proto_utils::FieldMetadata<
      35,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_EnableRecentsScreenshot kEnableRecentsScreenshot{};
  void set_enable_recents_screenshot(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_EnableRecentsScreenshot::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastDropInputMode =
    ::protozero::proto_utils::FieldMetadata<
      36,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActivityRecordProto>;

  static constexpr FieldMetadata_LastDropInputMode kLastDropInputMode{};
  void set_last_drop_input_mode(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastDropInputMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OverrideOrientation =
    ::protozero::proto_utils::FieldMetadata<
      37,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      ActivityRecordProto>;

  static constexpr FieldMetadata_OverrideOrientation kOverrideOrientation{};
  void set_override_orientation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_OverrideOrientation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldSendCompatFakeFocus =
    ::protozero::proto_utils::FieldMetadata<
      38,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldSendCompatFakeFocus kShouldSendCompatFakeFocus{};
  void set_should_send_compat_fake_focus(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldSendCompatFakeFocus::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldForceRotateForCameraCompat =
    ::protozero::proto_utils::FieldMetadata<
      39,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldForceRotateForCameraCompat kShouldForceRotateForCameraCompat{};
  void set_should_force_rotate_for_camera_compat(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldForceRotateForCameraCompat::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldRefreshActivityForCameraCompat =
    ::protozero::proto_utils::FieldMetadata<
      40,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldRefreshActivityForCameraCompat kShouldRefreshActivityForCameraCompat{};
  void set_should_refresh_activity_for_camera_compat(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldRefreshActivityForCameraCompat::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldRefreshActivityViaPauseForCameraCompat =
    ::protozero::proto_utils::FieldMetadata<
      41,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldRefreshActivityViaPauseForCameraCompat kShouldRefreshActivityViaPauseForCameraCompat{};
  void set_should_refresh_activity_via_pause_for_camera_compat(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldRefreshActivityViaPauseForCameraCompat::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldOverrideMinAspectRatio =
    ::protozero::proto_utils::FieldMetadata<
      42,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldOverrideMinAspectRatio kShouldOverrideMinAspectRatio{};
  void set_should_override_min_aspect_ratio(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldOverrideMinAspectRatio::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldIgnoreOrientationRequestLoop =
    ::protozero::proto_utils::FieldMetadata<
      43,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldIgnoreOrientationRequestLoop kShouldIgnoreOrientationRequestLoop{};
  void set_should_ignore_orientation_request_loop(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldIgnoreOrientationRequestLoop::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldOverrideForceResizeApp =
    ::protozero::proto_utils::FieldMetadata<
      44,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldOverrideForceResizeApp kShouldOverrideForceResizeApp{};
  void set_should_override_force_resize_app(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldOverrideForceResizeApp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ShouldEnableUserAspectRatioSettings =
    ::protozero::proto_utils::FieldMetadata<
      45,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_ShouldEnableUserAspectRatioSettings kShouldEnableUserAspectRatioSettings{};
  void set_should_enable_user_aspect_ratio_settings(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ShouldEnableUserAspectRatioSettings::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsUserFullscreenOverrideEnabled =
    ::protozero::proto_utils::FieldMetadata<
      46,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      ActivityRecordProto>;

  static constexpr FieldMetadata_IsUserFullscreenOverrideEnabled kIsUserFullscreenOverrideEnabled{};
  void set_is_user_fullscreen_override_enabled(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsUserFullscreenOverrideEnabled::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class TaskFragmentProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskFragmentProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskFragmentProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskFragmentProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_display_id() const { return at<2>().valid(); }
  int32_t display_id() const { return at<2>().as_int32(); }
  bool has_activity_type() const { return at<3>().valid(); }
  int32_t activity_type() const { return at<3>().as_int32(); }
  bool has_min_width() const { return at<4>().valid(); }
  int32_t min_width() const { return at<4>().as_int32(); }
  bool has_min_height() const { return at<5>().valid(); }
  int32_t min_height() const { return at<5>().as_int32(); }
};

class TaskFragmentProto : public ::protozero::Message {
 public:
  using Decoder = TaskFragmentProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kDisplayIdFieldNumber = 2,
    kActivityTypeFieldNumber = 3,
    kMinWidthFieldNumber = 4,
    kMinHeightFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TaskFragmentProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      TaskFragmentProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_DisplayId =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskFragmentProto>;

  static constexpr FieldMetadata_DisplayId kDisplayId{};
  void set_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActivityType =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskFragmentProto>;

  static constexpr FieldMetadata_ActivityType kActivityType{};
  void set_activity_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActivityType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinWidth =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskFragmentProto>;

  static constexpr FieldMetadata_MinWidth kMinWidth{};
  void set_min_width(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinWidth::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinHeight =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskFragmentProto>;

  static constexpr FieldMetadata_MinHeight kMinHeight{};
  void set_min_height(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinHeight::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class TaskProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/31, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TaskProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_fills_parent() const { return at<4>().valid(); }
  bool fills_parent() const { return at<4>().as_bool(); }
  bool has_bounds() const { return at<5>().valid(); }
  ::protozero::ConstBytes bounds() const { return at<5>().as_bytes(); }
  bool has_displayed_bounds() const { return at<6>().valid(); }
  ::protozero::ConstBytes displayed_bounds() const { return at<6>().as_bytes(); }
  bool has_defer_removal() const { return at<7>().valid(); }
  bool defer_removal() const { return at<7>().as_bool(); }
  bool has_surface_width() const { return at<8>().valid(); }
  int32_t surface_width() const { return at<8>().as_int32(); }
  bool has_surface_height() const { return at<9>().valid(); }
  int32_t surface_height() const { return at<9>().as_int32(); }
  bool has_tasks() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> tasks() const { return GetRepeated<::protozero::ConstBytes>(10); }
  bool has_activities() const { return at<11>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> activities() const { return GetRepeated<::protozero::ConstBytes>(11); }
  bool has_resumed_activity() const { return at<12>().valid(); }
  ::protozero::ConstBytes resumed_activity() const { return at<12>().as_bytes(); }
  bool has_real_activity() const { return at<13>().valid(); }
  ::protozero::ConstChars real_activity() const { return at<13>().as_string(); }
  bool has_orig_activity() const { return at<14>().valid(); }
  ::protozero::ConstChars orig_activity() const { return at<14>().as_string(); }
  bool has_display_id() const { return at<15>().valid(); }
  int32_t display_id() const { return at<15>().as_int32(); }
  bool has_root_task_id() const { return at<16>().valid(); }
  int32_t root_task_id() const { return at<16>().as_int32(); }
  bool has_activity_type() const { return at<17>().valid(); }
  int32_t activity_type() const { return at<17>().as_int32(); }
  bool has_resize_mode() const { return at<18>().valid(); }
  int32_t resize_mode() const { return at<18>().as_int32(); }
  bool has_min_width() const { return at<19>().valid(); }
  int32_t min_width() const { return at<19>().as_int32(); }
  bool has_min_height() const { return at<20>().valid(); }
  int32_t min_height() const { return at<20>().as_int32(); }
  bool has_adjusted_bounds() const { return at<21>().valid(); }
  ::protozero::ConstBytes adjusted_bounds() const { return at<21>().as_bytes(); }
  bool has_last_non_fullscreen_bounds() const { return at<22>().valid(); }
  ::protozero::ConstBytes last_non_fullscreen_bounds() const { return at<22>().as_bytes(); }
  bool has_adjusted_for_ime() const { return at<23>().valid(); }
  bool adjusted_for_ime() const { return at<23>().as_bool(); }
  bool has_adjust_ime_amount() const { return at<24>().valid(); }
  float adjust_ime_amount() const { return at<24>().as_float(); }
  bool has_adjust_divider_amount() const { return at<25>().valid(); }
  float adjust_divider_amount() const { return at<25>().as_float(); }
  bool has_animating_bounds() const { return at<26>().valid(); }
  bool animating_bounds() const { return at<26>().as_bool(); }
  bool has_minimize_amount() const { return at<27>().valid(); }
  float minimize_amount() const { return at<27>().as_float(); }
  bool has_created_by_organizer() const { return at<28>().valid(); }
  bool created_by_organizer() const { return at<28>().as_bool(); }
  bool has_affinity() const { return at<29>().valid(); }
  ::protozero::ConstChars affinity() const { return at<29>().as_string(); }
  bool has_has_child_pip_activity() const { return at<30>().valid(); }
  bool has_child_pip_activity() const { return at<30>().as_bool(); }
  bool has_task_fragment() const { return at<31>().valid(); }
  ::protozero::ConstBytes task_fragment() const { return at<31>().as_bytes(); }
};

class TaskProto : public ::protozero::Message {
 public:
  using Decoder = TaskProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kIdFieldNumber = 2,
    kFillsParentFieldNumber = 4,
    kBoundsFieldNumber = 5,
    kDisplayedBoundsFieldNumber = 6,
    kDeferRemovalFieldNumber = 7,
    kSurfaceWidthFieldNumber = 8,
    kSurfaceHeightFieldNumber = 9,
    kTasksFieldNumber = 10,
    kActivitiesFieldNumber = 11,
    kResumedActivityFieldNumber = 12,
    kRealActivityFieldNumber = 13,
    kOrigActivityFieldNumber = 14,
    kDisplayIdFieldNumber = 15,
    kRootTaskIdFieldNumber = 16,
    kActivityTypeFieldNumber = 17,
    kResizeModeFieldNumber = 18,
    kMinWidthFieldNumber = 19,
    kMinHeightFieldNumber = 20,
    kAdjustedBoundsFieldNumber = 21,
    kLastNonFullscreenBoundsFieldNumber = 22,
    kAdjustedForImeFieldNumber = 23,
    kAdjustImeAmountFieldNumber = 24,
    kAdjustDividerAmountFieldNumber = 25,
    kAnimatingBoundsFieldNumber = 26,
    kMinimizeAmountFieldNumber = 27,
    kCreatedByOrganizerFieldNumber = 28,
    kAffinityFieldNumber = 29,
    kHasChildPipActivityFieldNumber = 30,
    kTaskFragmentFieldNumber = 31,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.TaskProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      TaskProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FillsParent =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_FillsParent kFillsParent{};
  void set_fills_parent(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FillsParent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Bounds =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      TaskProto>;

  static constexpr FieldMetadata_Bounds kBounds{};
  template <typename T = RectProto> T* set_bounds() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_DisplayedBounds =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      TaskProto>;

  static constexpr FieldMetadata_DisplayedBounds kDisplayedBounds{};
  template <typename T = RectProto> T* set_displayed_bounds() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_DeferRemoval =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_DeferRemoval kDeferRemoval{};
  void set_defer_removal(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_DeferRemoval::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SurfaceWidth =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_SurfaceWidth kSurfaceWidth{};
  void set_surface_width(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SurfaceWidth::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SurfaceHeight =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_SurfaceHeight kSurfaceHeight{};
  void set_surface_height(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SurfaceHeight::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Tasks =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskProto,
      TaskProto>;

  static constexpr FieldMetadata_Tasks kTasks{};
  template <typename T = TaskProto> T* add_tasks() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_Activities =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ActivityRecordProto,
      TaskProto>;

  static constexpr FieldMetadata_Activities kActivities{};
  template <typename T = ActivityRecordProto> T* add_activities() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_ResumedActivity =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      TaskProto>;

  static constexpr FieldMetadata_ResumedActivity kResumedActivity{};
  template <typename T = IdentifierProto> T* set_resumed_activity() {
    return BeginNestedMessage<T>(12);
  }


  using FieldMetadata_RealActivity =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TaskProto>;

  static constexpr FieldMetadata_RealActivity kRealActivity{};
  void set_real_activity(const char* data, size_t size) {
    AppendBytes(FieldMetadata_RealActivity::kFieldId, data, size);
  }
  void set_real_activity(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_RealActivity::kFieldId, chars.data, chars.size);
  }
  void set_real_activity(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_RealActivity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_OrigActivity =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TaskProto>;

  static constexpr FieldMetadata_OrigActivity kOrigActivity{};
  void set_orig_activity(const char* data, size_t size) {
    AppendBytes(FieldMetadata_OrigActivity::kFieldId, data, size);
  }
  void set_orig_activity(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_OrigActivity::kFieldId, chars.data, chars.size);
  }
  void set_orig_activity(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_OrigActivity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayId =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_DisplayId kDisplayId{};
  void set_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RootTaskId =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_RootTaskId kRootTaskId{};
  void set_root_task_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_RootTaskId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ActivityType =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_ActivityType kActivityType{};
  void set_activity_type(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ActivityType::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ResizeMode =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_ResizeMode kResizeMode{};
  void set_resize_mode(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ResizeMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinWidth =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_MinWidth kMinWidth{};
  void set_min_width(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinWidth::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinHeight =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      TaskProto>;

  static constexpr FieldMetadata_MinHeight kMinHeight{};
  void set_min_height(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinHeight::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AdjustedBounds =
    ::protozero::proto_utils::FieldMetadata<
      21,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      TaskProto>;

  static constexpr FieldMetadata_AdjustedBounds kAdjustedBounds{};
  template <typename T = RectProto> T* set_adjusted_bounds() {
    return BeginNestedMessage<T>(21);
  }


  using FieldMetadata_LastNonFullscreenBounds =
    ::protozero::proto_utils::FieldMetadata<
      22,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      TaskProto>;

  static constexpr FieldMetadata_LastNonFullscreenBounds kLastNonFullscreenBounds{};
  template <typename T = RectProto> T* set_last_non_fullscreen_bounds() {
    return BeginNestedMessage<T>(22);
  }


  using FieldMetadata_AdjustedForIme =
    ::protozero::proto_utils::FieldMetadata<
      23,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_AdjustedForIme kAdjustedForIme{};
  void set_adjusted_for_ime(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AdjustedForIme::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AdjustImeAmount =
    ::protozero::proto_utils::FieldMetadata<
      24,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TaskProto>;

  static constexpr FieldMetadata_AdjustImeAmount kAdjustImeAmount{};
  void set_adjust_ime_amount(float value) {
    static constexpr uint32_t field_id = FieldMetadata_AdjustImeAmount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AdjustDividerAmount =
    ::protozero::proto_utils::FieldMetadata<
      25,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TaskProto>;

  static constexpr FieldMetadata_AdjustDividerAmount kAdjustDividerAmount{};
  void set_adjust_divider_amount(float value) {
    static constexpr uint32_t field_id = FieldMetadata_AdjustDividerAmount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AnimatingBounds =
    ::protozero::proto_utils::FieldMetadata<
      26,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_AnimatingBounds kAnimatingBounds{};
  void set_animating_bounds(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AnimatingBounds::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_MinimizeAmount =
    ::protozero::proto_utils::FieldMetadata<
      27,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kFloat,
      float,
      TaskProto>;

  static constexpr FieldMetadata_MinimizeAmount kMinimizeAmount{};
  void set_minimize_amount(float value) {
    static constexpr uint32_t field_id = FieldMetadata_MinimizeAmount::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kFloat>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_CreatedByOrganizer =
    ::protozero::proto_utils::FieldMetadata<
      28,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_CreatedByOrganizer kCreatedByOrganizer{};
  void set_created_by_organizer(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_CreatedByOrganizer::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Affinity =
    ::protozero::proto_utils::FieldMetadata<
      29,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      TaskProto>;

  static constexpr FieldMetadata_Affinity kAffinity{};
  void set_affinity(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Affinity::kFieldId, data, size);
  }
  void set_affinity(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Affinity::kFieldId, chars.data, chars.size);
  }
  void set_affinity(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Affinity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HasChildPipActivity =
    ::protozero::proto_utils::FieldMetadata<
      30,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      TaskProto>;

  static constexpr FieldMetadata_HasChildPipActivity kHasChildPipActivity{};
  void set_has_child_pip_activity(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HasChildPipActivity::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TaskFragment =
    ::protozero::proto_utils::FieldMetadata<
      31,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskFragmentProto,
      TaskProto>;

  static constexpr FieldMetadata_TaskFragment kTaskFragment{};
  template <typename T = TaskFragmentProto> T* set_task_fragment() {
    return BeginNestedMessage<T>(31);
  }

};

class PinnedTaskControllerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PinnedTaskControllerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PinnedTaskControllerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PinnedTaskControllerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_default_bounds() const { return at<1>().valid(); }
  ::protozero::ConstBytes default_bounds() const { return at<1>().as_bytes(); }
  bool has_movement_bounds() const { return at<2>().valid(); }
  ::protozero::ConstBytes movement_bounds() const { return at<2>().as_bytes(); }
};

class PinnedTaskControllerProto : public ::protozero::Message {
 public:
  using Decoder = PinnedTaskControllerProto_Decoder;
  enum : int32_t {
    kDefaultBoundsFieldNumber = 1,
    kMovementBoundsFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.PinnedTaskControllerProto"; }


  using FieldMetadata_DefaultBounds =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      PinnedTaskControllerProto>;

  static constexpr FieldMetadata_DefaultBounds kDefaultBounds{};
  template <typename T = RectProto> T* set_default_bounds() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_MovementBounds =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      PinnedTaskControllerProto>;

  static constexpr FieldMetadata_MovementBounds kMovementBounds{};
  template <typename T = RectProto> T* set_movement_bounds() {
    return BeginNestedMessage<T>(2);
  }

};

class DockedTaskDividerControllerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DockedTaskDividerControllerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DockedTaskDividerControllerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DockedTaskDividerControllerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_minimized_dock() const { return at<1>().valid(); }
  bool minimized_dock() const { return at<1>().as_bool(); }
};

class DockedTaskDividerControllerProto : public ::protozero::Message {
 public:
  using Decoder = DockedTaskDividerControllerProto_Decoder;
  enum : int32_t {
    kMinimizedDockFieldNumber = 1,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DockedTaskDividerControllerProto"; }


  using FieldMetadata_MinimizedDock =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DockedTaskDividerControllerProto>;

  static constexpr FieldMetadata_MinimizedDock kMinimizedDock{};
  void set_minimized_dock(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_MinimizedDock::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class DisplayRotationProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisplayRotationProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisplayRotationProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisplayRotationProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rotation() const { return at<1>().valid(); }
  int32_t rotation() const { return at<1>().as_int32(); }
  bool has_frozen_to_user_rotation() const { return at<2>().valid(); }
  bool frozen_to_user_rotation() const { return at<2>().as_bool(); }
  bool has_user_rotation() const { return at<3>().valid(); }
  int32_t user_rotation() const { return at<3>().as_int32(); }
  bool has_fixed_to_user_rotation_mode() const { return at<4>().valid(); }
  int32_t fixed_to_user_rotation_mode() const { return at<4>().as_int32(); }
  bool has_last_orientation() const { return at<5>().valid(); }
  int32_t last_orientation() const { return at<5>().as_int32(); }
  bool has_is_fixed_to_user_rotation() const { return at<6>().valid(); }
  bool is_fixed_to_user_rotation() const { return at<6>().as_bool(); }
};

class DisplayRotationProto : public ::protozero::Message {
 public:
  using Decoder = DisplayRotationProto_Decoder;
  enum : int32_t {
    kRotationFieldNumber = 1,
    kFrozenToUserRotationFieldNumber = 2,
    kUserRotationFieldNumber = 3,
    kFixedToUserRotationModeFieldNumber = 4,
    kLastOrientationFieldNumber = 5,
    kIsFixedToUserRotationFieldNumber = 6,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisplayRotationProto"; }


  using FieldMetadata_Rotation =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayRotationProto>;

  static constexpr FieldMetadata_Rotation kRotation{};
  void set_rotation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Rotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FrozenToUserRotation =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayRotationProto>;

  static constexpr FieldMetadata_FrozenToUserRotation kFrozenToUserRotation{};
  void set_frozen_to_user_rotation(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_FrozenToUserRotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_UserRotation =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayRotationProto>;

  static constexpr FieldMetadata_UserRotation kUserRotation{};
  void set_user_rotation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_UserRotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FixedToUserRotationMode =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayRotationProto>;

  static constexpr FieldMetadata_FixedToUserRotationMode kFixedToUserRotationMode{};
  void set_fixed_to_user_rotation_mode(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FixedToUserRotationMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastOrientation =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayRotationProto>;

  static constexpr FieldMetadata_LastOrientation kLastOrientation{};
  void set_last_orientation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastOrientation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsFixedToUserRotation =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayRotationProto>;

  static constexpr FieldMetadata_IsFixedToUserRotation kIsFixedToUserRotation{};
  void set_is_fixed_to_user_rotation(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsFixedToUserRotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class DisplayFramesProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DisplayFramesProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisplayFramesProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisplayFramesProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_stable_bounds() const { return at<1>().valid(); }
  ::protozero::ConstBytes stable_bounds() const { return at<1>().as_bytes(); }
  bool has_dock() const { return at<2>().valid(); }
  ::protozero::ConstBytes dock() const { return at<2>().as_bytes(); }
  bool has_current() const { return at<3>().valid(); }
  ::protozero::ConstBytes current() const { return at<3>().as_bytes(); }
};

class DisplayFramesProto : public ::protozero::Message {
 public:
  using Decoder = DisplayFramesProto_Decoder;
  enum : int32_t {
    kStableBoundsFieldNumber = 1,
    kDockFieldNumber = 2,
    kCurrentFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisplayFramesProto"; }


  using FieldMetadata_StableBounds =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      DisplayFramesProto>;

  static constexpr FieldMetadata_StableBounds kStableBounds{};
  template <typename T = RectProto> T* set_stable_bounds() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Dock =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      DisplayFramesProto>;

  static constexpr FieldMetadata_Dock kDock{};
  template <typename T = RectProto> T* set_dock() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_Current =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      DisplayFramesProto>;

  static constexpr FieldMetadata_Current kCurrent{};
  template <typename T = RectProto> T* set_current() {
    return BeginNestedMessage<T>(3);
  }

};

class DisplayAreaChildProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DisplayAreaChildProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisplayAreaChildProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisplayAreaChildProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_display_area() const { return at<1>().valid(); }
  ::protozero::ConstBytes display_area() const { return at<1>().as_bytes(); }
  bool has_window() const { return at<2>().valid(); }
  ::protozero::ConstBytes window() const { return at<2>().as_bytes(); }
  bool has_unknown() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> unknown() const { return GetRepeated<::protozero::ConstChars>(3); }
};

class DisplayAreaChildProto : public ::protozero::Message {
 public:
  using Decoder = DisplayAreaChildProto_Decoder;
  enum : int32_t {
    kDisplayAreaFieldNumber = 1,
    kWindowFieldNumber = 2,
    kUnknownFieldNumber = 3,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisplayAreaChildProto"; }


  using FieldMetadata_DisplayArea =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayAreaProto,
      DisplayAreaChildProto>;

  static constexpr FieldMetadata_DisplayArea kDisplayArea{};
  template <typename T = DisplayAreaProto> T* set_display_area() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Window =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      DisplayAreaChildProto>;

  static constexpr FieldMetadata_Window kWindow{};
  template <typename T = WindowTokenProto> T* set_window() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_Unknown =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisplayAreaChildProto>;

  static constexpr FieldMetadata_Unknown kUnknown{};
  void add_unknown(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Unknown::kFieldId, data, size);
  }
  void add_unknown(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Unknown::kFieldId, chars.data, chars.size);
  }
  void add_unknown(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Unknown::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }
};

class DisplayAreaProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DisplayAreaProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisplayAreaProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisplayAreaProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_children() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> children() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_is_task_display_area() const { return at<4>().valid(); }
  bool is_task_display_area() const { return at<4>().as_bool(); }
  bool has_is_root_display_area() const { return at<5>().valid(); }
  bool is_root_display_area() const { return at<5>().as_bool(); }
  bool has_feature_id() const { return at<6>().valid(); }
  int32_t feature_id() const { return at<6>().as_int32(); }
  bool has_is_organized() const { return at<7>().valid(); }
  bool is_organized() const { return at<7>().as_bool(); }
  bool has_is_ignoring_orientation_request() const { return at<8>().valid(); }
  bool is_ignoring_orientation_request() const { return at<8>().as_bool(); }
};

class DisplayAreaProto : public ::protozero::Message {
 public:
  using Decoder = DisplayAreaProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kNameFieldNumber = 2,
    kChildrenFieldNumber = 3,
    kIsTaskDisplayAreaFieldNumber = 4,
    kIsRootDisplayAreaFieldNumber = 5,
    kFeatureIdFieldNumber = 6,
    kIsOrganizedFieldNumber = 7,
    kIsIgnoringOrientationRequestFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisplayAreaProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      DisplayAreaProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Name =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisplayAreaProto>;

  static constexpr FieldMetadata_Name kName{};
  void set_name(const char* data, size_t size) {
    AppendBytes(FieldMetadata_Name::kFieldId, data, size);
  }
  void set_name(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_Name::kFieldId, chars.data, chars.size);
  }
  void set_name(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_Name::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Children =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayAreaChildProto,
      DisplayAreaProto>;

  static constexpr FieldMetadata_Children kChildren{};
  template <typename T = DisplayAreaChildProto> T* add_children() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_IsTaskDisplayArea =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayAreaProto>;

  static constexpr FieldMetadata_IsTaskDisplayArea kIsTaskDisplayArea{};
  void set_is_task_display_area(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsTaskDisplayArea::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsRootDisplayArea =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayAreaProto>;

  static constexpr FieldMetadata_IsRootDisplayArea kIsRootDisplayArea{};
  void set_is_root_display_area(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsRootDisplayArea::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FeatureId =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayAreaProto>;

  static constexpr FieldMetadata_FeatureId kFeatureId{};
  void set_feature_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FeatureId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsOrganized =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayAreaProto>;

  static constexpr FieldMetadata_IsOrganized kIsOrganized{};
  void set_is_organized(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsOrganized::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_IsIgnoringOrientationRequest =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayAreaProto>;

  static constexpr FieldMetadata_IsIgnoringOrientationRequest kIsIgnoringOrientationRequest{};
  void set_is_ignoring_orientation_request(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsIgnoringOrientationRequest::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class DisplayContentProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/39, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DisplayContentProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DisplayContentProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DisplayContentProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_docked_task_divider_controller() const { return at<4>().valid(); }
  ::protozero::ConstBytes docked_task_divider_controller() const { return at<4>().as_bytes(); }
  bool has_pinned_task_controller() const { return at<5>().valid(); }
  ::protozero::ConstBytes pinned_task_controller() const { return at<5>().as_bytes(); }
  bool has_above_app_windows() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> above_app_windows() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_below_app_windows() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> below_app_windows() const { return GetRepeated<::protozero::ConstBytes>(7); }
  bool has_ime_windows() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> ime_windows() const { return GetRepeated<::protozero::ConstBytes>(8); }
  bool has_dpi() const { return at<9>().valid(); }
  int32_t dpi() const { return at<9>().as_int32(); }
  bool has_display_info() const { return at<10>().valid(); }
  ::protozero::ConstBytes display_info() const { return at<10>().as_bytes(); }
  bool has_rotation() const { return at<11>().valid(); }
  int32_t rotation() const { return at<11>().as_int32(); }
  bool has_screen_rotation_animation() const { return at<12>().valid(); }
  ::protozero::ConstBytes screen_rotation_animation() const { return at<12>().as_bytes(); }
  bool has_display_frames() const { return at<13>().valid(); }
  ::protozero::ConstBytes display_frames() const { return at<13>().as_bytes(); }
  bool has_surface_size() const { return at<14>().valid(); }
  int32_t surface_size() const { return at<14>().as_int32(); }
  bool has_focused_app() const { return at<15>().valid(); }
  ::protozero::ConstChars focused_app() const { return at<15>().as_string(); }
  bool has_app_transition() const { return at<16>().valid(); }
  ::protozero::ConstBytes app_transition() const { return at<16>().as_bytes(); }
  bool has_opening_apps() const { return at<17>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> opening_apps() const { return GetRepeated<::protozero::ConstBytes>(17); }
  bool has_closing_apps() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> closing_apps() const { return GetRepeated<::protozero::ConstBytes>(18); }
  bool has_changing_apps() const { return at<19>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> changing_apps() const { return GetRepeated<::protozero::ConstBytes>(19); }
  bool has_overlay_windows() const { return at<20>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> overlay_windows() const { return GetRepeated<::protozero::ConstBytes>(20); }
  bool has_root_display_area() const { return at<21>().valid(); }
  ::protozero::ConstBytes root_display_area() const { return at<21>().as_bytes(); }
  bool has_single_task_instance() const { return at<22>().valid(); }
  bool single_task_instance() const { return at<22>().as_bool(); }
  bool has_focused_root_task_id() const { return at<23>().valid(); }
  int32_t focused_root_task_id() const { return at<23>().as_int32(); }
  bool has_resumed_activity() const { return at<24>().valid(); }
  ::protozero::ConstBytes resumed_activity() const { return at<24>().as_bytes(); }
  bool has_tasks() const { return at<25>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> tasks() const { return GetRepeated<::protozero::ConstBytes>(25); }
  bool has_display_ready() const { return at<26>().valid(); }
  bool display_ready() const { return at<26>().as_bool(); }
  bool has_input_method_target() const { return at<27>().valid(); }
  ::protozero::ConstBytes input_method_target() const { return at<27>().as_bytes(); }
  bool has_input_method_input_target() const { return at<28>().valid(); }
  ::protozero::ConstBytes input_method_input_target() const { return at<28>().as_bytes(); }
  bool has_input_method_control_target() const { return at<29>().valid(); }
  ::protozero::ConstBytes input_method_control_target() const { return at<29>().as_bytes(); }
  bool has_current_focus() const { return at<30>().valid(); }
  ::protozero::ConstBytes current_focus() const { return at<30>().as_bytes(); }
  bool has_ime_insets_source_provider() const { return at<31>().valid(); }
  ::protozero::ConstBytes ime_insets_source_provider() const { return at<31>().as_bytes(); }
  bool has_can_show_ime() const { return at<32>().valid(); }
  bool can_show_ime() const { return at<32>().as_bool(); }
  bool has_display_rotation() const { return at<33>().valid(); }
  ::protozero::ConstBytes display_rotation() const { return at<33>().as_bytes(); }
  bool has_ime_policy() const { return at<34>().valid(); }
  int32_t ime_policy() const { return at<34>().as_int32(); }
  bool has_insets_source_providers() const { return at<35>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> insets_source_providers() const { return GetRepeated<::protozero::ConstBytes>(35); }
  bool has_is_sleeping() const { return at<36>().valid(); }
  bool is_sleeping() const { return at<36>().as_bool(); }
  bool has_sleep_tokens() const { return at<37>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> sleep_tokens() const { return GetRepeated<::protozero::ConstChars>(37); }
  bool has_keep_clear_areas() const { return at<38>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> keep_clear_areas() const { return GetRepeated<::protozero::ConstBytes>(38); }
  bool has_min_size_of_resizeable_task_dp() const { return at<39>().valid(); }
  int32_t min_size_of_resizeable_task_dp() const { return at<39>().as_int32(); }
};

class DisplayContentProto : public ::protozero::Message {
 public:
  using Decoder = DisplayContentProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kIdFieldNumber = 2,
    kDockedTaskDividerControllerFieldNumber = 4,
    kPinnedTaskControllerFieldNumber = 5,
    kAboveAppWindowsFieldNumber = 6,
    kBelowAppWindowsFieldNumber = 7,
    kImeWindowsFieldNumber = 8,
    kDpiFieldNumber = 9,
    kDisplayInfoFieldNumber = 10,
    kRotationFieldNumber = 11,
    kScreenRotationAnimationFieldNumber = 12,
    kDisplayFramesFieldNumber = 13,
    kSurfaceSizeFieldNumber = 14,
    kFocusedAppFieldNumber = 15,
    kAppTransitionFieldNumber = 16,
    kOpeningAppsFieldNumber = 17,
    kClosingAppsFieldNumber = 18,
    kChangingAppsFieldNumber = 19,
    kOverlayWindowsFieldNumber = 20,
    kRootDisplayAreaFieldNumber = 21,
    kSingleTaskInstanceFieldNumber = 22,
    kFocusedRootTaskIdFieldNumber = 23,
    kResumedActivityFieldNumber = 24,
    kTasksFieldNumber = 25,
    kDisplayReadyFieldNumber = 26,
    kInputMethodTargetFieldNumber = 27,
    kInputMethodInputTargetFieldNumber = 28,
    kInputMethodControlTargetFieldNumber = 29,
    kCurrentFocusFieldNumber = 30,
    kImeInsetsSourceProviderFieldNumber = 31,
    kCanShowImeFieldNumber = 32,
    kDisplayRotationFieldNumber = 33,
    kImePolicyFieldNumber = 34,
    kInsetsSourceProvidersFieldNumber = 35,
    kIsSleepingFieldNumber = 36,
    kSleepTokensFieldNumber = 37,
    kKeepClearAreasFieldNumber = 38,
    kMinSizeOfResizeableTaskDpFieldNumber = 39,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.DisplayContentProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Id =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_Id kId{};
  void set_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Id::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DockedTaskDividerController =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DockedTaskDividerControllerProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_DockedTaskDividerController kDockedTaskDividerController{};
  template <typename T = DockedTaskDividerControllerProto> T* set_docked_task_divider_controller() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_PinnedTaskController =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      PinnedTaskControllerProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_PinnedTaskController kPinnedTaskController{};
  template <typename T = PinnedTaskControllerProto> T* set_pinned_task_controller() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_AboveAppWindows =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_AboveAppWindows kAboveAppWindows{};
  template <typename T = WindowTokenProto> T* add_above_app_windows() {
    return BeginNestedMessage<T>(6);
  }


  using FieldMetadata_BelowAppWindows =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_BelowAppWindows kBelowAppWindows{};
  template <typename T = WindowTokenProto> T* add_below_app_windows() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_ImeWindows =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ImeWindows kImeWindows{};
  template <typename T = WindowTokenProto> T* add_ime_windows() {
    return BeginNestedMessage<T>(8);
  }


  using FieldMetadata_Dpi =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_Dpi kDpi{};
  void set_dpi(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Dpi::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayInfo =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayInfoProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_DisplayInfo kDisplayInfo{};
  template <typename T = DisplayInfoProto> T* set_display_info() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_Rotation =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_Rotation kRotation{};
  void set_rotation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Rotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScreenRotationAnimation =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ScreenRotationAnimationProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ScreenRotationAnimation kScreenRotationAnimation{};
  template <typename T = ScreenRotationAnimationProto> T* set_screen_rotation_animation() {
    return BeginNestedMessage<T>(12);
  }


  using FieldMetadata_DisplayFrames =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayFramesProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_DisplayFrames kDisplayFrames{};
  template <typename T = DisplayFramesProto> T* set_display_frames() {
    return BeginNestedMessage<T>(13);
  }


  using FieldMetadata_SurfaceSize =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_SurfaceSize kSurfaceSize{};
  void set_surface_size(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_SurfaceSize::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FocusedApp =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisplayContentProto>;

  static constexpr FieldMetadata_FocusedApp kFocusedApp{};
  void set_focused_app(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FocusedApp::kFieldId, data, size);
  }
  void set_focused_app(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FocusedApp::kFieldId, chars.data, chars.size);
  }
  void set_focused_app(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FocusedApp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AppTransition =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      AppTransitionProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_AppTransition kAppTransition{};
  template <typename T = AppTransitionProto> T* set_app_transition() {
    return BeginNestedMessage<T>(16);
  }


  using FieldMetadata_OpeningApps =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_OpeningApps kOpeningApps{};
  template <typename T = IdentifierProto> T* add_opening_apps() {
    return BeginNestedMessage<T>(17);
  }


  using FieldMetadata_ClosingApps =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ClosingApps kClosingApps{};
  template <typename T = IdentifierProto> T* add_closing_apps() {
    return BeginNestedMessage<T>(18);
  }


  using FieldMetadata_ChangingApps =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ChangingApps kChangingApps{};
  template <typename T = IdentifierProto> T* add_changing_apps() {
    return BeginNestedMessage<T>(19);
  }


  using FieldMetadata_OverlayWindows =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowTokenProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_OverlayWindows kOverlayWindows{};
  template <typename T = WindowTokenProto> T* add_overlay_windows() {
    return BeginNestedMessage<T>(20);
  }


  using FieldMetadata_RootDisplayArea =
    ::protozero::proto_utils::FieldMetadata<
      21,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayAreaProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_RootDisplayArea kRootDisplayArea{};
  template <typename T = DisplayAreaProto> T* set_root_display_area() {
    return BeginNestedMessage<T>(21);
  }


  using FieldMetadata_SingleTaskInstance =
    ::protozero::proto_utils::FieldMetadata<
      22,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayContentProto>;

  static constexpr FieldMetadata_SingleTaskInstance kSingleTaskInstance{};
  void set_single_task_instance(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_SingleTaskInstance::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FocusedRootTaskId =
    ::protozero::proto_utils::FieldMetadata<
      23,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_FocusedRootTaskId kFocusedRootTaskId{};
  void set_focused_root_task_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FocusedRootTaskId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ResumedActivity =
    ::protozero::proto_utils::FieldMetadata<
      24,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ResumedActivity kResumedActivity{};
  template <typename T = IdentifierProto> T* set_resumed_activity() {
    return BeginNestedMessage<T>(24);
  }


  using FieldMetadata_Tasks =
    ::protozero::proto_utils::FieldMetadata<
      25,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      TaskProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_Tasks kTasks{};
  template <typename T = TaskProto> T* add_tasks() {
    return BeginNestedMessage<T>(25);
  }


  using FieldMetadata_DisplayReady =
    ::protozero::proto_utils::FieldMetadata<
      26,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayContentProto>;

  static constexpr FieldMetadata_DisplayReady kDisplayReady{};
  void set_display_ready(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayReady::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InputMethodTarget =
    ::protozero::proto_utils::FieldMetadata<
      27,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_InputMethodTarget kInputMethodTarget{};
  template <typename T = WindowStateProto> T* set_input_method_target() {
    return BeginNestedMessage<T>(27);
  }


  using FieldMetadata_InputMethodInputTarget =
    ::protozero::proto_utils::FieldMetadata<
      28,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_InputMethodInputTarget kInputMethodInputTarget{};
  template <typename T = WindowStateProto> T* set_input_method_input_target() {
    return BeginNestedMessage<T>(28);
  }


  using FieldMetadata_InputMethodControlTarget =
    ::protozero::proto_utils::FieldMetadata<
      29,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_InputMethodControlTarget kInputMethodControlTarget{};
  template <typename T = WindowStateProto> T* set_input_method_control_target() {
    return BeginNestedMessage<T>(29);
  }


  using FieldMetadata_CurrentFocus =
    ::protozero::proto_utils::FieldMetadata<
      30,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_CurrentFocus kCurrentFocus{};
  template <typename T = WindowStateProto> T* set_current_focus() {
    return BeginNestedMessage<T>(30);
  }


  using FieldMetadata_ImeInsetsSourceProvider =
    ::protozero::proto_utils::FieldMetadata<
      31,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      ImeInsetsSourceProviderProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_ImeInsetsSourceProvider kImeInsetsSourceProvider{};
  template <typename T = ImeInsetsSourceProviderProto> T* set_ime_insets_source_provider() {
    return BeginNestedMessage<T>(31);
  }


  using FieldMetadata_CanShowIme =
    ::protozero::proto_utils::FieldMetadata<
      32,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayContentProto>;

  static constexpr FieldMetadata_CanShowIme kCanShowIme{};
  void set_can_show_ime(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_CanShowIme::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_DisplayRotation =
    ::protozero::proto_utils::FieldMetadata<
      33,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayRotationProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_DisplayRotation kDisplayRotation{};
  template <typename T = DisplayRotationProto> T* set_display_rotation() {
    return BeginNestedMessage<T>(33);
  }


  using FieldMetadata_ImePolicy =
    ::protozero::proto_utils::FieldMetadata<
      34,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_ImePolicy kImePolicy{};
  void set_ime_policy(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_ImePolicy::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InsetsSourceProviders =
    ::protozero::proto_utils::FieldMetadata<
      35,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      InsetsSourceProviderProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_InsetsSourceProviders kInsetsSourceProviders{};
  template <typename T = InsetsSourceProviderProto> T* add_insets_source_providers() {
    return BeginNestedMessage<T>(35);
  }


  using FieldMetadata_IsSleeping =
    ::protozero::proto_utils::FieldMetadata<
      36,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      DisplayContentProto>;

  static constexpr FieldMetadata_IsSleeping kIsSleeping{};
  void set_is_sleeping(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsSleeping::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_SleepTokens =
    ::protozero::proto_utils::FieldMetadata<
      37,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      DisplayContentProto>;

  static constexpr FieldMetadata_SleepTokens kSleepTokens{};
  void add_sleep_tokens(const char* data, size_t size) {
    AppendBytes(FieldMetadata_SleepTokens::kFieldId, data, size);
  }
  void add_sleep_tokens(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_SleepTokens::kFieldId, chars.data, chars.size);
  }
  void add_sleep_tokens(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_SleepTokens::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeepClearAreas =
    ::protozero::proto_utils::FieldMetadata<
      38,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RectProto,
      DisplayContentProto>;

  static constexpr FieldMetadata_KeepClearAreas kKeepClearAreas{};
  template <typename T = RectProto> T* add_keep_clear_areas() {
    return BeginNestedMessage<T>(38);
  }


  using FieldMetadata_MinSizeOfResizeableTaskDp =
    ::protozero::proto_utils::FieldMetadata<
      39,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      DisplayContentProto>;

  static constexpr FieldMetadata_MinSizeOfResizeableTaskDp kMinSizeOfResizeableTaskDp{};
  void set_min_size_of_resizeable_task_dp(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_MinSizeOfResizeableTaskDp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class AppTransitionProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AppTransitionProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AppTransitionProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AppTransitionProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_app_transition_state() const { return at<1>().valid(); }
  int32_t app_transition_state() const { return at<1>().as_int32(); }
  bool has_last_used_app_transition() const { return at<2>().valid(); }
  int32_t last_used_app_transition() const { return at<2>().as_int32(); }
};

class AppTransitionProto : public ::protozero::Message {
 public:
  using Decoder = AppTransitionProto_Decoder;
  enum : int32_t {
    kAppTransitionStateFieldNumber = 1,
    kLastUsedAppTransitionFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.AppTransitionProto"; }


  using AppState = ::perfetto::protos::pbzero::AppTransitionProto_AppState;
  static inline const char* AppState_Name(AppState value) {
    return ::perfetto::protos::pbzero::AppTransitionProto_AppState_Name(value);
  }
  static inline const AppState APP_STATE_IDLE = AppState::APP_STATE_IDLE;
  static inline const AppState APP_STATE_READY = AppState::APP_STATE_READY;
  static inline const AppState APP_STATE_RUNNING = AppState::APP_STATE_RUNNING;
  static inline const AppState APP_STATE_TIMEOUT = AppState::APP_STATE_TIMEOUT;

  using FieldMetadata_AppTransitionState =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      AppTransitionProto_AppState,
      AppTransitionProto>;

  static constexpr FieldMetadata_AppTransitionState kAppTransitionState{};
  void set_app_transition_state(AppTransitionProto_AppState value) {
    static constexpr uint32_t field_id = FieldMetadata_AppTransitionState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastUsedAppTransition =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      TransitionTypeEnum,
      AppTransitionProto>;

  static constexpr FieldMetadata_LastUsedAppTransition kLastUsedAppTransition{};
  void set_last_used_app_transition(TransitionTypeEnum value) {
    static constexpr uint32_t field_id = FieldMetadata_LastUsedAppTransition::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class WindowManagerPolicyProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowManagerPolicyProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowManagerPolicyProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowManagerPolicyProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_last_system_ui_flags() const { return at<1>().valid(); }
  int32_t last_system_ui_flags() const { return at<1>().as_int32(); }
  bool has_rotation_mode() const { return at<2>().valid(); }
  int32_t rotation_mode() const { return at<2>().as_int32(); }
  bool has_rotation() const { return at<3>().valid(); }
  int32_t rotation() const { return at<3>().as_int32(); }
  bool has_orientation() const { return at<4>().valid(); }
  int32_t orientation() const { return at<4>().as_int32(); }
  bool has_screen_on_fully() const { return at<5>().valid(); }
  bool screen_on_fully() const { return at<5>().as_bool(); }
  bool has_keyguard_draw_complete() const { return at<6>().valid(); }
  bool keyguard_draw_complete() const { return at<6>().as_bool(); }
  bool has_window_manager_draw_complete() const { return at<7>().valid(); }
  bool window_manager_draw_complete() const { return at<7>().as_bool(); }
  bool has_focused_app_token() const { return at<8>().valid(); }
  ::protozero::ConstChars focused_app_token() const { return at<8>().as_string(); }
  bool has_focused_window() const { return at<9>().valid(); }
  ::protozero::ConstBytes focused_window() const { return at<9>().as_bytes(); }
  bool has_top_fullscreen_opaque_window() const { return at<10>().valid(); }
  ::protozero::ConstBytes top_fullscreen_opaque_window() const { return at<10>().as_bytes(); }
  bool has_top_fullscreen_opaque_or_dimming_window() const { return at<11>().valid(); }
  ::protozero::ConstBytes top_fullscreen_opaque_or_dimming_window() const { return at<11>().as_bytes(); }
  bool has_keyguard_occluded() const { return at<12>().valid(); }
  bool keyguard_occluded() const { return at<12>().as_bool(); }
  bool has_keyguard_occluded_changed() const { return at<13>().valid(); }
  bool keyguard_occluded_changed() const { return at<13>().as_bool(); }
  bool has_keyguard_occluded_pending() const { return at<14>().valid(); }
  bool keyguard_occluded_pending() const { return at<14>().as_bool(); }
  bool has_force_status_bar() const { return at<15>().valid(); }
  bool force_status_bar() const { return at<15>().as_bool(); }
  bool has_force_status_bar_from_keyguard() const { return at<16>().valid(); }
  bool force_status_bar_from_keyguard() const { return at<16>().as_bool(); }
  bool has_status_bar() const { return at<17>().valid(); }
  ::protozero::ConstBytes status_bar() const { return at<17>().as_bytes(); }
  bool has_navigation_bar() const { return at<18>().valid(); }
  ::protozero::ConstBytes navigation_bar() const { return at<18>().as_bytes(); }
  bool has_orientation_listener() const { return at<19>().valid(); }
  ::protozero::ConstBytes orientation_listener() const { return at<19>().as_bytes(); }
  bool has_keyguard_delegate() const { return at<20>().valid(); }
  ::protozero::ConstBytes keyguard_delegate() const { return at<20>().as_bytes(); }
};

class WindowManagerPolicyProto : public ::protozero::Message {
 public:
  using Decoder = WindowManagerPolicyProto_Decoder;
  enum : int32_t {
    kLastSystemUiFlagsFieldNumber = 1,
    kRotationModeFieldNumber = 2,
    kRotationFieldNumber = 3,
    kOrientationFieldNumber = 4,
    kScreenOnFullyFieldNumber = 5,
    kKeyguardDrawCompleteFieldNumber = 6,
    kWindowManagerDrawCompleteFieldNumber = 7,
    kFocusedAppTokenFieldNumber = 8,
    kFocusedWindowFieldNumber = 9,
    kTopFullscreenOpaqueWindowFieldNumber = 10,
    kTopFullscreenOpaqueOrDimmingWindowFieldNumber = 11,
    kKeyguardOccludedFieldNumber = 12,
    kKeyguardOccludedChangedFieldNumber = 13,
    kKeyguardOccludedPendingFieldNumber = 14,
    kForceStatusBarFieldNumber = 15,
    kForceStatusBarFromKeyguardFieldNumber = 16,
    kStatusBarFieldNumber = 17,
    kNavigationBarFieldNumber = 18,
    kOrientationListenerFieldNumber = 19,
    kKeyguardDelegateFieldNumber = 20,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowManagerPolicyProto"; }


  using UserRotationMode = ::perfetto::protos::pbzero::WindowManagerPolicyProto_UserRotationMode;
  static inline const char* UserRotationMode_Name(UserRotationMode value) {
    return ::perfetto::protos::pbzero::WindowManagerPolicyProto_UserRotationMode_Name(value);
  }
  static inline const UserRotationMode USER_ROTATION_FREE = UserRotationMode::USER_ROTATION_FREE;
  static inline const UserRotationMode USER_ROTATION_LOCKED = UserRotationMode::USER_ROTATION_LOCKED;

  using FieldMetadata_LastSystemUiFlags =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_LastSystemUiFlags kLastSystemUiFlags{};
  void set_last_system_ui_flags(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastSystemUiFlags::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_RotationMode =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      WindowManagerPolicyProto_UserRotationMode,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_RotationMode kRotationMode{};
  void set_rotation_mode(WindowManagerPolicyProto_UserRotationMode value) {
    static constexpr uint32_t field_id = FieldMetadata_RotationMode::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Rotation =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      SurfaceProto_Rotation,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_Rotation kRotation{};
  void set_rotation(SurfaceProto_Rotation value) {
    static constexpr uint32_t field_id = FieldMetadata_Rotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Orientation =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      ActivityInfoProto_ScreenOrientation,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_Orientation kOrientation{};
  void set_orientation(ActivityInfoProto_ScreenOrientation value) {
    static constexpr uint32_t field_id = FieldMetadata_Orientation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScreenOnFully =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_ScreenOnFully kScreenOnFully{};
  void set_screen_on_fully(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ScreenOnFully::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardDrawComplete =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_KeyguardDrawComplete kKeyguardDrawComplete{};
  void set_keyguard_draw_complete(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardDrawComplete::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowManagerDrawComplete =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_WindowManagerDrawComplete kWindowManagerDrawComplete{};
  void set_window_manager_draw_complete(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_WindowManagerDrawComplete::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FocusedAppToken =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_FocusedAppToken kFocusedAppToken{};
  void set_focused_app_token(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FocusedAppToken::kFieldId, data, size);
  }
  void set_focused_app_token(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FocusedAppToken::kFieldId, chars.data, chars.size);
  }
  void set_focused_app_token(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FocusedAppToken::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FocusedWindow =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_FocusedWindow kFocusedWindow{};
  template <typename T = IdentifierProto> T* set_focused_window() {
    return BeginNestedMessage<T>(9);
  }


  using FieldMetadata_TopFullscreenOpaqueWindow =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_TopFullscreenOpaqueWindow kTopFullscreenOpaqueWindow{};
  template <typename T = IdentifierProto> T* set_top_fullscreen_opaque_window() {
    return BeginNestedMessage<T>(10);
  }


  using FieldMetadata_TopFullscreenOpaqueOrDimmingWindow =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_TopFullscreenOpaqueOrDimmingWindow kTopFullscreenOpaqueOrDimmingWindow{};
  template <typename T = IdentifierProto> T* set_top_fullscreen_opaque_or_dimming_window() {
    return BeginNestedMessage<T>(11);
  }


  using FieldMetadata_KeyguardOccluded =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_KeyguardOccluded kKeyguardOccluded{};
  void set_keyguard_occluded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardOccluded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardOccludedChanged =
    ::protozero::proto_utils::FieldMetadata<
      13,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_KeyguardOccludedChanged kKeyguardOccludedChanged{};
  void set_keyguard_occluded_changed(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardOccludedChanged::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardOccludedPending =
    ::protozero::proto_utils::FieldMetadata<
      14,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_KeyguardOccludedPending kKeyguardOccludedPending{};
  void set_keyguard_occluded_pending(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardOccludedPending::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ForceStatusBar =
    ::protozero::proto_utils::FieldMetadata<
      15,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_ForceStatusBar kForceStatusBar{};
  void set_force_status_bar(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ForceStatusBar::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ForceStatusBarFromKeyguard =
    ::protozero::proto_utils::FieldMetadata<
      16,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_ForceStatusBarFromKeyguard kForceStatusBarFromKeyguard{};
  void set_force_status_bar_from_keyguard(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_ForceStatusBarFromKeyguard::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_StatusBar =
    ::protozero::proto_utils::FieldMetadata<
      17,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BarControllerProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_StatusBar kStatusBar{};
  template <typename T = BarControllerProto> T* set_status_bar() {
    return BeginNestedMessage<T>(17);
  }


  using FieldMetadata_NavigationBar =
    ::protozero::proto_utils::FieldMetadata<
      18,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BarControllerProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_NavigationBar kNavigationBar{};
  template <typename T = BarControllerProto> T* set_navigation_bar() {
    return BeginNestedMessage<T>(18);
  }


  using FieldMetadata_OrientationListener =
    ::protozero::proto_utils::FieldMetadata<
      19,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowOrientationListenerProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_OrientationListener kOrientationListener{};
  template <typename T = WindowOrientationListenerProto> T* set_orientation_listener() {
    return BeginNestedMessage<T>(19);
  }


  using FieldMetadata_KeyguardDelegate =
    ::protozero::proto_utils::FieldMetadata<
      20,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KeyguardServiceDelegateProto,
      WindowManagerPolicyProto>;

  static constexpr FieldMetadata_KeyguardDelegate kKeyguardDelegate{};
  template <typename T = KeyguardServiceDelegateProto> T* set_keyguard_delegate() {
    return BeginNestedMessage<T>(20);
  }

};

class KeyguardPerDisplayProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KeyguardPerDisplayProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KeyguardPerDisplayProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KeyguardPerDisplayProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_display_id() const { return at<1>().valid(); }
  int32_t display_id() const { return at<1>().as_int32(); }
  bool has_keyguard_showing() const { return at<2>().valid(); }
  bool keyguard_showing() const { return at<2>().as_bool(); }
  bool has_aod_showing() const { return at<3>().valid(); }
  bool aod_showing() const { return at<3>().as_bool(); }
  bool has_keyguard_occluded() const { return at<4>().valid(); }
  bool keyguard_occluded() const { return at<4>().as_bool(); }
  bool has_keyguard_going_away() const { return at<5>().valid(); }
  bool keyguard_going_away() const { return at<5>().as_bool(); }
};

class KeyguardPerDisplayProto : public ::protozero::Message {
 public:
  using Decoder = KeyguardPerDisplayProto_Decoder;
  enum : int32_t {
    kDisplayIdFieldNumber = 1,
    kKeyguardShowingFieldNumber = 2,
    kAodShowingFieldNumber = 3,
    kKeyguardOccludedFieldNumber = 4,
    kKeyguardGoingAwayFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.KeyguardPerDisplayProto"; }


  using FieldMetadata_DisplayId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      KeyguardPerDisplayProto>;

  static constexpr FieldMetadata_DisplayId kDisplayId{};
  void set_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardShowing =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardPerDisplayProto>;

  static constexpr FieldMetadata_KeyguardShowing kKeyguardShowing{};
  void set_keyguard_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardShowing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_AodShowing =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardPerDisplayProto>;

  static constexpr FieldMetadata_AodShowing kAodShowing{};
  void set_aod_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AodShowing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardOccluded =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardPerDisplayProto>;

  static constexpr FieldMetadata_KeyguardOccluded kKeyguardOccluded{};
  void set_keyguard_occluded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardOccluded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardGoingAway =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardPerDisplayProto>;

  static constexpr FieldMetadata_KeyguardGoingAway kKeyguardGoingAway{};
  void set_keyguard_going_away(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardGoingAway::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class KeyguardOccludedProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KeyguardOccludedProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KeyguardOccludedProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KeyguardOccludedProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_display_id() const { return at<1>().valid(); }
  int32_t display_id() const { return at<1>().as_int32(); }
  bool has_keyguard_occluded() const { return at<2>().valid(); }
  bool keyguard_occluded() const { return at<2>().as_bool(); }
};

class KeyguardOccludedProto : public ::protozero::Message {
 public:
  using Decoder = KeyguardOccludedProto_Decoder;
  enum : int32_t {
    kDisplayIdFieldNumber = 1,
    kKeyguardOccludedFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.KeyguardOccludedProto"; }


  using FieldMetadata_DisplayId =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      KeyguardOccludedProto>;

  static constexpr FieldMetadata_DisplayId kDisplayId{};
  void set_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardOccluded =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardOccludedProto>;

  static constexpr FieldMetadata_KeyguardOccluded kKeyguardOccluded{};
  void set_keyguard_occluded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardOccluded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class KeyguardControllerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  KeyguardControllerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KeyguardControllerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KeyguardControllerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_keyguard_showing() const { return at<1>().valid(); }
  bool keyguard_showing() const { return at<1>().as_bool(); }
  bool has_keyguard_occluded_states() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> keyguard_occluded_states() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_aod_showing() const { return at<3>().valid(); }
  bool aod_showing() const { return at<3>().as_bool(); }
  bool has_keyguard_per_display() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> keyguard_per_display() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_keyguard_going_away() const { return at<5>().valid(); }
  bool keyguard_going_away() const { return at<5>().as_bool(); }
};

class KeyguardControllerProto : public ::protozero::Message {
 public:
  using Decoder = KeyguardControllerProto_Decoder;
  enum : int32_t {
    kKeyguardShowingFieldNumber = 1,
    kKeyguardOccludedStatesFieldNumber = 2,
    kAodShowingFieldNumber = 3,
    kKeyguardPerDisplayFieldNumber = 4,
    kKeyguardGoingAwayFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.KeyguardControllerProto"; }


  using FieldMetadata_KeyguardShowing =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardControllerProto>;

  static constexpr FieldMetadata_KeyguardShowing kKeyguardShowing{};
  void set_keyguard_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardShowing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardOccludedStates =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KeyguardOccludedProto,
      KeyguardControllerProto>;

  static constexpr FieldMetadata_KeyguardOccludedStates kKeyguardOccludedStates{};
  template <typename T = KeyguardOccludedProto> T* add_keyguard_occluded_states() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_AodShowing =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardControllerProto>;

  static constexpr FieldMetadata_AodShowing kAodShowing{};
  void set_aod_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_AodShowing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_KeyguardPerDisplay =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KeyguardPerDisplayProto,
      KeyguardControllerProto>;

  static constexpr FieldMetadata_KeyguardPerDisplay kKeyguardPerDisplay{};
  template <typename T = KeyguardPerDisplayProto> T* add_keyguard_per_display() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_KeyguardGoingAway =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardControllerProto>;

  static constexpr FieldMetadata_KeyguardGoingAway kKeyguardGoingAway{};
  void set_keyguard_going_away(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_KeyguardGoingAway::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }
};

class KeyguardServiceDelegateProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KeyguardServiceDelegateProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KeyguardServiceDelegateProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KeyguardServiceDelegateProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_showing() const { return at<1>().valid(); }
  bool showing() const { return at<1>().as_bool(); }
  bool has_occluded() const { return at<2>().valid(); }
  bool occluded() const { return at<2>().as_bool(); }
  bool has_secure() const { return at<3>().valid(); }
  bool secure() const { return at<3>().as_bool(); }
  bool has_screen_state() const { return at<4>().valid(); }
  int32_t screen_state() const { return at<4>().as_int32(); }
  bool has_interactive_state() const { return at<5>().valid(); }
  int32_t interactive_state() const { return at<5>().as_int32(); }
};

class KeyguardServiceDelegateProto : public ::protozero::Message {
 public:
  using Decoder = KeyguardServiceDelegateProto_Decoder;
  enum : int32_t {
    kShowingFieldNumber = 1,
    kOccludedFieldNumber = 2,
    kSecureFieldNumber = 3,
    kScreenStateFieldNumber = 4,
    kInteractiveStateFieldNumber = 5,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.KeyguardServiceDelegateProto"; }


  using ScreenState = ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState;
  static inline const char* ScreenState_Name(ScreenState value) {
    return ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_ScreenState_Name(value);
  }

  using InteractiveState = ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState;
  static inline const char* InteractiveState_Name(InteractiveState value) {
    return ::perfetto::protos::pbzero::KeyguardServiceDelegateProto_InteractiveState_Name(value);
  }
  static inline const ScreenState SCREEN_STATE_OFF = ScreenState::SCREEN_STATE_OFF;
  static inline const ScreenState SCREEN_STATE_TURNING_ON = ScreenState::SCREEN_STATE_TURNING_ON;
  static inline const ScreenState SCREEN_STATE_ON = ScreenState::SCREEN_STATE_ON;
  static inline const ScreenState SCREEN_STATE_TURNING_OFF = ScreenState::SCREEN_STATE_TURNING_OFF;
  static inline const InteractiveState INTERACTIVE_STATE_SLEEP = InteractiveState::INTERACTIVE_STATE_SLEEP;
  static inline const InteractiveState INTERACTIVE_STATE_WAKING = InteractiveState::INTERACTIVE_STATE_WAKING;
  static inline const InteractiveState INTERACTIVE_STATE_AWAKE = InteractiveState::INTERACTIVE_STATE_AWAKE;
  static inline const InteractiveState INTERACTIVE_STATE_GOING_TO_SLEEP = InteractiveState::INTERACTIVE_STATE_GOING_TO_SLEEP;

  using FieldMetadata_Showing =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardServiceDelegateProto>;

  static constexpr FieldMetadata_Showing kShowing{};
  void set_showing(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Showing::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Occluded =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardServiceDelegateProto>;

  static constexpr FieldMetadata_Occluded kOccluded{};
  void set_occluded(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Occluded::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Secure =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      KeyguardServiceDelegateProto>;

  static constexpr FieldMetadata_Secure kSecure{};
  void set_secure(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Secure::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_ScreenState =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      KeyguardServiceDelegateProto_ScreenState,
      KeyguardServiceDelegateProto>;

  static constexpr FieldMetadata_ScreenState kScreenState{};
  void set_screen_state(KeyguardServiceDelegateProto_ScreenState value) {
    static constexpr uint32_t field_id = FieldMetadata_ScreenState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InteractiveState =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      KeyguardServiceDelegateProto_InteractiveState,
      KeyguardServiceDelegateProto>;

  static constexpr FieldMetadata_InteractiveState kInteractiveState{};
  void set_interactive_state(KeyguardServiceDelegateProto_InteractiveState value) {
    static constexpr uint32_t field_id = FieldMetadata_InteractiveState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class WindowOrientationListenerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowOrientationListenerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowOrientationListenerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowOrientationListenerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_enabled() const { return at<1>().valid(); }
  bool enabled() const { return at<1>().as_bool(); }
  bool has_rotation() const { return at<2>().valid(); }
  int32_t rotation() const { return at<2>().as_int32(); }
};

class WindowOrientationListenerProto : public ::protozero::Message {
 public:
  using Decoder = WindowOrientationListenerProto_Decoder;
  enum : int32_t {
    kEnabledFieldNumber = 1,
    kRotationFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowOrientationListenerProto"; }


  using FieldMetadata_Enabled =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowOrientationListenerProto>;

  static constexpr FieldMetadata_Enabled kEnabled{};
  void set_enabled(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_Enabled::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Rotation =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      SurfaceProto_Rotation,
      WindowOrientationListenerProto>;

  static constexpr FieldMetadata_Rotation kRotation{};
  void set_rotation(SurfaceProto_Rotation value) {
    static constexpr uint32_t field_id = FieldMetadata_Rotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class BarControllerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BarControllerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BarControllerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BarControllerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  int32_t state() const { return at<1>().as_int32(); }
  bool has_transient_state() const { return at<2>().valid(); }
  int32_t transient_state() const { return at<2>().as_int32(); }
};

class BarControllerProto : public ::protozero::Message {
 public:
  using Decoder = BarControllerProto_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kTransientStateFieldNumber = 2,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.BarControllerProto"; }


  using FieldMetadata_State =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      StatusBarManagerProto_WindowState,
      BarControllerProto>;

  static constexpr FieldMetadata_State kState{};
  void set_state(StatusBarManagerProto_WindowState value) {
    static constexpr uint32_t field_id = FieldMetadata_State::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_TransientState =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kEnum,
      StatusBarManagerProto_TransientWindowState,
      BarControllerProto>;

  static constexpr FieldMetadata_TransientState kTransientState{};
  void set_transient_state(StatusBarManagerProto_TransientWindowState value) {
    static constexpr uint32_t field_id = FieldMetadata_TransientState::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kEnum>
        ::Append(*this, field_id, value);
  }
};

class RootWindowContainerProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  RootWindowContainerProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RootWindowContainerProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RootWindowContainerProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_window_container() const { return at<1>().valid(); }
  ::protozero::ConstBytes window_container() const { return at<1>().as_bytes(); }
  bool has_displays() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> displays() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_windows() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> windows() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_keyguard_controller() const { return at<5>().valid(); }
  ::protozero::ConstBytes keyguard_controller() const { return at<5>().as_bytes(); }
  bool has_is_home_recents_component() const { return at<6>().valid(); }
  bool is_home_recents_component() const { return at<6>().as_bool(); }
  bool has_pending_activities() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> pending_activities() const { return GetRepeated<::protozero::ConstBytes>(7); }
  bool has_default_min_size_resizable_task() const { return at<8>().valid(); }
  int32_t default_min_size_resizable_task() const { return at<8>().as_int32(); }
};

class RootWindowContainerProto : public ::protozero::Message {
 public:
  using Decoder = RootWindowContainerProto_Decoder;
  enum : int32_t {
    kWindowContainerFieldNumber = 1,
    kDisplaysFieldNumber = 2,
    kWindowsFieldNumber = 4,
    kKeyguardControllerFieldNumber = 5,
    kIsHomeRecentsComponentFieldNumber = 6,
    kPendingActivitiesFieldNumber = 7,
    kDefaultMinSizeResizableTaskFieldNumber = 8,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.RootWindowContainerProto"; }


  using FieldMetadata_WindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowContainerProto,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_WindowContainer kWindowContainer{};
  template <typename T = WindowContainerProto> T* set_window_container() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_Displays =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      DisplayContentProto,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_Displays kDisplays{};
  template <typename T = DisplayContentProto> T* add_displays() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_Windows =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowStateProto,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_Windows kWindows{};
  template <typename T = WindowStateProto> T* add_windows() {
    return BeginNestedMessage<T>(4);
  }


  using FieldMetadata_KeyguardController =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      KeyguardControllerProto,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_KeyguardController kKeyguardController{};
  template <typename T = KeyguardControllerProto> T* set_keyguard_controller() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_IsHomeRecentsComponent =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_IsHomeRecentsComponent kIsHomeRecentsComponent{};
  void set_is_home_recents_component(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_IsHomeRecentsComponent::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_PendingActivities =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kRepeatedNotPacked,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_PendingActivities kPendingActivities{};
  template <typename T = IdentifierProto> T* add_pending_activities() {
    return BeginNestedMessage<T>(7);
  }


  using FieldMetadata_DefaultMinSizeResizableTask =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      RootWindowContainerProto>;

  static constexpr FieldMetadata_DefaultMinSizeResizableTask kDefaultMinSizeResizableTask{};
  void set_default_min_size_resizable_task(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_DefaultMinSizeResizableTask::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }
};

class WindowManagerServiceDumpProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WindowManagerServiceDumpProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WindowManagerServiceDumpProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WindowManagerServiceDumpProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_policy() const { return at<1>().valid(); }
  ::protozero::ConstBytes policy() const { return at<1>().as_bytes(); }
  bool has_root_window_container() const { return at<2>().valid(); }
  ::protozero::ConstBytes root_window_container() const { return at<2>().as_bytes(); }
  bool has_focused_window() const { return at<3>().valid(); }
  ::protozero::ConstBytes focused_window() const { return at<3>().as_bytes(); }
  bool has_focused_app() const { return at<4>().valid(); }
  ::protozero::ConstChars focused_app() const { return at<4>().as_string(); }
  bool has_input_method_window() const { return at<5>().valid(); }
  ::protozero::ConstBytes input_method_window() const { return at<5>().as_bytes(); }
  bool has_display_frozen() const { return at<6>().valid(); }
  bool display_frozen() const { return at<6>().as_bool(); }
  bool has_rotation() const { return at<7>().valid(); }
  int32_t rotation() const { return at<7>().as_int32(); }
  bool has_last_orientation() const { return at<8>().valid(); }
  int32_t last_orientation() const { return at<8>().as_int32(); }
  bool has_focused_display_id() const { return at<9>().valid(); }
  int32_t focused_display_id() const { return at<9>().as_int32(); }
  bool has_hard_keyboard_available() const { return at<10>().valid(); }
  bool hard_keyboard_available() const { return at<10>().as_bool(); }
  bool has_window_frames_valid() const { return at<11>().valid(); }
  bool window_frames_valid() const { return at<11>().as_bool(); }
  bool has_back_navigation() const { return at<12>().valid(); }
  ::protozero::ConstBytes back_navigation() const { return at<12>().as_bytes(); }
};

class WindowManagerServiceDumpProto : public ::protozero::Message {
 public:
  using Decoder = WindowManagerServiceDumpProto_Decoder;
  enum : int32_t {
    kPolicyFieldNumber = 1,
    kRootWindowContainerFieldNumber = 2,
    kFocusedWindowFieldNumber = 3,
    kFocusedAppFieldNumber = 4,
    kInputMethodWindowFieldNumber = 5,
    kDisplayFrozenFieldNumber = 6,
    kRotationFieldNumber = 7,
    kLastOrientationFieldNumber = 8,
    kFocusedDisplayIdFieldNumber = 9,
    kHardKeyboardAvailableFieldNumber = 10,
    kWindowFramesValidFieldNumber = 11,
    kBackNavigationFieldNumber = 12,
  };
  static constexpr const char* GetName() { return ".perfetto.protos.WindowManagerServiceDumpProto"; }


  using FieldMetadata_Policy =
    ::protozero::proto_utils::FieldMetadata<
      1,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      WindowManagerPolicyProto,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_Policy kPolicy{};
  template <typename T = WindowManagerPolicyProto> T* set_policy() {
    return BeginNestedMessage<T>(1);
  }


  using FieldMetadata_RootWindowContainer =
    ::protozero::proto_utils::FieldMetadata<
      2,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      RootWindowContainerProto,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_RootWindowContainer kRootWindowContainer{};
  template <typename T = RootWindowContainerProto> T* set_root_window_container() {
    return BeginNestedMessage<T>(2);
  }


  using FieldMetadata_FocusedWindow =
    ::protozero::proto_utils::FieldMetadata<
      3,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_FocusedWindow kFocusedWindow{};
  template <typename T = IdentifierProto> T* set_focused_window() {
    return BeginNestedMessage<T>(3);
  }


  using FieldMetadata_FocusedApp =
    ::protozero::proto_utils::FieldMetadata<
      4,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kString,
      std::string,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_FocusedApp kFocusedApp{};
  void set_focused_app(const char* data, size_t size) {
    AppendBytes(FieldMetadata_FocusedApp::kFieldId, data, size);
  }
  void set_focused_app(::protozero::ConstChars chars) {
    AppendBytes(FieldMetadata_FocusedApp::kFieldId, chars.data, chars.size);
  }
  void set_focused_app(std::string value) {
    static constexpr uint32_t field_id = FieldMetadata_FocusedApp::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kString>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_InputMethodWindow =
    ::protozero::proto_utils::FieldMetadata<
      5,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      IdentifierProto,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_InputMethodWindow kInputMethodWindow{};
  template <typename T = IdentifierProto> T* set_input_method_window() {
    return BeginNestedMessage<T>(5);
  }


  using FieldMetadata_DisplayFrozen =
    ::protozero::proto_utils::FieldMetadata<
      6,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_DisplayFrozen kDisplayFrozen{};
  void set_display_frozen(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_DisplayFrozen::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_Rotation =
    ::protozero::proto_utils::FieldMetadata<
      7,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_Rotation kRotation{};
  void set_rotation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_Rotation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_LastOrientation =
    ::protozero::proto_utils::FieldMetadata<
      8,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_LastOrientation kLastOrientation{};
  void set_last_orientation(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_LastOrientation::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_FocusedDisplayId =
    ::protozero::proto_utils::FieldMetadata<
      9,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kInt32,
      int32_t,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_FocusedDisplayId kFocusedDisplayId{};
  void set_focused_display_id(int32_t value) {
    static constexpr uint32_t field_id = FieldMetadata_FocusedDisplayId::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kInt32>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_HardKeyboardAvailable =
    ::protozero::proto_utils::FieldMetadata<
      10,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_HardKeyboardAvailable kHardKeyboardAvailable{};
  void set_hard_keyboard_available(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_HardKeyboardAvailable::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_WindowFramesValid =
    ::protozero::proto_utils::FieldMetadata<
      11,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kBool,
      bool,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_WindowFramesValid kWindowFramesValid{};
  void set_window_frames_valid(bool value) {
    static constexpr uint32_t field_id = FieldMetadata_WindowFramesValid::kFieldId;
    // Call the appropriate protozero::Message::Append(field_id, ...)
    // method based on the type of the field.
    ::protozero::internal::FieldWriter<
      ::protozero::proto_utils::ProtoSchemaType::kBool>
        ::Append(*this, field_id, value);
  }

  using FieldMetadata_BackNavigation =
    ::protozero::proto_utils::FieldMetadata<
      12,
      ::protozero::proto_utils::RepetitionType::kNotRepeated,
      ::protozero::proto_utils::ProtoSchemaType::kMessage,
      BackNavigationProto,
      WindowManagerServiceDumpProto>;

  static constexpr FieldMetadata_BackNavigation kBackNavigation{};
  template <typename T = BackNavigationProto> T* set_back_navigation() {
    return BeginNestedMessage<T>(12);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
