/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 *******************************************************************************
 * AUTOGENERATED BY tools/gen_amalgamated_sql.py - DO NOT EDIT
 *******************************************************************************
 */

 #include <string.h>

namespace perfetto {
namespace trace_processor {
namespace stdlib {

const char kAndroidAutoMultiuser[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.startup.startups;

-- Time elapsed between the latest user start
-- and the specific end event
-- like package startup(ex carlauncher) or previous user stop.
CREATE PERFETTO TABLE android_auto_multiuser_timing(
    -- Id of the started android user
    event_start_user_id STRING,
    -- Start event time
    event_start_time LONG,
    -- End event time
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    event_end_time LONG,
    -- End event name
    event_end_name STRING,
    -- Start event name
    event_start_name STRING,
    -- User switch duration from start event
    -- to end event
    duration LONG
) AS
-- The last ts for user switch event.
WITH auto_multiuser_user_start AS (
    SELECT
      slice.name as event_start_name,
      slice.ts AS user_start_time,
      -- Ex.: UserController.startUser-11-fg-start-mode-1
      -- User is enclosed in dashes and will be at most 2 characters(10, 11, etc.)
      SUBSTR(name, INSTR(name, '-') + 1, 2) as started_user_id
    FROM slice
    WHERE (
        slice.name GLOB "UserController.startUser*"
        AND slice.name NOT GLOB "UserController.startUser-10*"
    )
    ORDER BY ts DESC
    LIMIT 1
)
SELECT
  started_user_id AS event_start_user_id,
  user_start_time AS event_start_time,
  event_end_time,
  event_end_name,
  event_start_name,
  (event_end_time - user_start_time) as duration
FROM (
  SELECT
    ts_end AS event_end_time,
    package as event_end_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM android_startups
  UNION
  SELECT
    slice.ts + slice.dur as event_end_time,
    slice.name as event_end_name
  FROM slice
  WHERE slice.name GLOB "finishUserStopped-10*"
) as a
JOIN auto_multiuser_user_start as b
ON a.event_end_time > b.user_start_time;

-- Previous user(user 10) total CPU time
CREATE PERFETTO VIEW _android_auto_user_10_total_cpu_time AS
SELECT
  SUM(dur) as total_cpu_time,
  (uid - android_appid) / 100000 as user_id,
  event_end_name
FROM sched_slice
  JOIN thread USING (utid)
  JOIN process USING (upid),
  android_auto_multiuser_timing
WHERE
  user_id = 10
  AND ts >= android_auto_multiuser_timing.event_start_time
  AND ts <= android_auto_multiuser_timing.event_end_time
GROUP BY event_end_name;

-- Previous user(user 10) total memory usage
CREATE PERFETTO VIEW _android_auto_user_10_total_memory AS
WITH filtered_process AS (
    SELECT
      c.ts,
      c.value,
      p.name AS proc_name,
      (uid - android_appid) / 100000 as user_id,
      event_end_name
    FROM counter AS c
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      LEFT JOIN process_counter_track AS t
        ON c.track_id = t.id
      LEFT JOIN process AS p USING (upid),
      android_auto_multiuser_timing
    WHERE
      t.name GLOB "mem.rss"
      AND user_id = 10
      AND c.ts >= android_auto_multiuser_timing.event_start_time
      AND c.ts <= android_auto_multiuser_timing.event_end_time
),
process_rss AS (
    SELECT
      *,
      ifnull(
        lag(value) OVER (PARTITION BY proc_name, event_end_name ORDER BY ts), value
      ) AS prev_value
    FROM filtered_process
),
per_process_allocations AS (
    SELECT
      proc_name,
      SUM(value - prev_value) / 1e3 AS alloc_value_kb,
      user_id,
      event_end_name
    FROM process_rss
    WHERE value - prev_value > 0
    GROUP BY proc_name, event_end_name
    ORDER BY alloc_value_kb DESC
)
SELECT
  cast_int!(SUM(alloc_value_kb)) AS total_memory_usage_kb,
  user_id,
  event_end_name
FROM per_process_allocations
GROUP BY event_end_name;

-- This table extends `android_auto_multiuser_timing` table with previous user resource usage.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_auto_multiuser_timing_with_previous_user_resource_usage(
    -- Start user id
    event_start_user_id STRING,
    -- Start event time
    event_start_time LONG,
    -- End event time
    event_end_time LONG,
    -- End event name
    event_end_name STRING,
    -- Start event name
    event_start_name STRING,
    -- User switch duration from start event
    -- to end event
    duration LONG,
    -- User id
    user_id LONG,
    -- Total CPU time for a user
    total_cpu_time LONG,
    -- Total memory user for a user
    total_memory_usage_kb LONG
) AS
SELECT
    a.event_start_user_id,
    a.event_start_time,
    a.event_end_time,
    a.event_end_name,
    a.event_start_name,
    a.duration,
    b.user_id,
    b.total_cpu_time,
    c.total_memory_usage_kb
FROM android_auto_multiuser_timing as a
LEFT JOIN _android_auto_user_10_total_cpu_time as b
    ON a.event_end_name = b.event_end_name
LEFT JOIN _android_auto_user_10_total_memory as c
    ON a.event_end_name = c.event_end_name;
)_d3l1m1t3r_"
R"_d3l1m1t3r_()_d3l1m1t3r_"
;

const char kAndroidBatteryChargingStates[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
INCLUDE PERFETTO MODULE counters.intervals;

-- Device charging states.
CREATE PERFETTO TABLE android_charging_states(
  -- Alias of counter.id if a slice with charging state exists otherwise
  -- there will be a single row where id = 1.
  id LONG,
  -- Timestamp at which the device charging state began.
  ts TIMESTAMP,
  -- Duration of the device charging state.
  dur DURATION,
  -- Device charging state, one of: Charging, Discharging, Not charging
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- (when the charger is present but battery is not charging),
  -- Full, Unknown
  charging_state STRING
) AS SELECT
    id,
    ts,
    dur,
    charging_state
  FROM (
    WITH
      _counter AS (
        SELECT counter.id, ts, 0 AS track_id, value
        FROM counter
        JOIN counter_track
          ON counter_track.id = counter.track_id
        WHERE counter_track.name = 'BatteryStatus'
      )
    SELECT
      id,
      ts,
      dur,
      CASE
        value
        -- 0 and 1 are both 'Unknown'
        WHEN 2 THEN 'Charging'
        WHEN 3 THEN 'Discharging'
        -- special case when charger is present but battery isn't charging
        WHEN 4 THEN 'Not charging'
        WHEN 5 THEN 'Full'
        ELSE 'Unknown'
        END AS charging_state
    FROM counter_leading_intervals !(_counter)
    WHERE dur > 0
    -- Either the above select statement is populated or the
    -- select statement after the union is populated but not both.
    UNION
    -- When the trace does not have a slice in the charging state track then
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- we will assume that the charging state for the entire trace is Unknown.
    -- This ensures that we still have job data even if the charging state is
    -- not known. The following statement will only ever return a single row.
    SELECT 1, TRACE_START(), TRACE_DUR(), 'Unknown'
    WHERE NOT EXISTS (
      SELECT * FROM _counter
    ) AND TRACE_DUR() > 0
  );

)_d3l1m1t3r_"
;

const char kAndroidCpuClusterType[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Uses cluster_id which has been calculated using the cpu_capacity in order
-- to determine the cluster type for cpus with 2, 3 or 4 clusters
-- indicating whether they are "little", "medium" or "big".

INCLUDE PERFETTO MODULE intervals.overlap;

CREATE PERFETTO TABLE _cores AS
WITH data(cluster_id, cluster_type, cluster_count) AS (
  VALUES
    (0, 'little', 2), (1, 'big', 2),
    (0, 'little', 3), (1, 'medium', 3), (2, 'big', 3),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    (0, 'little', 4), (1, 'medium', 4), (2, 'medium', 4), (3, 'big', 4)
)
SELECT * FROM data;

-- Stores the mapping of a cpu to its cluster type - e.g. little, medium, big.
-- This cluster type is determined by initially using cpu_capacity from sysfs
-- and grouping clusters with identical capacities, ordered by size.
-- In the case that capacities are not present, max frequency is used instead.
-- If nothing is avaiable, NULL is returned.
CREATE PERFETTO TABLE android_cpu_cluster_mapping (
  -- Alias of `cpu.ucpu`.
  ucpu LONG,
  -- Alias of `cpu.cpu`.
  cpu LONG,
  -- The cluster type of the CPU.
  cluster_type STRING
) AS
SELECT
  ucpu,
  cpu,
  _cores.cluster_type AS cluster_type
FROM
  cpu
LEFT JOIN _cores ON _cores.cluster_id = cpu.cluster_id
AND _cores.cluster_count = (SELECT COUNT(DISTINCT cluster_id) FROM cpu);

-- The count of active CPUs with a given cluster type over time.
CREATE PERFETTO FUNCTION _active_cpu_count_for_cluster_type(
  -- Type of the CPU cluster as reported by android_cpu_cluster_mapping. Usually 'little', 'medium' or 'big'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cluster_type STRING
) RETURNS TABLE(
  -- Timestamp when the number of active CPU changed.
  ts TIMESTAMP,
  -- Number of active CPUs, covering the range from this timestamp to the next
  -- row's timestamp.
  active_cpu_count LONG
) AS
WITH
-- Materialise the relevant clusters to avoid calling a function for each row of the sched table.
cluster AS (
  SELECT ucpu
  FROM android_cpu_cluster_mapping
  WHERE cluster_type = $cluster_type
),
-- Filter sched events corresponding to running tasks.
-- utid=0 is the swapper thread / idle task.
tasks AS (
  SELECT ts, dur
  FROM sched
  WHERE
    ucpu IN (SELECT ucpu FROM cluster)
    AND utid != 0
)
SELECT
  ts, value as active_cpu_count
FROM intervals_overlap_count!(tasks, ts, dur)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidFramesJankType[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Categorizes whether the jank was caused by Surface Flinger
CREATE PERFETTO FUNCTION android_is_sf_jank_type(
  -- the jank type
  -- from args.display_value with key = "Jank type"
  jank_type STRING)
-- True when the jank type represents sf jank
RETURNS BOOL AS
SELECT
       $jank_type GLOB '*SurfaceFlinger CPU Deadline Missed*'
    OR $jank_type GLOB '*SurfaceFlinger GPU Deadline Missed*'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    OR $jank_type GLOB '*SurfaceFlinger Scheduling*'
    OR $jank_type GLOB '*Prediction Error*'
    OR $jank_type GLOB '*Display HAL*';


-- Categorizes whether the jank was caused by the app
CREATE PERFETTO FUNCTION android_is_app_jank_type(
  -- the jank type
  -- from args.display_value with key = "Jank type"
  jank_type STRING)
-- True when the jank type represents app jank
RETURNS BOOL AS
SELECT $jank_type GLOB '*App Deadline Missed*';
)_d3l1m1t3r_"
;

const char kAndroidFramesPerFrameMetrics[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE android.frames.timeline;

-- The amount by which each frame missed of hit its deadline. Negative if the
-- deadline was not missed. Frames are considered janky if `overrun` is
-- positive.
-- Calculated as the difference between the end of the
-- `expected_frame_timeline_slice` and `actual_frame_timeline_slice` for the
-- frame.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Availability: from S (API 31).
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_frames_overrun(
    -- Frame id.
    frame_id LONG,
    -- Difference between `expected` and `actual` frame ends. Negative if frame
    -- didn't miss deadline.
    overrun LONG
) AS
SELECT
    frame_id,
    (act_slice.ts + act_slice.dur) - (exp_slice.ts + exp_slice.dur) AS overrun
FROM _distinct_from_actual_timeline_slice act
JOIN _distinct_from_expected_timeline_slice exp USING (frame_id)
JOIN slice act_slice ON (act.id = act_slice.id)
JOIN slice exp_slice ON (exp.id = exp_slice.id);

-- How much time did the frame's Choreographer callbacks take.
CREATE PERFETTO TABLE android_frames_ui_time(
    -- Frame id
    frame_id LONG,
    -- UI time duration
    ui_time LONG
) AS
SELECT
    frame_id,
    dur AS ui_time
FROM android_frames_choreographer_do_frame f
JOIN slice USING (id);

-- App Vsync delay for a frame. The time between the VSYNC-app signal and the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- start of Choreographer work.
-- Calculated as time difference between the actual frame start (from
-- `actual_frame_timeline_slice`) and start of the `Choreographer#doFrame`
-- slice.
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_app_vsync_delay_per_frame(
    -- Frame id
    frame_id LONG,
    -- App VSYNC delay.
    app_vsync_delay LONG
) AS
-- As there can be multiple `DrawFrame` slices, the `frames_surface_slices`
-- table contains multiple rows for the same `frame_id` which only differ on
-- `draw_frame_id`. As we don't care about `draw_frame_id` we can just collapse
-- them.
WITH distinct_frames AS (
    SELECT
        frame_id,
        do_frame_id,
        actual_frame_timeline_id,
        expected_frame_timeline_id
    FROM android_frames
    GROUP BY 1
)
SELECT
    frame_id,
    act.ts - exp.ts AS app_vsync_delay
FROM distinct_frames f
JOIN slice exp ON (f.expected_frame_timeline_id = exp.id)
JOIN slice act ON (f.actual_frame_timeline_id = act.id);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- How much time did the frame take across the UI Thread + RenderThread.
-- Calculated as sum of `app VSYNC delay` `Choreographer#doFrame` slice
-- duration and summed durations of all `DrawFrame` slices associated with this
-- frame.
-- Availability: from N (API 24).
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_cpu_time_per_frame(
    -- Frame id
    frame_id LONG,
    -- Difference between actual timeline of the frame and
    -- `Choreographer#doFrame`. See `android_app_vsync_delay_per_frame` table for more details.
    app_vsync_delay LONG,
    -- Duration of `Choreographer#doFrame` slice.
    do_frame_dur DURATION,
    -- Duration of `DrawFrame` slice. Summed duration of all `DrawFrame`
    -- slices, if more than one. See `android_frames_draw_frame` for more details.
    draw_frame_dur DURATION,
    -- CPU time across the UI Thread + RenderThread.
    cpu_time LONG
) AS
WITH all_draw_frames AS (
SELECT
    frame_id,
    SUM(dur) as draw_frame_dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_frames_draw_frame
JOIN slice USING (id)
GROUP BY frame_id
),
distinct_frames AS (
    SELECT
        frame_id,
        do_frame_id,
        actual_frame_timeline_id
    FROM android_frames
    GROUP BY 1
)
SELECT
    frame_id,
    app_vsync_delay,
    do_frame.dur AS do_frame_dur,
    draw_frame_dur,
    app_vsync_delay + do_frame.dur + draw_frame_dur AS cpu_time
FROM android_app_vsync_delay_per_frame
JOIN all_draw_frames USING (frame_id)
JOIN distinct_frames f USING (frame_id)
JOIN slice do_frame ON (f.do_frame_id = do_frame.id);

-- CPU time of frames which don't have `android_cpu_time_per_frame` available.
-- Calculated as UI time of the frame + 5ms.
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE _cpu_time_per_frame_fallback(
    -- Frame id.
    frame_id LONG,
    -- Estimated cpu time.
    estimated_cpu_time LONG
) AS
SELECT
    frame_id,
    ui_time + time_from_ms(5) AS estimated_cpu_time
FROM android_frames_ui_time;

CREATE PERFETTO TABLE _estimated_cpu_time_per_frame(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    frame_id LONG,
    cpu_time LONG
) AS
SELECT
    frame_id,
    IIF(r.cpu_time IS NULL, f.estimated_cpu_time, r.cpu_time) AS cpu_time
FROM _cpu_time_per_frame_fallback f
LEFT JOIN android_cpu_time_per_frame r USING (frame_id);

-- Aggregated stats of the frame.
--
-- For Googlers: more details in go/android-performance-metrics-glossary.
CREATE PERFETTO TABLE android_frame_stats(
    -- Frame id.
    frame_id LONG,
    -- The amount by which each frame missed of hit its deadline. See
    -- `android_frames_overrun` for details.
    overrun LONG,
    -- How much time did the frame take across the UI Thread + RenderThread.
    cpu_time LONG,
    -- How much time did the frame's Choreographer callbacks take.
    ui_time LONG,
    -- Was frame janky.
    was_jank BOOL,
    -- CPU time of the frame took over 20ms.
    was_slow_frame BOOL,
    -- CPU time of the frame took over 50ms.
    was_big_jank BOOL,
    -- CPU time of the frame took over 200ms.
    was_huge_jank BOOL
) AS
SELECT
    frame_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    overrun,
    cpu_time,
    ui_time,
    IIF(overrun > 0, 1, NULL) AS was_jank,
    IIF(cpu_time > time_from_ms(20), 1, NULL) AS was_slow_frame,
    IIF(cpu_time > time_from_ms(50), 1, NULL) AS was_big_jank,
    IIF(cpu_time > time_from_ms(200), 1, NULL) AS was_huge_jank
FROM android_frames_overrun
JOIN android_frames_ui_time USING (frame_id)
-- Because some frames might not have CPU time calculated properly (data loss
-- or too old API), we will use fallback cpu time from
-- `_cpu_time_per_frame_fallback`.
JOIN _estimated_cpu_time_per_frame USING (frame_id);


)_d3l1m1t3r_"
;

const char kAndroidFramesTimeline[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE android.frames.timeline_maxsdk28;

-- Parses the slice name to fetch `frame_id` from `slice` table.
-- Use with caution. Slice names are a flaky source of ids and the resulting
-- table might require some further operations.
CREATE PERFETTO FUNCTION _get_frame_table_with_id(
    -- String just before id.
    glob_str STRING
)_d3l1m1t3r_"
R"_d3l1m1t3r_() RETURNS TABLE (
    -- Frame slice.
    id JOINID(slice.id),
    -- Parsed frame id.
    frame_id LONG,
    -- Utid.
    utid JOINID(thread.id),
    -- Upid.
    upid JOINID(process.id),
    -- Timestamp of the frame slice.
    ts TIMESTAMP
) AS
WITH all_found AS (
    SELECT
        id,
        cast_int!(STR_SPLIT(name, ' ', 1)) AS frame_id,
        utid,
        upid,
        ts
    FROM thread_slice
    -- Mostly the frame slice is at depth 0. Though it could be pushed to depth 1 while users
    -- enable low layer trace e.g. atrace_app.
    WHERE name GLOB $glob_str AND depth IN (0, 1)
)
SELECT *
FROM all_found
-- Casting string to int returns 0 if the string can't be cast.
WHERE frame_id != 0;

-- All of the `Choreographer#doFrame` slices with their frame id.
CREATE PERFETTO TABLE android_frames_choreographer_do_frame(
    -- Choreographer#doFrame slice. Slice with the name "Choreographer#doFrame
    -- {frame id}".
    id JOINID(slice.id),
    -- Frame id. Taken as the value behind "Choreographer#doFrame" in slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- name.
    frame_id LONG,
    -- Utid of the UI thread
    ui_thread_utid JOINID(thread.id),
    -- Upid of application process
    upid JOINID(process.id),
    -- Timestamp of the slice.
    ts TIMESTAMP
) AS
SELECT
    id,
    frame_id,
    utid AS ui_thread_utid,
    upid,
    ts
-- Some OEMs have customized `doFrame` to add more information, but we've only
-- observed it added after the frame ID (b/303823815).
FROM _get_frame_table_with_id('Choreographer#doFrame*');

-- All of the `DrawFrame` slices with their frame id and render thread.
-- There might be multiple DrawFrames slices for a single vsync (frame id).
-- This happens when we are drawing multiple layers (e.g. status bar and
-- notifications).
CREATE PERFETTO TABLE android_frames_draw_frame(
    -- DrawFrame slice. Slice with the name "DrawFrame {frame id}".
    id JOINID(slice.id),
    -- Frame id. Taken as the value behind "DrawFrame" in slice
    -- name.
    frame_id LONG,
    -- Utid of the render thread
    render_thread_utid JOINID(thread.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Upid of application process
    upid JOINID(process.id)
) AS
SELECT
    id,
    frame_id,
    utid AS render_thread_utid,
    upid
FROM _get_frame_table_with_id('DrawFrame*');

-- `actual_frame_timeline_slice` returns the same slice on different tracks.
-- We are getting the first slice with one frame id.
CREATE PERFETTO TABLE _distinct_from_actual_timeline_slice AS
SELECT
    cast_int!(name) AS frame_id,
    MIN(id) AS id,
    MIN(ts) AS ts,
    MAX(dur) AS dur,
    MAX(ts + dur) AS ts_end,
    count() AS count
FROM actual_frame_timeline_slice
GROUP BY 1;

-- `expected_frame_timeline_slice` returns the same slice on different tracks.
-- We are getting the first slice with one frame id.
CREATE PERFETTO TABLE _distinct_from_expected_timeline_slice AS
SELECT
    cast_int!(name) AS frame_id,
    id,
    count() AS count
FROM expected_frame_timeline_slice
GROUP BY 1;

-- All slices related to one frame. Aggregates `Choreographer#doFrame`,
-- `DrawFrame`, `actual_frame_timeline_slice` and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- `expected_frame_timeline_slice` slices.
-- See https://perfetto.dev/docs/data-sources/frametimeline for details.
CREATE PERFETTO TABLE android_frames(
    -- Frame id.
    frame_id LONG,
    -- Timestamp of the frame. Start of the frame as defined by the start of
    -- "Choreographer#doFrame" slice and the same as the start of the frame in
    -- `actual_frame_timeline_slice if present.
    ts TIMESTAMP,
    -- Duration of the frame, as defined by the duration of the corresponding
    -- `actual_frame_timeline_slice` or, if not present the time between the
    -- `ts` and the end of the final `DrawFrame`.
    dur DURATION,
    -- "Choreographer#doFrame" slice. The slice with name 
    -- "Choreographer#doFrame" corresponding to this frame.
    do_frame_id JOINID(slice.id),
    -- "DrawFrame" slice. The slice with name "DrawFrame" corresponding to this
    -- frame.
    draw_frame_id JOINID(slice.id),
    -- actual_frame_timeline_slice` slice related to this frame.
    actual_frame_timeline_id JOINID(slice.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- `expected_frame_timeline_slice` slice related to this frame.
    expected_frame_timeline_id JOINID(slice.id),
    -- `utid` of the render thread.
    render_thread_utid JOINID(thread.id),
    -- `utid` of the UI thread.
    ui_thread_utid JOINID(thread.id),
    -- Count of slices in `actual_frame_timeline_slice` related to this frame.
    actual_frame_timeline_count LONG,
    -- Count of slices in `expected_frame_timeline_slice` related to this frame.
    expected_frame_timeline_count LONG
) AS
WITH fallback AS MATERIALIZED (
    SELECT
        frame_id,
        do_frame_slice.ts AS ts,
        MAX(draw_frame_slice.ts + draw_frame_slice.dur) - do_frame_slice.ts AS dur
    FROM android_frames_choreographer_do_frame do_frame
    JOIN android_frames_draw_frame draw_frame USING (frame_id, upid)
    JOIN slice do_frame_slice ON (do_frame.id = do_frame_slice.id)
    JOIN slice draw_frame_slice ON (draw_frame.id = draw_frame_slice.id)
GROUP BY 1
),
frames_sdk_after_28 AS (
SELECT
    frame_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    COALESCE(act.ts, fallback.ts) AS ts,
    COALESCE(act.dur, fallback.dur) AS dur,
    do_frame.id AS do_frame_id,
    draw_frame.id AS draw_frame_id,
    draw_frame.render_thread_utid,
    do_frame.ui_thread_utid,
    "after_28" AS sdk,
    act.id AS actual_frame_timeline_id,
    exp.id AS expected_frame_timeline_id,
    act.count AS actual_frame_timeline_count,
    exp.count AS expected_frame_timeline_count
FROM android_frames_choreographer_do_frame do_frame
JOIN android_frames_draw_frame draw_frame USING (frame_id, upid)
JOIN fallback USING (frame_id)
LEFT JOIN _distinct_from_actual_timeline_slice act USING (frame_id)
LEFT JOIN _distinct_from_expected_timeline_slice exp USING (frame_id)
ORDER BY frame_id
),
all_frames AS (
    SELECT * FROM frames_sdk_after_28
    UNION
    SELECT
        *,
        NULL AS actual_frame_timeline_id,
        NULL AS expected_frame_timeline_id,
        NULL AS actual_frame_timeline_count,
        NULL AS expected_frame_timeline_count
    FROM _frames_maxsdk_28
)_d3l1m1t3r_"
R"_d3l1m1t3r_()
SELECT
    frame_id,
    ts,
    dur,
    do_frame_id,
    draw_frame_id,
    actual_frame_timeline_id,
    expected_frame_timeline_id,
    render_thread_utid,
    ui_thread_utid,
    actual_frame_timeline_count,
    expected_frame_timeline_count
FROM all_frames
WHERE sdk = IIF(
    (SELECT COUNT(1) FROM actual_frame_timeline_slice) > 0,
    "after_28", "maxsdk28");

-- Returns first frame after the provided timestamp. The returning table has at
-- most one row.
CREATE PERFETTO FUNCTION android_first_frame_after(
    -- Timestamp.
    ts TIMESTAMP)
RETURNS TABLE (
    -- Frame id.
    frame_id LONG,
    -- Start of the frame, the timestamp of the "Choreographer#doFrame" slice.
    ts TIMESTAMP,
    -- Duration of the frame.
    dur DURATION,
    -- "Choreographer#doFrame" slice. The slice with name 
    -- "Choreographer#doFrame" corresponding to this frame.
    do_frame_id JOINID(slice.id),
    -- "DrawFrame" slice. The slice with name "DrawFrame" corresponding to this
    -- frame.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    draw_frame_id JOINID(slice.id),
    -- actual_frame_timeline_slice` slice related to this frame.
    actual_frame_timeline_id JOINID(slice.id),
    -- `expected_frame_timeline_slice` slice related to this frame.
    expected_frame_timeline_id JOINID(slice.id),
    -- `utid` of the render thread.
    render_thread_utid JOINID(thread.id),
    -- `utid` of the UI thread.
    ui_thread_utid JOINID(thread.id)
) AS
SELECT
    frame_id,
    ts,
    dur,
    do_frame_id,
    draw_frame_id,
    actual_frame_timeline_id,
    expected_frame_timeline_id,
    render_thread_utid,
    ui_thread_utid
FROM android_frames
WHERE ts > $ts
ORDER BY ts
LIMIT 1;

)_d3l1m1t3r_"
;

const char kAndroidFramesTimelineMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;

-- All slices related to one frame for max SDK 28. Aggregates
-- "Choreographer#doFrame" and "DrawFrame". Tries to guess the `ts` and `dur`
-- of the frame by first guessing which "DrawFrame" slices are related to which
-- "Choreographer#doSlice".
CREATE PERFETTO TABLE _frames_maxsdk_28(
    -- Frame id. Created manually starting from 0.
    frame_id LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Timestamp of the frame. Start of "Choreographer#doFrame" slice.
    ts TIMESTAMP,
    -- Duration of the frame, defined as the duration until the last
    -- "DrawFrame" of this frame finishes.
    dur DURATION,
    -- Slice with name "Choreographer#doFrame" corresponding to this frame.
    do_frame_id JOINID(slice.id),
    -- Slice with name "DrawFrame" corresponding to this frame. Fetched as one
    -- of the "DrawFrame" slices that happen for the same process as
    -- "Choreographer#doFrame" slice and start after it started and before the
    -- next "doFrame" started.
    draw_frame_id JOINID(slice.id),
    -- `utid` of the render thread.
    render_thread_utid JOINID(thread.id),
    -- `utid` of the UI thread.
    ui_thread_utid JOINID(thread.id),
    -- "maxsdk28"
    sdk STRING
) AS
WITH choreographer AS (
  SELECT id
  FROM slice
  WHERE name = 'Choreographer#doFrame'
),
do_frames AS (
    SELECT
        id,
        ts,
        LEAD(ts, 1, TRACE_END()) OVER (PARTITION BY upid ORDER BY ts) AS next_do_frame,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        utid,
        upid
    FROM choreographer
    JOIN thread_slice USING (id)
    WHERE is_main_thread = 1
    ORDER BY ts
),
draw_frames AS (
    SELECT
        id,
        ts,
        dur,
        ts + dur AS ts_end,
        utid,
        upid
    FROM thread_slice
    WHERE name = 'DrawFrame'
)
SELECT
  ROW_NUMBER() OVER () AS frame_id,
  do.ts,
  MAX(draw.ts_end) OVER (PARTITION BY do.id) - do.ts AS dur,
  do.id AS do_frame_id,
  draw.id AS draw_frame_id,
  draw.utid AS render_thread_utid,
  do.utid AS ui_thread_utid,
  "maxsdk28" AS sdk
FROM do_frames do
JOIN draw_frames draw ON (do.upid = draw.upid AND draw.ts >= do.ts AND draw.ts < next_do_frame)
ORDER BY do.ts;
)_d3l1m1t3r_"
;

const char kAndroidGpuFrequency[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE counters.intervals;

-- GPU frequency counter per GPU.
CREATE PERFETTO TABLE android_gpu_frequency(
  -- Timestamp
  ts TIMESTAMP,
  -- Duration
  dur DURATION,
  -- GPU id. Joinable with `gpu_counter_track.gpu_id`.
  gpu_id LONG,
  -- GPU frequency
  gpu_freq LONG
) AS
SELECT
  ts,
  dur,
  gpu_id,
  cast_int!(value) AS gpu_freq
FROM counter_leading_intervals!((
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT c.*
    FROM counter c
    JOIN gpu_counter_track t
    ON t.id = c.track_id AND t.name = 'gpufreq'
    WHERE gpu_id IS NOT NULL
))
JOIN gpu_counter_track t ON t.id = track_id;

)_d3l1m1t3r_"
;

const char kAndroidGpuMemory[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.memory.general;

-- Counter for GPU memory per process with duration.
CREATE PERFETTO TABLE android_gpu_memory_per_process(
  -- Timestamp
  ts TIMESTAMP,
  -- Duration
  dur DURATION,
  -- Upid of the process
  upid JOINID(process.id),
  -- GPU memory
  gpu_memory LONG
) AS
SELECT
  ts,
  dur,
  upid,
  cast_int!(value) AS gpu_memory
FROM _all_counters_per_process
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name = 'GPU Memory';

)_d3l1m1t3r_"
;

const char kAndroidGpuWorkPeriod[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Tracks for GPU work period events originating from the
-- `power/gpu_work_period` Linux ftrace tracepoint.
--
-- This tracepoint is usually only available on selected Android devices.
CREATE PERFETTO TABLE android_gpu_work_period_track (
  -- Unique identifier for this track. Joinable with track.id.
  id LONG,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The UID of the package for which the GPU work period events were emitted.
  uid LONG,
  -- The GPU identifier for which the GPU work period events were emitted.
  gpu_id LONG
) AS
SELECT
  id,
  machine_id,
  extract_arg(dimension_arg_set_id, 'uid') as uid,
  extract_arg(dimension_arg_set_id, 'gpu') as gpu_id
FROM track
WHERE classification = 'android_gpu_work_period';

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphClassSummaryTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed ON an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.memory.heap_graph.class_tree;
INCLUDE PERFETTO MODULE graphs.scan;

CREATE PERFETTO TABLE _heap_graph_class_tree_cumulatives AS
SELECT *
FROM _graph_aggregating_scan!(
  (
    SELECT id AS source_node_id, parent_id AS dest_node_id
    FROM _heap_graph_class_tree
    WHERE parent_id IS NOT NULL
  ),
  (
    SELECT
      p.id,
      p.self_count AS cumulative_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      p.self_size AS cumulative_size
    FROM _heap_graph_class_tree p
    LEFT JOIN _heap_graph_class_tree c ON c.parent_id = p.id
    WHERE c.id IS NULL
  ),
  (cumulative_count, cumulative_size),
  (
    WITH agg AS (
      SELECT
        t.id,
        SUM(t.cumulative_count) AS child_count,
        SUM(t.cumulative_size) AS child_size
      FROM $table t
      GROUP BY t.id
    )
    SELECT
      a.id,
      a.child_count + r.self_count as cumulative_count,
      a.child_size + r.self_size as cumulative_size
    FROM agg a
    JOIN _heap_graph_class_tree r USING (id)
  )
) a
ORDER BY id;

-- Table containing all the Android heap graphs in the trace converted to a
-- shortest-path tree and then aggregated by class name.
--
-- This table contains a "flamegraph-like" representation of the contents of the
-- heap graph.
CREATE PERFETTO TABLE android_heap_graph_class_summary_tree(
  -- The timestamp the heap graph was dumped at.
  graph_sample_ts TIMESTAMP,
  -- The upid of the process.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  upid JOINID(process.id),
  -- The id of the node in the class tree.
  id LONG,
  -- The parent id of the node in the class tree or NULL if this is the root.
  parent_id LONG,
  -- The name of the class.
  name STRING,
  -- A string describing the type of Java root if this node is a root or NULL
  -- if this node is not a root.
  root_type STRING,
  -- The count of objects with the same class name and the same path to the
  -- root.
  self_count LONG,
  -- The size of objects with the same class name and the same path to the
  -- root.
  self_size LONG,
  -- The sum of `self_count` of this node and all descendants of this node.
  cumulative_count LONG,
  -- The sum of `self_size` of this node and all descendants of this node.
  cumulative_size LONG
) AS
SELECT
  t.graph_sample_ts,
  t.upid,
  t.id,
  t.parent_id,
  t.name,
  t.root_type,
  t.self_count,
  t.self_size,
  c.cumulative_count,
  c.cumulative_size
FROM _heap_graph_class_tree t
JOIN _heap_graph_class_tree_cumulatives c USING (id);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphClassTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed ON an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.memory.heap_graph.excluded_refs;
INCLUDE PERFETTO MODULE android.memory.heap_graph.helpers;
INCLUDE PERFETTO MODULE graphs.search;

-- Converts the heap graph into a tree by performing a BFS on the graph from
-- the roots. This basically ends up with all paths being the shortest path
-- from the root to the node (with lower ids being picked in the case of ties).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _heap_graph_object_min_depth_tree AS
SELECT node_id AS id, parent_node_id AS parent_id
FROM graph_reachable_bfs!(
  (
    SELECT owner_id AS source_node_id, owned_id AS dest_node_id
    FROM heap_graph_reference ref
    WHERE ref.id NOT IN _excluded_refs AND ref.owned_id IS NOT NULL
    ORDER BY ref.owned_id
  ),
  (
    SELECT id AS node_id
    FROM heap_graph_object
    WHERE root_type IS NOT NULL
  )
)
ORDER BY id;

CREATE PERFETTO TABLE _heap_graph_path_hashes as
SELECT *
FROM _heap_graph_type_path_hash!(_heap_graph_object_min_depth_tree);

CREATE PERFETTO TABLE _heap_graph_path_hashes_aggregated as
SELECT *
FROM _heap_graph_path_hash_aggregate!(_heap_graph_path_hashes);

CREATE PERFETTO TABLE _heap_graph_class_tree AS
SELECT *
FROM _heap_graph_path_hashes_to_class_tree!(_heap_graph_path_hashes_aggregated);

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphDominatorClassTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed ON an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.memory.heap_graph.helpers;
INCLUDE PERFETTO MODULE android.memory.heap_graph.raw_dominator_tree;

CREATE PERFETTO TABLE _heap_graph_dominator_path_hashes as
SELECT *
FROM _heap_graph_type_path_hash!((
  SELECT id, idom_id AS parent_id
  FROM _raw_heap_graph_dominator_tree
));

CREATE PERFETTO TABLE _heap_graph_dominator_path_hashes_aggregated as
SELECT *
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _heap_graph_path_hash_aggregate!(_heap_graph_dominator_path_hashes);

CREATE PERFETTO TABLE _heap_graph_dominator_class_tree AS
SELECT *
FROM _heap_graph_path_hashes_to_class_tree!(
  _heap_graph_dominator_path_hashes_aggregated
);

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphDominatorTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.scan;
INCLUDE PERFETTO MODULE android.memory.heap_graph.raw_dominator_tree;

CREATE PERFETTO TABLE _heap_graph_dominator_tree_bottom_up_scan AS
SELECT *
FROM _graph_aggregating_scan!(
  (
    SELECT id AS source_node_id, idom_id AS dest_node_id
    FROM _raw_heap_graph_dominator_tree
    WHERE idom_id IS NOT NULL
  ),
  (
    SELECT
      p.id,
      1 AS subtree_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      o.self_size AS subtree_size_bytes,
      o.native_size AS subtree_native_size_bytes
    FROM _raw_heap_graph_dominator_tree p
    JOIN heap_graph_object o USING (id)
    LEFT JOIN _raw_heap_graph_dominator_tree c ON p.id = c.idom_id
    WHERE c.id IS NULL
  ),
  (subtree_count, subtree_size_bytes, subtree_native_size_bytes),
  (
    WITH children_agg AS (
      SELECT
        t.id,
        SUM(t.subtree_count) AS subtree_count,
        SUM(t.subtree_size_bytes) AS subtree_size_bytes,
        SUM(t.subtree_native_size_bytes) AS subtree_native_size_bytes
      FROM $table t
      GROUP BY t.id
    )
    SELECT
      c.id,
      c.subtree_count + 1 AS subtree_count,
      c.subtree_size_bytes + self_size AS subtree_size_bytes,
      c.subtree_native_size_bytes + native_size AS subtree_native_size_bytes
    FROM children_agg c
    JOIN heap_graph_object o USING (id)
  )
)
ORDER BY id;

CREATE PERFETTO TABLE _heap_graph_dominator_tree_top_down_scan AS
SELECT *
FROM _graph_scan!(
  (
    SELECT idom_id AS source_node_id, id AS dest_node_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM _raw_heap_graph_dominator_tree
    WHERE idom_id IS NOT NULL
  ),
  (
    SELECT id, 1 AS depth
    FROM _raw_heap_graph_dominator_tree
    WHERE idom_id IS NULL
  ),
  (depth),
  (SELECT t.id, t.depth + 1 AS depth FROM $table t)
)
ORDER BY id;

-- All reachable heap graph objects, their immediate dominators and summary of
-- their dominated sets.
-- The heap graph dominator tree is calculated by stdlib graphs.dominator_tree.
-- Each reachable object is a node in the dominator tree, their immediate
-- dominator is their parent node in the tree, and their dominated set is all
-- their descendants in the tree. All size information come from the
-- heap_graph_object prelude table.
CREATE PERFETTO TABLE heap_graph_dominator_tree(
  -- Heap graph object id.
  id LONG,
  -- Immediate dominator object id of the object. If the immediate dominator
  -- is the "super-root" (i.e. the object is a root or is dominated by multiple
  -- roots) then `idom_id` will be NULL.
  idom_id LONG,
  -- Count of all objects dominated by this object, self inclusive.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dominated_obj_count LONG,
  -- Total self_size of all objects dominated by this object, self inclusive.
  dominated_size_bytes LONG,
  -- Total native_size of all objects dominated by this object, self inclusive.
  dominated_native_size_bytes LONG,
  -- Depth of the object in the dominator tree. Depth of root objects are 1.
  depth LONG
) AS
SELECT
  r.id,
  r.idom_id AS idom_id,
  d.subtree_count AS dominated_obj_count,
  d.subtree_size_bytes AS dominated_size_bytes,
  d.subtree_native_size_bytes AS dominated_native_size_bytes,
  t.depth
FROM _raw_heap_graph_dominator_tree r
JOIN _heap_graph_dominator_tree_bottom_up_scan d USING(id)
JOIN _heap_graph_dominator_tree_top_down_scan t USING (id)
WHERE r.id IS NOT NULL
ORDER BY id;

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphExcludedRefs[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _ref_type_ids AS
SELECT id AS type_id
FROM heap_graph_class
WHERE kind IN (
  'KIND_FINALIZER_REFERENCE',
  'KIND_PHANTOM_REFERENCE',
  'KIND_SOFT_REFERENCE',
  'KIND_WEAK_REFERENCE'
)
ORDER BY type_id;

CREATE PERFETTO TABLE _excluded_refs AS
SELECT ref.id
FROM heap_graph_reference ref
CROSS JOIN heap_graph_object robj USING (reference_set_id)
CROSS JOIN _ref_type_ids USING (type_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE ref.field_name = 'java.lang.ref.Reference.referent'
ORDER BY ref.id;

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphHeapGraphClassAggregation[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.memory.heap_graph.dominator_tree;
INCLUDE PERFETTO MODULE graphs.partition;

CREATE PERFETTO FUNCTION _partition_tree_super_root_fn()
-- The assigned id of the "super root".
RETURNS LONG AS
SELECT id + 1
FROM heap_graph_object
ORDER BY id DESC
LIMIT 1;

CREATE PERFETTO FUNCTION _is_libcore_or_array(obj_name STRING)
RETURNS BOOL AS
SELECT ($obj_name GLOB 'java.*' AND NOT $obj_name GLOB 'java.lang.Class<*>')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  OR $obj_name GLOB 'j$.*'
  OR $obj_name GLOB 'int[[]*'
  OR $obj_name GLOB 'long[[]*'
  OR $obj_name GLOB 'byte[[]*'
  OR $obj_name GLOB 'char[[]*'
  OR $obj_name GLOB 'short[[]*'
  OR $obj_name GLOB 'float[[]*'
  OR $obj_name GLOB 'double[[]*'
  OR $obj_name GLOB 'boolean[[]*'
  OR $obj_name GLOB 'android.util.*Array*';

CREATE PERFETTO TABLE _heap_graph_dominator_tree_for_partition AS
SELECT
  tree.id,
  IFNULL(tree.idom_id, _partition_tree_super_root_fn()) as parent_id,
  obj.type_id as group_key
FROM heap_graph_dominator_tree tree
JOIN heap_graph_object obj USING(id)
UNION ALL
-- provide a single root required by tree partition if heap graph exists.
SELECT
  _partition_tree_super_root_fn() AS id,
  NULL AS parent_id,
  (SELECT id + 1 FROM heap_graph_class ORDER BY id desc LIMIT 1) AS group_key
WHERE _partition_tree_super_root_fn() IS NOT NULL;

CREATE PERFETTO TABLE _heap_object_marked_for_dominated_stats AS
SELECT
  id,
  IIF(parent_id IS NULL, 1, 0) as marked
FROM tree_structural_partition_by_group!(_heap_graph_dominator_tree_for_partition)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY id;

-- Class-level breakdown of the java heap.
-- Per type name aggregates the object stats and the dominator tree stats.
CREATE PERFETTO TABLE android_heap_graph_class_aggregation (
  -- Process upid
  upid JOINID(process.id),
  -- Heap dump timestamp
  graph_sample_ts TIMESTAMP,
  -- Class type id
  type_id LONG,
  -- Class name (deobfuscated if available)
  type_name STRING,
  -- Is type an instance of a libcore object (java.*) or array
  is_libcore_or_array BOOL,
  -- Count of class instances
  obj_count LONG,
  -- Size of class instances
  size_bytes LONG,
  -- Native size of class instances
  native_size_bytes LONG,
  -- Count of reachable class instances
  reachable_obj_count LONG,
  -- Size of reachable class instances
  reachable_size_bytes LONG,
  -- Native size of reachable class instances
  reachable_native_size_bytes LONG,
  -- Count of all objects dominated by instances of this class
  -- Only applies to reachable objects
  dominated_obj_count LONG,
  -- Size of all objects dominated by instances of this class
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Only applies to reachable objects
  dominated_size_bytes LONG,
  -- Native size of all objects dominated by instances of this class
  -- Only applies to reachable objects
  dominated_native_size_bytes LONG
) AS
WITH base AS (
  -- First level aggregation to avoid joining with class for every object
  SELECT
    obj.upid,
    obj.graph_sample_ts,
    obj.type_id,
    COUNT(1) AS obj_count,
    SUM(self_size) AS size_bytes,
    SUM(native_size) AS native_size_bytes,
    SUM(IIF(obj.reachable, 1, 0)) AS reachable_obj_count,
    SUM(IIF(obj.reachable, self_size, 0)) AS reachable_size_bytes,
    SUM(IIF(obj.reachable, native_size, 0)) AS reachable_native_size_bytes,
    SUM(IIF(marked, dominated_obj_count, 0)) AS dominated_obj_count,
    SUM(IIF(marked, dominated_size_bytes, 0)) AS dominated_size_bytes,
    SUM(IIF(marked, dominated_native_size_bytes, 0)) AS dominated_native_size_bytes
  FROM heap_graph_object obj
  -- Left joins to preserve unreachable objects.
  LEFT JOIN _heap_object_marked_for_dominated_stats USING(id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  LEFT JOIN heap_graph_dominator_tree USING(id)
  GROUP BY 1, 2, 3
  ORDER BY 1, 2, 3
)
SELECT
  upid,
  graph_sample_ts,
  type_id,
  IFNULL(cls.deobfuscated_name, cls.name) AS type_name,
  _is_libcore_or_array(IFNULL(cls.deobfuscated_name, cls.name))
    AS is_libcore_or_array,
  SUM(obj_count) AS obj_count,
  SUM(size_bytes) AS size_bytes,
  SUM(native_size_bytes) AS native_size_bytes,
  SUM(reachable_obj_count) AS reachable_obj_count,
  SUM(reachable_size_bytes) AS reachable_size_bytes,
  SUM(reachable_native_size_bytes) AS reachable_native_size_bytes,
  SUM(dominated_obj_count) AS dominated_obj_count,
  SUM(dominated_size_bytes) AS dominated_size_bytes,
  SUM(dominated_native_size_bytes) AS dominated_native_size_bytes
FROM base
JOIN heap_graph_class cls ON base.type_id = cls.id
GROUP BY 1, 2, 3, 4, 5
ORDER BY 1, 2, 3, 4, 5;

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphHelpers[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed ON an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.scan;

-- Given a table containing a "tree-ified" heap graph object table (i.e.
-- by using a dominator tree or shortest path algorithm), computes a hash of
-- the path from the root to each node in the graph based on class names.
--
-- This allows an SQL aggregation of all nodes which have the same hash to
-- build a "class-tree" instead of the object tree.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO MACRO _heap_graph_type_path_hash(tab TableOrSubquery)
RETURNS TableOrSubquery
AS (
  SELECT id, path_hash, parent_path_hash
  FROM _graph_scan!(
    (
      SELECT parent_id AS source_node_id, id AS dest_node_id
      FROM $tab
      WHERE parent_id IS NOT NULL
    ),
    (
      SELECT
        t.id,
        o.type_id as parent_type_id,
        HASH(
          o.upid,
          o.graph_sample_ts,
          o.type_id,
          IFNULL(o.root_type, '')
        ) AS path_hash,
        0 AS parent_path_hash
      FROM $tab t
      JOIN heap_graph_object o USING (id)
      WHERE t.parent_id IS NULL
    ),
    (parent_type_id, path_hash, parent_path_hash),
    (
      SELECT
        t.id,
        o.type_id as parent_type_id,
        IIF(
          o.type_id = t.parent_type_id,
          t.path_hash,
          HASH(t.path_hash, o.type_id)
        ) AS path_hash,
        IIF(
          o.type_id = t.parent_type_id,
          t.parent_path_hash,
          t.path_hash
        ) AS parent_path_hash
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM $table t
      JOIN heap_graph_object o USING (id)
    )
  )
  ORDER BY id
);

-- Given a table containing heap graph tree-table with path hashes computed
-- (see _heap_graph_type_path_hash macro), aggregates together all nodes
-- with the same hash and also splits out "native size" as a separate node under
-- the nodes which contain the native size.
CREATE PERFETTO MACRO _heap_graph_path_hash_aggregate(tab TableOrSubquery)
RETURNS TableOrSubquery
AS (
  with x AS (
    SELECT
      o.graph_sample_ts,
      o.upid,
      path_hash,
      parent_path_hash,
      COALESCE(c.deobfuscated_name, c.name) AS name,
      o.root_type,
      COUNT() AS self_count,
      SUM(o.self_size) AS self_size,
      SUM(o.native_size > 0) AS self_native_count,
      SUM(o.native_size) AS self_native_size
    FROM $tab
    JOIN heap_graph_object o USING (id)
    JOIN heap_graph_class c ON o.type_id = c.id
    GROUP BY path_hash
  )
  SELECT
    graph_sample_ts,
    upid,
    HASH(path_hash, 'native', '') AS path_hash,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    path_hash AS parent_path_hash,
    '[native] ' || x.name AS name,
    root_type,
    SUM(x.self_native_count) AS self_count,
    SUM(x.self_native_size) AS self_size
  FROM x
  WHERE x.self_native_size > 0
  GROUP BY path_hash
  UNION ALL
  SELECT
    graph_sample_ts,
    upid,
    path_hash,
    parent_path_hash,
    name,
    root_type,
    self_count,
    self_size
  FROM x
  ORDER BY path_hash
);

-- Given a table containing heap graph tree-table aggregated by path hashes
-- (see _heap_graph_path_hash_aggregate) computes the "class tree" by converting
-- the path hashes to ids.
--
-- Note that |tab| *must* be a Perfetto (e.g. not a subquery) for this macro
-- to work.
CREATE PERFETTO MACRO _heap_graph_path_hashes_to_class_tree(tab TableOrSubquery)
RETURNS TableOrSubquery
AS (
  SELECT
    graph_sample_ts,
    upid,
    _auto_id AS id,
    (
      SELECT p._auto_id
      FROM $tab p
      WHERE c.parent_path_hash = p.path_hash
    ) AS parent_id,
    name,
    root_type,
    self_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    self_size
  FROM $tab c
  ORDER BY id
);

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapGraphRawDominatorTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.memory.heap_graph.excluded_refs;
INCLUDE PERFETTO MODULE graphs.dominator_tree;

-- The assigned id of the "super root".
-- Since a Java heap graph is a "forest" structure, we need to add a imaginary
-- "super root" node which connects all the roots of the forest into a single
-- connected component, so that the dominator tree algorithm can be performed.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION _heap_graph_super_root_fn()
-- The assigned id of the "super root".
RETURNS LONG AS
SELECT id + 1
FROM heap_graph_object
ORDER BY id DESC
LIMIT 1;

CREATE PERFETTO TABLE _raw_heap_graph_dominator_tree AS
SELECT
  node_id AS id,
  iif(
    dominator_node_id = _heap_graph_super_root_fn(),
    null,
    dominator_node_id
  ) as idom_id
FROM graph_dominator_tree!(
  (
    SELECT
      ref.owner_id AS source_node_id,
      ref.owned_id AS dest_node_id
    FROM heap_graph_reference ref
    JOIN heap_graph_object source_node ON ref.owner_id = source_node.id
    WHERE source_node.reachable
      AND ref.id NOT IN _excluded_refs
      AND ref.owned_id IS NOT NULL
    UNION ALL
    SELECT
      (SELECT _heap_graph_super_root_fn()) as source_node_id,
      id AS dest_node_id
    FROM heap_graph_object
    WHERE root_type IS NOT NULL
  ),
  (SELECT _heap_graph_super_root_fn())
)
-- Excluding the imaginary root.
WHERE dominator_node_id IS NOT NULL
ORDER BY id;

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapProfileCallstacks[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE callstacks.stack_profile;

CREATE PERFETTO MACRO _android_heap_profile_callstacks_for_allocations(
  allocations TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  WITH metrics AS MATERIALIZED (
    SELECT
    callsite_id,
    SUM(size) AS self_size,
    SUM(count) AS self_count,
    SUM(alloc_size) AS self_alloc_size,
    SUM(alloc_count) AS self_alloc_count
    FROM $allocations
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    GROUP BY callsite_id
  )
  SELECT
    c.id,
    c.parent_id,
    c.name,
    c.mapping_name,
    c.source_file,
    c.line_number,
    IFNULL(m.self_size, 0) AS self_size,
    IFNULL(m.self_count, 0) AS self_count,
    IFNULL(m.self_alloc_size, 0) AS self_alloc_size,
    IFNULL(m.self_alloc_count, 0) AS self_alloc_count
  FROM _callstacks_for_stack_profile_samples!(metrics) c
  LEFT JOIN metrics m USING (callsite_id)
);

)_d3l1m1t3r_"
;

const char kAndroidMemoryHeapProfileSummaryTree[] = R"_d3l1m1t3r_(
--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE callstacks.stack_profile;

CREATE PERFETTO TABLE _android_heap_profile_raw_callstacks AS
WITH metrics AS MATERIALIZED (
  SELECT
    callsite_id,
    SUM(size) AS self_size,
    SUM(MAX(size, 0)) AS self_alloc_size
  FROM heap_profile_allocation
  GROUP BY callsite_id
)
SELECT
  c.id,
  c.parent_id,
  c.name,
  c.mapping_name,
  c.source_file,
  c.line_number,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IFNULL(m.self_size, 0) AS self_size,
  IFNULL(m.self_alloc_size, 0) AS self_alloc_size
FROM _callstacks_for_stack_profile_samples!(metrics) c
LEFT JOIN metrics m USING (callsite_id);

CREATE PERFETTO TABLE _android_heap_profile_cumulatives AS
SELECT a.*
FROM _graph_aggregating_scan!(
  (
    SELECT id AS source_node_id, parent_id AS dest_node_id
    FROM _android_heap_profile_raw_callstacks
    WHERE parent_id IS NOT NULL
  ),
  (
    SELECT
      p.id,
      p.self_size AS cumulative_size,
      p.self_alloc_size AS cumulative_alloc_size
    FROM _android_heap_profile_raw_callstacks p
    LEFT JOIN _android_heap_profile_raw_callstacks c ON c.parent_id = p.id
    WHERE c.id IS NULL
  ),
  (cumulative_size, cumulative_alloc_size),
  (
    WITH agg AS (
      SELECT
        t.id,
        SUM(t.cumulative_size) AS child_size,
        SUM(t.cumulative_alloc_size) AS child_alloc_size
      FROM $table t
      GROUP BY t.id
    )
    SELECT
      a.id,
      a.child_size + r.self_size as cumulative_size,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      a.child_alloc_size + r.self_alloc_size AS cumulative_alloc_size
    FROM agg a
    JOIN _android_heap_profile_raw_callstacks r USING (id)
  )
) a;

-- Table summarising the amount of memory allocated by each
-- callstack as seen by Android native heap profiling (i.e.
-- profiling information collected by heapprofd).
--
-- Note: this table collapses data from all processes together
-- into a single table.
CREATE PERFETTO TABLE android_heap_profile_summary_tree(
  -- The id of the callstack. A callstack in this context
  -- is a unique set of frames up to the root.
  id LONG,
  -- The id of the parent callstack for this callstack.
  parent_id LONG,
  -- The function name of the frame for this callstack.
  name STRING,
  -- The name of the mapping containing the frame. This
  -- can be a native binary, library, JAR or APK.
  mapping_name STRING,
  -- The name of the file containing the function.
  source_file STRING,
  -- The line number in the file the function is located at.
  line_number LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The amount of memory allocated and *not freed* with this
  -- function as the leaf frame.
  self_size LONG,
  -- The amount of memory allocated and *not freed* with this
  -- function appearing anywhere on the callstack.
  cumulative_size LONG,
  -- The amount of memory allocated with this function as the leaf
  -- frame. This may include memory which was later freed.
  self_alloc_size LONG,
  -- The amount of memory allocated with this function appearing
  -- anywhere on the callstack. This may include memory which was
  -- later freed.
  cumulative_alloc_size LONG
) AS
SELECT
  id,
  parent_id,
  name,
  mapping_name,
  source_file,
  line_number,
  self_size,
  cumulative_size,
  self_alloc_size,
  cumulative_alloc_size
FROM _android_heap_profile_raw_callstacks r
JOIN _android_heap_profile_cumulatives a USING (id);

)_d3l1m1t3r_"
;

const char kAndroidMemoryDmabuf[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Raw ftrace events
CREATE PERFETTO TABLE _raw_dmabuf_events AS
SELECT
  (SELECT int_value FROM args WHERE arg_set_id = c.arg_set_id AND key = 'inode') AS inode,
  tt.utid,
  c.ts,
  cast_int!(c.value) AS buf_size
FROM thread_counter_track tt
  JOIN counter c ON c.track_id = tt.id
WHERE tt.name = 'mem.dma_heap_change';

-- gralloc binder reply slices
CREATE PERFETTO TABLE _gralloc_binders AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WITH gralloc_threads AS (
  SELECT utid
  FROM process JOIN thread USING (upid)
  WHERE process.name GLOB '/vendor/bin/hw/android.hardware.graphics.allocator*'
)
SELECT
  flow.slice_out AS client_slice_id,
  gralloc_slice.ts,
  gralloc_slice.dur,
  thread_track.utid
FROM slice gralloc_slice
JOIN thread_track ON gralloc_slice.track_id = thread_track.id
JOIN gralloc_threads USING (utid)
JOIN flow ON gralloc_slice.id = flow.slice_in
WHERE gralloc_slice.name = 'binder reply'
;

-- Match gralloc thread allocations to inbound binders
CREATE PERFETTO TABLE _attributed_dmabufs AS
SELECT
  r.inode,
  r.ts,
  r.buf_size,
  IFNULL(client_thread.utid, r.utid) AS attr_utid
FROM _raw_dmabuf_events r
LEFT JOIN _gralloc_binders gb ON r.utid = gb.utid AND r.ts BETWEEN gb.ts AND gb.ts + gb.dur
LEFT JOIN thread_track client_thread ON gb.client_slice_id = client_thread.id
ORDER BY r.inode, r.ts;

CREATE PERFETTO FUNCTION _alloc_source(is_alloc BOOL, inode LONG, ts TIMESTAMP)
RETURNS LONG AS
SELECT attr_utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _attributed_dmabufs
WHERE
  inode = $inode
  AND (
    ($is_alloc AND ts = $ts) OR
    (NOT $is_alloc AND ts < $ts)
  )
ORDER BY ts DESC
LIMIT 1;

-- Track dmabuf allocations, re-attributing gralloc allocations to their source
-- (if binder transactions to gralloc are recorded).
CREATE PERFETTO TABLE android_dmabuf_allocs (
  -- timestamp of the allocation
  ts TIMESTAMP,
  -- allocation size (will be negative for release)
  buf_size LONG,
  -- dmabuf inode
  inode LONG,
  -- utid of thread responsible for the allocation
  -- if a dmabuf is allocated by gralloc we follow the binder transaction
  -- to the requesting thread (requires binder tracing)
  utid JOINID(thread.id),
  -- tid of thread responsible for the allocation
  tid LONG,
  -- thread name
  thread_name STRING,
  -- upid of process responsible for the allocation (matches utid)
  upid JOINID(process.id),
  -- pid of process responsible for the allocation
  pid LONG,
  -- process name
  process_name STRING
) AS
WITH _thread_allocs AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT inode, ts, buf_size, _alloc_source(buf_size > 0, inode, ts) AS utid
  FROM _attributed_dmabufs
)
SELECT ts, buf_size, inode,
  utid, tid, thread.name AS thread_name,
  upid, pid, process.name AS process_name
FROM _thread_allocs allocs
JOIN thread USING (utid)
LEFT JOIN process USING (upid)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidMemoryProcess[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.oom_adjuster;
INCLUDE PERFETTO MODULE linux.memory.process;

-- OOM score tables

CREATE VIRTUAL TABLE _mem_ooms_sj
USING SPAN_OUTER_JOIN(
  android_oom_adj_intervals PARTITIONED upid,
  _memory_rss_and_swap_per_process_table PARTITIONED upid);

-- Process memory and it's OOM adjuster scores. Detects transitions, each new
-- interval means that either the memory or OOM adjuster score of the process changed.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE memory_oom_score_with_rss_and_swap_per_process(
  -- Timestamp the oom_adj score or memory of the process changed
  ts TIMESTAMP,
  -- Duration until the next oom_adj score or memory change of the process.
  dur DURATION,
  -- oom adjuster score of the process.
  score LONG,
  -- oom adjuster bucket of the process.
  bucket STRING,
  -- Upid of the process having an oom_adj update.
  upid JOINID(process.id),
  -- Name of the process having an oom_adj update.
  process_name STRING,
  -- Pid of the process having an oom_adj update.
  pid LONG,
  -- Slice of the latest oom_adj update in the system_server.
  oom_adj_id JOINID(slice.id),
  -- Timestamp of the latest oom_adj update in the system_server.
  oom_adj_ts TIMESTAMP,
  -- Duration of the latest oom_adj update in the system_server.
  oom_adj_dur DURATION,
  -- Track of the latest oom_adj update in the system_server. Alias of
  -- `track.id`.
  oom_adj_track_id JOINID(track.id),
  -- Thread name of the latest oom_adj update in the system_server.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  oom_adj_thread_name STRING,
  -- Reason for the latest oom_adj update in the system_server.
  oom_adj_reason STRING,
  -- Trigger for the latest oom_adj update in the system_server.
  oom_adj_trigger STRING,
  -- Anon RSS counter value
  anon_rss LONG,
  -- File RSS counter value
  file_rss LONG,
  -- Shared memory RSS counter value
  shmem_rss LONG,
  -- Total RSS value. Sum of `anon_rss`, `file_rss` and `shmem_rss`. Returns
  -- value even if one of the values is NULL.
  rss LONG,
  -- Swap counter value
  swap LONG,
  -- Sum or `anon_rss` and `swap`. Returns value even if one of the values is
  -- NULL.
  anon_rss_and_swap LONG,
  -- Sum or `rss` and `swap`. Returns value even if one of the values is NULL.
  rss_and_swap LONG
) AS
SELECT
  ts,
  dur,
  score,
  bucket,
  upid,
  process_name,
  pid,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger,
  anon_rss,
  file_rss,
  shmem_rss,
  file_rss + anon_rss + COALESCE(shmem_rss, 0) AS rss,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  swap,
  anon_rss + COALESCE(swap, 0) AS anon_rss_and_swap,
  anon_rss + file_rss  + COALESCE(shmem_rss, 0) + COALESCE(swap, 0) AS rss_and_swap
FROM _mem_ooms_sj
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupBreakdowns[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startups;
INCLUDE PERFETTO MODULE intervals.overlap;
INCLUDE PERFETTO MODULE slices.hierarchy;
INCLUDE PERFETTO MODULE slices.with_context;

-- Maps slice names with common prefixes to a static string key.
-- Returns NULL if there's no mapping.
CREATE PERFETTO FUNCTION _normalize_android_string(name STRING)
RETURNS STRING
AS
SELECT
  CASE
    WHEN $name = 'mm_vmscan_direct_reclaim' THEN 'kernel_memory_reclaim'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $name GLOB 'GC: Wait For*' THEN 'userspace_memory_reclaim'
    WHEN ($name GLOB 'monitor contention*' OR $name GLOB 'Lock contention on a monitor lock*')
      THEN 'monitor_contention'
    WHEN $name GLOB 'Lock contention*' THEN 'art_lock_contention'
    WHEN ($name = 'binder transaction' OR $name = 'binder reply') THEN 'binder'
    WHEN $name = 'Contending for pthread mutex' THEN 'mutex_contention'
    WHEN $name GLOB 'dlopen*' THEN 'dlopen'
    WHEN $name GLOB 'VerifyClass*' THEN 'verify_class'
    WHEN $name = 'inflate' THEN 'inflate'
    WHEN $name GLOB 'Choreographer#doFrame*' THEN 'choreographer_do_frame'
    WHEN $name GLOB 'OpenDexFilesFromOat*' THEN 'open_dex_files_from_oat'
    WHEN $name = 'ResourcesManager#getResources' THEN 'resources_manager_get_resources'
    WHEN $name = 'bindApplication' THEN 'bind_application'
    WHEN $name = 'activityStart' THEN 'activity_start'
    WHEN $name = 'activityResume' THEN 'activity_resume'
    WHEN $name = 'activityRestart' THEN 'activity_restart'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $name = 'clientTransactionExecuted' THEN 'client_transaction_executed'
    ELSE NULL
    END name;

-- Derives a startup reason from a slice name and some thread_state columns.
CREATE PERFETTO FUNCTION _startup_breakdown_reason(
  name STRING,
  state STRING,
  io_wait LONG,
  irq_context LONG)
RETURNS STRING
AS
SELECT
  CASE
    WHEN $io_wait = 1 THEN 'io'
    WHEN $name IS NOT NULL THEN $name
    WHEN $irq_context = 1 THEN 'irq'
    ELSE $state
    END name;

-- List of startups with unique ids for each possible upid. The existing
-- startup_ids are not necessarily unique (because of multiuser).
CREATE PERFETTO TABLE _startup_root_slices
AS
SELECT
  (SELECT MAX(id) FROM slice) + row_number() OVER () AS id,
  android_startups.dur AS dur,
  android_startups.ts AS ts,
  android_startups.startup_id,
  android_startups.startup_type,
  process.name AS process_name,
  thread.utid AS utid
FROM android_startup_processes startup
JOIN android_startups
  USING (startup_id)
JOIN thread
  ON thread.upid = process.upid AND thread.is_main_thread
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process
  ON process.upid = startup.upid
WHERE android_startups.dur > 0
ORDER BY ts;

-- All relevant startup slices normalized with _normalize_android_string.
CREATE PERFETTO TABLE _startup_normalized_slices
AS
WITH
  relevant_startup_slices AS (
    SELECT slice.*
    FROM thread_slice slice
    JOIN _startup_root_slices startup
      ON
        slice.utid = startup.utid
        -- Inline the logic to check whether startup intervals overlap
        -- with main thread slices. This is to improve performance until
        -- interval_intersect doesn't require a JOIN.
        -- TODO(zezeozue): Replace with interval intersect when JOINs are
        -- not required.
        AND MAX(slice.ts, startup.ts) < MIN(slice.ts + slice.dur, startup.ts + startup.dur)
  )
SELECT p.id, p.parent_id, p.depth, p.name, thread_slice.ts, thread_slice.dur, thread_slice.utid
FROM
  _slice_remove_nulls_and_reparent
    !(
      (
        SELECT id, parent_id, depth, _normalize_android_string(name) AS name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        FROM relevant_startup_slices
        WHERE dur > 0
      ),
      name)
      p
JOIN thread_slice
  USING (id);

-- Subset of _startup_normalized_slices that occurred during any app startups on the main thread.
-- Their timestamps and durations are chopped to fit within the respective app startup duration.
CREATE PERFETTO TABLE _startup_slices_breakdown
AS
SELECT *
FROM _intervals_merge_root_and_children_by_intersection !(_startup_root_slices, _startup_normalized_slices, utid);

-- Flattened slice version of _startup_slices_breakdown. This selects the leaf slice at every region
-- of the slice stack.
CREATE PERFETTO TABLE _startup_flat_slices_breakdown
AS
SELECT i.ts, i.dur, i.root_id, s.id AS slice_id, s.name FROM _intervals_flatten !(_startup_slices_breakdown) i
JOIN _startup_normalized_slices s USING (id);

-- Subset of thread_states that occurred during any app startups on the main thread.
CREATE PERFETTO TABLE _startup_thread_states_breakdown
AS
SELECT i.ts, i.dur, i.root_id, t.id AS thread_state_id, t.state, t.io_wait, t.irq_context
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM _intervals_merge_root_and_children_by_intersection!(_startup_root_slices,
                                                           (SELECT *, NULL AS parent_id FROM thread_state),
                                                           utid) i
JOIN thread_state t USING(id);

-- Intersection of _startup_flat_slices_breakdown and _startup_thread_states_breakdown.
-- A left intersection is used since some parts of the slice stack may not have any slices
-- but will have thread states.
CREATE VIRTUAL TABLE _startup_thread_states_and_slices_breakdown_sp
USING
  SPAN_LEFT_JOIN(
    _startup_thread_states_breakdown PARTITIONED root_id,
    _startup_flat_slices_breakdown PARTITIONED root_id);

-- Blended thread state and slice breakdown blocking app startups.
--
-- Each row blames a unique period during an app startup with a reason
-- derived from the slices and thread states on the main thread.
--
-- Some helpful events to enables are binder transactions, ART, am and view.
CREATE PERFETTO TABLE android_startup_opinionated_breakdown(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Startup id.
  startup_id JOINID(android_startups.startup_id),
  -- Id of relevant slice blocking startup.
  slice_id JOINID(slice.id),
  -- Id of thread_state blocking startup.
  thread_state_id JOINID(thread_state.id),
  -- Timestamp of an exclusive interval during the app startup with a single latency reason.
  ts TIMESTAMP,
  -- Duration of an exclusive interval during the app startup with a single latency reason.
  dur DURATION,
  -- Cause of delay during an exclusive interval of the app startup.
  reason STRING
)
AS
SELECT b.ts, b.dur, startup.startup_id, b.slice_id, b.thread_state_id, _startup_breakdown_reason(name, state, io_wait, irq_context) AS reason
FROM _startup_thread_states_and_slices_breakdown_sp b
JOIN _startup_root_slices startup ON startup.id = b.root_id
UNION ALL
-- Augment the existing startup breakdown with an artificial slice accounting for
-- any launch delays before the app starts handling startup on its main thread
SELECT
  _startup_root_slices.ts,
  MIN(_startup_thread_states_breakdown.ts) - _startup_root_slices.ts AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  startup_id,
  NULL AS slice_id,
  NULL AS thread_state_id,
  'launch_delay' AS reason
FROM _startup_thread_states_breakdown
JOIN _startup_root_slices
  ON _startup_root_slices.id = root_id
GROUP BY root_id
HAVING MIN(_startup_thread_states_breakdown.ts) - _startup_root_slices.ts > 0;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupEvents[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.with_context;

-- All activity startup events.
CREATE PERFETTO TABLE _startup_events AS
SELECT
  ts,
  dur,
  ts + dur AS ts_end,
  STR_SPLIT(s.name, ": ", 1) AS package_name
FROM process_slice s
WHERE
  s.name GLOB 'launching: *'
  AND (process_name IS NULL OR process_name = 'system_server');

)_d3l1m1t3r_"
;

const char kAndroidStartupStartups[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.process_metadata;
INCLUDE PERFETTO MODULE android.startup.startups_maxsdk28;
INCLUDE PERFETTO MODULE android.startup.startups_minsdk29;
INCLUDE PERFETTO MODULE android.startup.startups_minsdk33;
INCLUDE PERFETTO MODULE android.version;

-- All activity startups in the trace by startup id.
-- Populated by different scripts depending on the platform version/contents.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE android_startups(
  -- Startup id.
  startup_id ID,
  -- Timestamp of startup start.
  ts TIMESTAMP,
  -- Timestamp of startup end.
  ts_end LONG,
  -- Startup duration.
  dur DURATION,
  -- Package name.
  package STRING,
  -- Startup type.
  startup_type STRING
)
AS
WITH version AS (
  SELECT CASE
    WHEN _android_sdk_version() >= 33 THEN 33
    WHEN _android_sdk_version() >= 29 THEN 29
    WHEN _android_sdk_version() IS NOT NULL THEN 28
    WHEN (
      SELECT COUNT()
      FROM slice
      WHERE name GLOB 'launchingActivity#*:*'
    ) > 0 THEN 33
    WHEN (
      SELECT COUNT()
      FROM slice
      WHERE name GLOB 'MetricsLogger:*'
    ) > 0 THEN 29
    ELSE 28
  END AS v
)
SELECT _auto_id as startup_id, ts, ts_end, dur, package, startup_type
FROM _startups_maxsdk28
WHERE (SELECT v from version) = 28
UNION ALL
SELECT _auto_id as startup_id, ts, ts_end, dur, package, startup_type
FROM _startups_minsdk29
WHERE (SELECT v from version) = 29
UNION ALL
SELECT startup_id, ts, ts_end, dur, package, startup_type
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _startups_minsdk33
WHERE (SELECT v from version) = 33;

-- Create a table containing only the slices which are necessary for determining
-- whether a startup happened.
CREATE PERFETTO TABLE _startup_indicator_slices AS
SELECT ts, name, track_id
FROM slice
WHERE name IN ('bindApplication', 'activityStart', 'activityResume');

CREATE PERFETTO FUNCTION _startup_indicator_slice_count(start_ts TIMESTAMP,
                                                                end_ts TIMESTAMP,
                                                                utid JOINID(thread.id),
                                                                name STRING)
RETURNS LONG AS
SELECT COUNT(1)
FROM thread_track t
JOIN _startup_indicator_slices s ON s.track_id = t.id
WHERE
  t.utid = $utid AND
  s.ts >= $start_ts AND
  s.ts < $end_ts AND
  s.name = $name;

-- Maps a startup to the set of processes that handled the activity start.
--
-- The vast majority of cases should be a single process. However it is
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- possible that the process dies during the activity startup and is respawned.
CREATE PERFETTO TABLE android_startup_processes(
  -- Startup id.
  startup_id LONG,
  -- Upid of process on which activity started.
  upid JOINID(process.id),
  -- Pid of process on which activity started.
  pid LONG,
  -- Type of the startup.
  startup_type STRING
) AS
-- This is intentionally a materialized query. For some reason, if we don't
-- materialize, we end up with a query which is an order of magnitude slower :(
WITH startup_with_type AS MATERIALIZED (
  SELECT
    startup_id,
    upid,
    pid,
    CASE
      -- type parsed from platform event takes precedence if available
      WHEN startup_type IS NOT NULL THEN startup_type
      WHEN bind_app > 0 AND a_start > 0 AND a_resume > 0 THEN 'cold'
      WHEN a_start > 0 AND a_resume > 0 THEN 'warm'
      WHEN a_resume > 0 THEN 'hot'
      ELSE NULL
    END AS startup_type
  FROM (
    SELECT
      l.startup_id,
      l.startup_type,
      p.upid,
      p.pid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'bindApplication') AS bind_app,
      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'activityStart') AS a_start,
      _startup_indicator_slice_count(l.ts, l.ts_end, t.utid, 'activityResume') AS a_resume
    FROM android_startups l
    JOIN android_process_metadata p ON (
      l.package = p.package_name
      -- If the package list data source was not enabled in the trace, nothing
      -- will match the above constraint so also match any process whose name
      -- is a prefix of the package name.
      OR (
        (SELECT COUNT(1) = 0 FROM package_list)
        AND p.process_name GLOB l.package || '*'
      )
      )
    JOIN thread t ON (p.upid = t.upid AND t.is_main_thread)
    -- Filter out the non-startup processes with the same package name as that of a startup.
    WHERE a_resume > 0
  )
)
SELECT *
FROM startup_with_type
WHERE startup_type IS NOT NULL;


-- Maps a startup to the set of threads on processes that handled the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- activity start.
CREATE PERFETTO VIEW android_startup_threads(
  -- Startup id.
  startup_id LONG,
  -- Timestamp of start.
  ts TIMESTAMP,
  -- Duration of startup.
  dur DURATION,
  -- Upid of process involved in startup.
  upid JOINID(process.id),
  -- Pid if process involved in startup.
  pid LONG,
  -- Utid of the thread.
  utid JOINID(thread.id),
  -- Tid of the thread.
  tid LONG,
  -- Name of the thread.
  thread_name STRING,
  -- Thread is a main thread.
  is_main_thread BOOL
) AS
SELECT
  startups.startup_id,
  startups.ts,
  startups.dur,
  android_startup_processes.upid,
  android_startup_processes.pid,
  thread.utid,
  thread.tid,
  thread.name AS thread_name,
  thread.is_main_thread AS is_main_thread
FROM android_startups startups
JOIN android_startup_processes USING (startup_id)
JOIN thread USING (upid);

---
--- Functions
---

-- All the slices for all startups in trace.
--
-- Generally, this view should not be used. Instead, use one of the view functions related
-- to the startup slices which are created from this table.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_thread_slices_for_all_startups(
  -- Timestamp of startup.
  startup_ts TIMESTAMP,
  -- Timestamp of startup end.
  startup_ts_end LONG,
  -- Startup id.
  startup_id LONG,
  -- UTID of thread with slice.
  utid JOINID(thread.id),
  --Tid of thread.
  tid LONG,
  -- Name of thread.
  thread_name STRING,
  -- Whether it is main thread.
  is_main_thread BOOL,
  -- Arg set id.
  arg_set_id ARGSETID,
  -- Slice id.
  slice_id JOINID(slice.id),
  -- Name of slice.
  slice_name STRING,
  -- Timestamp of slice start.
  slice_ts TIMESTAMP,
  -- Slice duration.
  slice_dur LONG
) AS
SELECT
  st.ts AS startup_ts,
  st.ts + st.dur AS startup_ts_end,
  st.startup_id,
  st.utid,
  st.tid,
  st.thread_name,
  st.is_main_thread,
  slice.arg_set_id,
  slice.id as slice_id,
  slice.name AS slice_name,
  slice.ts AS slice_ts,
  slice.dur AS slice_dur
FROM android_startup_threads st
JOIN thread_track USING (utid)
JOIN slice ON (slice.track_id = thread_track.id)
WHERE slice.ts BETWEEN st.ts AND st.ts + st.dur;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Given a startup id and GLOB for a slice name, returns matching slices with data.
CREATE PERFETTO FUNCTION android_slices_for_startup_and_slice_name(
  -- Startup id.
  startup_id LONG,
  -- Glob of the slice.
  slice_name STRING)
RETURNS TABLE(
  -- Id of the slice.
  slice_id JOINID(slice.id),
  -- Name of the slice.
  slice_name STRING,
  -- Timestamp of start of the slice.
  slice_ts TIMESTAMP,
  -- Duration of the slice.
  slice_dur DURATION,
  -- Name of the thread with the slice.
  thread_name STRING,
  -- Tid of the thread with the slice.
  tid  LONG,
  -- Arg set id.
  arg_set_id ARGSETID
) AS
SELECT slice_id, slice_name, slice_ts, slice_dur, thread_name, tid, arg_set_id
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id AND slice_name GLOB $slice_name;

-- Returns binder transaction slices for a given startup id with duration over threshold.
CREATE PERFETTO FUNCTION android_binder_transaction_slices_for_startup(
  -- Startup id.
  startup_id LONG,
  -- Only return slices with duration over threshold.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  threshold DOUBLE)
RETURNS TABLE(
  -- Slice id.
  id LONG,
  -- Slice duration.
  slice_dur DURATION,
  -- Name of the thread with slice.
  thread_name STRING,
  -- Name of the process with slice.
  process STRING,
  -- Arg set id.
  arg_set_id ARGSETID,
  -- Whether is main thread.
  is_main_thread BOOL
) AS
SELECT
  slice_id as id,
  slice_dur,
  thread_name,
  process.name as process,
  s.arg_set_id,
  is_main_thread
FROM android_thread_slices_for_all_startups s
JOIN process ON (
  EXTRACT_ARG(s.arg_set_id, "destination process") = process.pid
)
WHERE startup_id = $startup_id
  AND slice_name GLOB "binder transaction"
  AND slice_dur > $threshold;

-- Returns duration of startup for slice name.
--
-- Sums duration of all slices of startup with provided name.
CREATE PERFETTO FUNCTION android_sum_dur_for_startup_and_slice(
  -- Startup id.
  startup_id LONG,
  -- Slice name.
  slice_name STRING)
-- Sum of duration.
RETURNS LONG AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE startup_id = $startup_id
  AND slice_name GLOB $slice_name;

-- Returns duration of startup for slice name on main thread.
--
-- Sums duration of all slices of startup with provided name only on main thread.
CREATE PERFETTO FUNCTION android_sum_dur_on_main_thread_for_startup_and_slice(
  -- Startup id.
  startup_id LONG,
  -- Slice name.
  slice_name STRING)
-- Sum of duration.
RETURNS LONG AS
SELECT SUM(slice_dur)
FROM android_thread_slices_for_all_startups
WHERE startup_id = $startup_id
  AND slice_name GLOB $slice_name
  AND is_main_thread;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMaxsdk28[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.frames.timeline;
INCLUDE PERFETTO MODULE android.startup.startup_events;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO TABLE _startups_maxsdk28 AS
-- Warm and cold starts only are based on the launching slice
WITH warm_and_cold AS (
  SELECT
    le.ts,
    le.ts_end AS ts_end,
    package_name AS package,
    NULL AS startup_type
  FROM _startup_events le
)_d3l1m1t3r_"
R"_d3l1m1t3r_(),
-- Hot starts dont have a launching slice so we use activityResume as a
-- proxy.
--
-- Note that this implementation will also count warm and cold starts but
-- we will remove those below.
maybe_hot AS (
  SELECT
    sl.ts,
    rs.ts + rs.dur AS ts_end,
    -- We use the process name as the package as we have no better option.
    COALESCE(process_name, thread_name, 'unknown') AS package,
    "hot" AS startup_type
  FROM thread_slice sl
  JOIN android_first_frame_after(sl.ts) rs
  WHERE name = 'activityResume'
    AND sl.is_main_thread
    -- Remove any launches here where the activityResume slices happens during
    -- a warm/cold startup.
    AND NOT EXISTS (
      SELECT 1
      FROM warm_and_cold wac
      WHERE sl.ts BETWEEN wac.ts AND wac.ts_end
      LIMIT 1
    )
),
cold_warm_hot AS (
  SELECT * FROM warm_and_cold
  UNION ALL
  SELECT * FROM maybe_hot
)
SELECT
  ts,
  ts_end,
  ts_end - ts AS dur,
  package,
  startup_type
FROM cold_warm_hot
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMinsdk29[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startup_events;

-- Marks the beginning of the trace and is equivalent to when the statsd startup
-- logging begins.
CREATE PERFETTO VIEW _activity_intent_received AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyIntentStarted';

-- We partition the trace into spans based on posted activity intents.
-- We will refine these progressively in the next steps to only encompass
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- activity starts.
CREATE PERFETTO TABLE _activity_intent_recv_spans AS
SELECT
  ts,
  LEAD(ts, 1, trace_end()) OVER(ORDER BY ts) - ts AS dur
FROM _activity_intent_received
ORDER BY ts;

-- Filter activity_intent_recv_spans, keeping only the ones that triggered
-- a startup.
CREATE PERFETTO VIEW _startup_partitions AS
SELECT * FROM _activity_intent_recv_spans AS spans
WHERE 1 = (
  SELECT COUNT(1)
  FROM _startup_events
  WHERE _startup_events.ts BETWEEN spans.ts AND spans.ts + spans.dur);

-- Successful activity startup. The end of the 'launching' event is not related
-- to whether it actually succeeded or not.
CREATE PERFETTO VIEW _activity_intent_startup_successful AS
SELECT ts FROM slice
WHERE name = 'MetricsLogger:launchObserverNotifyActivityLaunchFinished';

-- Use the starting event package name. The finish event package name
-- is not reliable in the case of failed startups.
CREATE PERFETTO TABLE _startups_minsdk29 AS
SELECT
  lpart.ts,
  le.ts_end,
  le.ts_end - lpart.ts AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  package_name AS package,
  NULL AS startup_type
FROM _startup_partitions AS lpart
JOIN _startup_events le ON
  (le.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur)
  AND (le.ts_end BETWEEN lpart.ts AND lpart.ts + lpart.dur)
WHERE (
  SELECT COUNT(1)
  FROM _activity_intent_startup_successful AS successful
  WHERE successful.ts BETWEEN lpart.ts AND lpart.ts + lpart.dur
) > 0
ORDER BY lpart.ts;

)_d3l1m1t3r_"
;

const char kAndroidStartupStartupsMinsdk33[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startup_events;

CREATE PERFETTO VIEW _startup_async_events AS
SELECT
  ts,
  dur,
  cast_int!(SUBSTR(name, 19) ) AS startup_id
FROM slice
WHERE
  name GLOB 'launchingActivity#*'
  AND dur != 0
  AND INSTR(name, ':') = 0;

CREATE PERFETTO VIEW _startup_complete_events AS
SELECT
  cast_int!(STR_SPLIT(completed, ':', 0)) AS startup_id,
  STR_SPLIT(completed, ':', 2) AS package_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  CASE
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-hot' THEN 'hot'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-warm' THEN 'warm'
    WHEN STR_SPLIT(completed, ':', 1) = 'completed-cold' THEN 'cold'
    ELSE NULL
  END AS startup_type,
  MIN(ts)
FROM (
  SELECT ts, SUBSTR(name, 19) AS completed
  FROM slice
  WHERE
    dur = 0
    -- Originally completed was unqualified, but at some point we introduced
    -- the startup type as well
    AND name GLOB 'launchingActivity#*:completed*:*'
    AND NOT name GLOB '*:completed-same-process:*'
)
GROUP BY 1, 2, 3;

CREATE PERFETTO TABLE _startups_minsdk33 AS
SELECT
  startup_id,
  ts,
  ts + dur AS ts_end,
  dur,
  package_name AS package,
  startup_type
FROM _startup_async_events
JOIN _startup_complete_events USING (startup_id);

)_d3l1m1t3r_"
;

const char kAndroidStartupTimeToDisplay[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.startup.startups;
INCLUDE PERFETTO MODULE android.frames.timeline;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO VIEW _startups_with_upid AS
WITH joined_with_processes AS (
  SELECT
    s.*,
    p.upid
  FROM android_startups s
  LEFT JOIN android_startup_processes p USING (startup_id)
),
fallback AS (
  SELECT
    s.*,
    upid FROM android_startups s
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN process p ON (p.name glob s.package)
)
  SELECT
    j.startup_id,
    j.ts,
    j.ts_end,
    j.dur,
    j.package,
    j.startup_type,
    COALESCE(j.upid, f.upid) AS upid
  FROM joined_with_processes j
  LEFT JOIN fallback f ON (j.upid IS NULL AND j.startup_id = f.startup_id);

-- Get Time To Initial Display of the startup calculated as time between the
-- startup started and the first frame that was started by Choreographer on the
-- UI thread of the startup finished drawing.
-- TTID (https://developer.android.com/topic/performance/vitals/launch-time#time-initial)
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE _ttid AS
WITH frames_with_upid AS (
  SELECT
  f.*,
  upid
  FROM android_frames f
  JOIN thread t ON (f.ui_thread_utid = t.utid)
),
  -- First `DrawFrame` on Render Thread after the startup.
first_frame_for_startup AS (
  SELECT
    startup_id,
    frame_id,
    s.ts AS startup_ts,
    draw_frame_id,
    s.upid
  FROM _startups_with_upid s
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  JOIN frames_with_upid f ON (s.upid = f.upid AND s.ts <= f.ts)
  GROUP BY startup_id
  ORDER BY startup_id, f.ts)
SELECT
  startup_id,
  frame_id,
  draw_frame_id,
  ts + dur - startup_ts AS ttid,
  upid
FROM first_frame_for_startup
JOIN slice ON (slice.id = draw_frame_id);

-- Get Time To Full Display of the startup calculated as time between the
-- startup started and the first frame that was started by Choreographer after
-- or containing the `reportFullyDrawn()` slice on the UI thread of the startup
-- finished drawing.
-- TTFD (https://developer.android.com/topic/performance/vitals/launch-time#retrieve-TTFD)
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE _ttfd AS
-- First `reportFullyDrawn` slice for each startup.
WITH first_report_fully_drawn_for_startup AS (
  SELECT
  startup_id,
  s.ts AS startup_ts,
  t.ts AS report_fully_drawn_ts,
  t.utid,
  s.upid
FROM _startups_with_upid s
JOIN thread_slice t ON (s.upid = t.upid AND t.ts >= s.ts)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE name GLOB "reportFullyDrawn*" AND t.is_main_thread = 1
GROUP BY startup_id
ORDER BY startup_id, t.ts),
-- After the first `reportFullyDrawn` find the first `Choreographer#DoFrame` on
-- the UI thread and it's first `DrawFrame` on Render Thread.
first_frame_after_report_for_startup AS (
  SELECT
    startup_id,
    frame_id,
    startup_ts,
    draw_frame_id,
    s.upid
  FROM first_report_fully_drawn_for_startup s
  JOIN android_frames f ON (
    s.utid = f.ui_thread_utid
    -- We are looking for the first DrawFrame that was started by the first
    -- "Choreographer#DoFrame" on UI thread after or containing
    -- reportFullyDrawn. In Android UIs, it's common to have UI code happen
    -- either before a frame, or during it, and generally non-trivial amounts
    -- of "update UI model" code doesn't try to differentiate these. We account
    -- for both of these by looking for the first UI slice that ends after the
    -- "reportFullyDrawnSlice" begins.
    AND report_fully_drawn_ts < (f.ts + f.dur))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP BY startup_id
  ORDER BY startup_id, f.ts
)
-- Get TTFD as the difference between the start of the startup and the end of
-- `DrawFrame` slice we previously found.
SELECT
  startup_id,
  frame_id,
  draw_frame_id,
  ts + dur - startup_ts AS ttfd,
  upid
FROM first_frame_after_report_for_startup
JOIN slice ON (slice.id = draw_frame_id);

-- Startup metric defintions, which focus on the observable time range:
-- TTID - Time To Initial Display
-- * https://developer.android.com/topic/performance/vitals/launch-time#time-initial
-- * end of first RenderThread.DrawFrame - bindApplication
-- TTFD - Time To Full Display
-- * https://developer.android.com/topic/performance/vitals/launch-time#retrieve-TTFD
-- * end of next RT.DrawFrame, after reportFullyDrawn called - bindApplication
-- Googlers: see go/android-performance-metrics-glossary for details.
CREATE PERFETTO TABLE android_startup_time_to_display(
  -- Startup id.
  startup_id LONG,
  -- Time to initial display (TTID)
  time_to_initial_display LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Time to full display (TTFD)
  time_to_full_display LONG,
  -- `android_frames.frame_id` of frame for initial display
  ttid_frame_id LONG,
  -- `android_frames.frame_id` of frame for full display
  ttfd_frame_id LONG,
  -- `process.upid` of the startup
  upid JOINID(process.id)
) AS
SELECT
  startup_id,
  ttid AS time_to_initial_display,
  ttfd AS time_to_full_display,
  _ttid.frame_id AS ttid_frame_id,
  _ttfd.frame_id AS ttfd_frame_id,
  _ttid.upid
FROM android_startups
LEFT JOIN _ttid USING (startup_id)
LEFT JOIN _ttfd USING (startup_id);

)_d3l1m1t3r_"
;

const char kAndroidWinscopeInputmethod[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android inputmethod clients state dumps (from android.inputmethod data source).
CREATE PERFETTO VIEW android_inputmethod_clients(
  -- Dump id
  id LONG,
  -- Timestamp when the dump was triggered
  ts TIMESTAMP,
  -- Extra args parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
SELECT
  id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_inputmethod_clients;

-- Android inputmethod manager service state dumps (from android.inputmethod data source).
CREATE PERFETTO VIEW android_inputmethod_manager_service(
  -- Dump id
  id LONG,
  -- Timestamp when the dump was triggered
  ts TIMESTAMP,
  -- Extra args parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
) AS
SELECT
  id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_inputmethod_manager_service;

-- Android inputmethod service state dumps (from android.inputmethod data source).
CREATE PERFETTO VIEW android_inputmethod_service(
  -- Dump id
  id LONG,
  -- Timestamp when the dump was triggered
  ts TIMESTAMP,
  -- Extra args parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- String id for raw proto message
  base64_proto_id LONG
) AS
SELECT
  id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_inputmethod_service;

)_d3l1m1t3r_"
;

const char kAndroidWinscopeViewcapture[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android viewcapture (from android.viewcapture data source).
CREATE PERFETTO VIEW android_viewcapture(
  -- Snapshot id
  id LONG,
  -- Timestamp when the snapshot was triggered
  ts TIMESTAMP,
  -- Extra args parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
SELECT
  id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_viewcapture;

)_d3l1m1t3r_"
;

const char kAndroidWinscopeWindowmanager[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android WindowManager (from android.windowmanager data source).
CREATE PERFETTO VIEW android_windowmanager(
  -- Snapshot id
  id LONG,
  -- Timestamp when the snapshot was triggered
  ts TIMESTAMP,
  -- Extra args parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
SELECT
  id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_windowmanager;

)_d3l1m1t3r_"
;

const char kAndroidAnrs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- List of all ANRs that occurred in the trace (one row per ANR).
CREATE PERFETTO VIEW android_anrs(
  -- Name of the process that triggered the ANR.
  process_name STRING,
  -- PID of the process that triggered the ANR.
  pid LONG,
  -- UPID of the process that triggered the ANR.
  upid JOINID(process.id),
  -- UUID of the ANR (generated on the platform).
  error_id STRING,
  -- Timestamp of the ANR.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Subject line of the ANR.
  subject STRING
) AS
-- Process and PID that ANRed.
WITH anr AS (
  SELECT
    -- Counter formats:
    -- v1: "ErrorId:<process_name>#<UUID>"
    -- v2: "ErrorId:<process_name> <pid>#<UUID>"
    STR_SPLIT(SUBSTR(STR_SPLIT(process_counter_track.name, '#', 0), 9), ' ', 0) AS process_name,
    cast_int!(STR_SPLIT(SUBSTR(STR_SPLIT(process_counter_track.name, '#', 0), 9), ' ', 1)) AS pid,
    STR_SPLIT(process_counter_track.name, '#', 1) AS error_id,
    counter.ts
  FROM process_counter_track
  JOIN process USING (upid)
  JOIN counter ON (counter.track_id = process_counter_track.id)
  WHERE process_counter_track.name GLOB 'ErrorId:*'
    AND process.name = 'system_server'
),
-- ANR subject line.
subject AS (
  --- Counter format:
  --- "Subject(for ErrorId <UUID>):<subject>"
  SELECT
    SUBSTR(STR_SPLIT(process_counter_track.name, ')', 0), 21) AS error_id,
    SUBSTR(process_counter_track.name, length(STR_SPLIT(process_counter_track.name, ')', 0)) + 3) AS subject
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM process_counter_track
  JOIN process
  USING (upid)
  WHERE process_counter_track.name GLOB 'Subject(for ErrorId *'
  AND process.name = 'system_server'
)
SELECT
    anr.process_name,
    anr.pid,
    process.upid,
    anr.error_id,
    anr.ts,
    subject
FROM anr
LEFT JOIN subject USING (error_id)
LEFT JOIN process ON (process.pid = anr.pid);
)_d3l1m1t3r_"
;

const char kAndroidAppProcessStarts[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE slices.with_context;

-- All process starts.
CREATE PERFETTO VIEW _proc_start
AS
SELECT ts, dur, TRIM(SUBSTR(name, 12)) AS process_name
FROM thread_slice
WHERE name GLOB 'Start proc:*' AND process_name = 'system_server';

-- Broadcast, service and activity cold starts.
CREATE PERFETTO TABLE _cold_start
AS
WITH
  lifecycle_slice AS (
    SELECT
      id,
      ts AS intent_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      dur AS intent_dur,
      track_id,
      name,
      upid,
      process_name,
      pid,
      utid,
      CASE
        WHEN name GLOB 'performCreate:*' THEN 'activity'
        WHEN name GLOB 'serviceCreate:*' THEN 'service'
        WHEN name GLOB 'broadcastReceiveComp:*' THEN 'broadcast'
      END AS reason,
            CASE
        WHEN name GLOB 'performCreate:*' THEN STR_SPLIT(name, 'performCreate:', 1)
        WHEN name GLOB 'serviceCreate:*' THEN STR_SPLIT(STR_SPLIT(name, '=', 2), ' ', 0)
        WHEN name GLOB 'broadcastReceive*' THEN STR_SPLIT(name, 'broadcastReceiveComp:', 1)
        END AS intent
    FROM thread_slice slice
    WHERE
      name GLOB 'bindApplication'
      OR name GLOB 'performCreate:*'
      OR name GLOB 'serviceCreate:*'
      OR name GLOB 'broadcastReceiveComp:*'
    ORDER BY ts
  ),
  cold_start AS (
    SELECT
      *,
      lag(name) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_name,
      lag(intent_ts) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      lag(intent_dur) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_dur,
      lag(id) OVER (PARTITION BY track_id ORDER BY intent_ts) AS bind_app_id
    FROM lifecycle_slice
  )
SELECT * FROM cold_start WHERE bind_app_name = 'bindApplication';

-- Join Broadcast, service and activity cold starts with process starts.
CREATE PERFETTO VIEW _cold_proc_start
AS
SELECT
  cold_start.*,
  MAX(proc_start.ts) AS proc_start_ts,
  proc_start.dur AS proc_start_dur,
  cold_start.intent_ts - MAX(proc_start.ts) + cold_start.intent_dur AS total_dur
FROM _cold_start cold_start
JOIN _proc_start proc_start
  ON proc_start.process_name = cold_start.process_name AND cold_start.intent_ts > proc_start.ts
GROUP BY cold_start.upid;

-- Provider cold starts.
CREATE PERFETTO TABLE _provider_start
AS
WITH
  provider_start AS (
    SELECT id AS bind_app_id FROM slice WHERE name = 'bindApplication'
    EXCEPT
    SELECT bind_app_id FROM _cold_start
  )
SELECT * FROM provider_start JOIN thread_slice ON id = bind_app_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Join Provider cold starts with process starts.
CREATE PERFETTO VIEW _provider_proc_start
AS
SELECT
  cold_start.*,
  MAX(proc_start.ts) AS proc_start_ts,
  proc_start.dur AS proc_start_dur,
  cold_start.ts - MAX(proc_start.ts) + cold_start.dur AS total_dur
FROM _provider_start cold_start
JOIN _proc_start proc_start
  ON proc_start.process_name = cold_start.process_name AND cold_start.ts > proc_start.ts
GROUP BY cold_start.upid;

-- All app cold starts with information about their cold start reason:
-- broadcast, service, activity or provider.
CREATE PERFETTO TABLE android_app_process_starts(
  -- Slice id of the bindApplication slice in the app. Uniquely identifies a process start.
  start_id LONG,
  -- Slice id of intent received in the app.
  id LONG,
  -- Track id of the intent received in the app.
  track_id JOINID(track.id),
  -- Name of the process receiving the intent.
  process_name STRING,
  -- Pid of the process receiving the intent.
  pid LONG,
  -- Upid of the process receiving the intent.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  upid JOINID(process.id),
  -- Intent action or component responsible for the cold start.
  intent STRING,
  -- Process start reason: activity, broadcast, service or provider.
  reason STRING,
  -- Timestamp the process start was dispatched from system_server.
  proc_start_ts TIMESTAMP,
  -- Duration to dispatch the process start from system_server.
  proc_start_dur DURATION,
  -- Timestamp the bindApplication started in the app.
  bind_app_ts TIMESTAMP,
  -- Duration to complete bindApplication in the app.
  bind_app_dur DURATION,
  -- Timestamp the Intent was received in the app.
  intent_ts TIMESTAMP,
  -- Duration to handle intent in the app.
  intent_dur DURATION,
  -- Total duration from proc_start dispatched to intent completed.
  total_dur LONG
) AS
SELECT
  bind_app_id AS start_id,
  id,
  track_id,
  process_name,
  pid,
  upid,
  intent,
  reason,
  proc_start_ts,
  proc_start_dur,
  bind_app_ts,
  bind_app_dur,
  intent_ts,
  intent_dur,
  total_dur
FROM _cold_proc_start
UNION ALL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  bind_app_id AS start_id,
  NULL AS id,
  NULL AS track_id,
  process_name,
  pid,
  upid,
  NULL AS intent,
  'provider' AS reason,
  proc_start_ts,
  proc_start_dur,
  ts AS bind_app_ts,
  dur AS bind_app_dur,
  NULL AS intent_ts,
  NULL AS intent_dur,
  total_dur
FROM _provider_proc_start;

)_d3l1m1t3r_"
;

const char kAndroidBattery[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Battery charge at timestamp.
CREATE PERFETTO VIEW android_battery_charge(
  -- Timestamp.
  ts TIMESTAMP,
  -- Current average micro ampers.
  current_avg_ua DOUBLE,
  -- Current capacity percentage.
  capacity_percent DOUBLE,
  -- Current charge in micro ampers.
  charge_uah DOUBLE,
  -- Current micro ampers.
  current_ua DOUBLE,
  -- Current voltage in micro volts.
  voltage_uv DOUBLE,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Current energy counter in microwatt-hours(Wh).
  energy_counter_uwh DOUBLE
)  AS
SELECT
  all_ts.ts,
  current_avg_ua,
  capacity_percent,
  charge_uah,
  current_ua,
  voltage_uv,
  energy_counter_uwh
FROM (
  SELECT DISTINCT(ts) AS ts
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name GLOB 'batt.*'
) AS all_ts
LEFT JOIN (
  SELECT ts, value AS current_avg_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current.avg_ua'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS capacity_percent
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.capacity_pct'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS charge_uah
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.charge_uah'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS current_ua
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.current_ua'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS voltage_uv
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.voltage_uv'
) USING(ts)
LEFT JOIN (
  SELECT ts, value AS energy_counter_uwh
  FROM counter c
  JOIN counter_track t ON c.track_id = t.id
  WHERE name = 'batt.energy_counter_uwh'
) USING(ts)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kAndroidBatteryStats[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Converts a battery_stats counter value to human readable string.
CREATE PERFETTO FUNCTION android_battery_stats_counter_to_string(
  -- The counter track name (e.g. 'battery_stats.audio').
  track STRING,
  -- The counter value.
  value DOUBLE)
-- The human-readable name for the counter value.
RETURNS STRING AS
SELECT
  CASE
    WHEN ($track = "battery_stats.wifi_scan" OR
          $track = "battery_stats.wifi_radio" OR
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          $track = "battery_stats.mobile_radio" OR
          $track = "battery_stats.audio" OR
          $track = "battery_stats.video" OR
          $track = "battery_stats.camera" OR
          $track = "battery_stats.power_save" OR
          $track = "battery_stats.phone_in_call")
      THEN
        CASE $value
          WHEN 0 THEN "inactive"
          WHEN 1 THEN "active"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi"
      THEN
        CASE $value
          WHEN 0 THEN "off"
          WHEN 1 THEN "on"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.phone_state"
      THEN
        CASE $value
          WHEN 0 THEN "in"
          WHEN 1 THEN "out"
          WHEN 2 THEN "emergency"
          WHEN 3 THEN "off"
          ELSE "unknown"
        END
    WHEN ($track = "battery_stats.phone_signal_strength" OR
          $track = "battery_stats.wifi_signal_strength")
      THEN
        CASE $value
          WHEN 0 THEN "0/4"
          WHEN 1 THEN "1/4"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHEN 2 THEN "2/4"
          WHEN 3 THEN "3/4"
          WHEN 4 THEN "4/4"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.wifi_suppl"
      THEN
        CASE $value
          WHEN 0 THEN "invalid"
          WHEN 1 THEN "disconnected"
          WHEN 2 THEN "disabled"
          WHEN 3 THEN "inactive"
          WHEN 4 THEN "scanning"
          WHEN 5 THEN "authenticating"
          WHEN 6 THEN "associating"
          WHEN 7 THEN "associated"
          WHEN 8 THEN "4-way-handshake"
          WHEN 9 THEN "group-handshake"
          WHEN 10 THEN "completed"
          WHEN 11 THEN "dormant"
          WHEN 12 THEN "uninitialized"
          ELSE "unknown"
        END
    WHEN $track = "battery_stats.data_conn"
      THEN
        CASE $value
          WHEN 0 THEN "Out of service"
          WHEN 1 THEN "2.5G (GPRS)"
          WHEN 2 THEN "2.7G (EDGE)"
          WHEN 3 THEN "3G (UMTS)"
          WHEN 4 THEN "3G (CDMA)"
          WHEN 5 THEN "3G (EVDO Rel 0)"
          WHEN 6 THEN "3G (EVDO Rev A)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          WHEN 7 THEN "3G (LXRTT)"
          WHEN 8 THEN "3.5G (HSDPA)"
          WHEN 9 THEN "3.5G (HSUPA)"
          WHEN 10 THEN "3.5G (HSPA)"
          WHEN 11 THEN "2G (IDEN)"
          WHEN 12 THEN "3G (EVDO Rev B)"
          WHEN 13 THEN "4G (LTE)"
          WHEN 14 THEN "3.5G (eHRPD)"
          WHEN 15 THEN "3.7G (HSPA+)"
          WHEN 16 THEN "2G (GSM)"
          WHEN 17 THEN "3G (TD SCDMA)"
          WHEN 18 THEN "Wifi calling (IWLAN)"
          WHEN 19 THEN "4.5G (LTE CA)"
          WHEN 20 THEN "5G (NR)"
          WHEN 21 THEN "Emergency calls only"
          WHEN 22 THEN "Other"
          ELSE "unknown"
        END
    ELSE cast_string!($value)
  END;

-- View of human readable battery stats counter-based states. These are recorded
-- by BatteryStats as a bitmap where each 'category' has a unique value at any
-- given time.
CREATE PERFETTO VIEW android_battery_stats_state(
  -- Start of the new barrary state.
  ts TIMESTAMP,
  -- The duration the state was active, -1 for incomplete slices.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- The same as `dur`, but extends to trace end for incomplete slices.
  safe_dur DURATION,
  -- The name of the counter track.
  track_name STRING,
  -- The counter value as a number.
  value LONG,
  -- The counter value as a human-readable string.
  value_name STRING
) AS
SELECT
  ts,
  IFNULL(LEAD(ts) OVER (PARTITION BY name ORDER BY ts) - ts, -1) AS dur,
  LEAD(ts, 1, TRACE_END()) OVER (PARTITION BY name ORDER BY ts) - ts AS safe_dur,
  name AS track_name,
  cast_int!(value) AS value,
  android_battery_stats_counter_to_string(name, value) AS value_name
FROM counter
JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE counter_track.name GLOB 'battery_stats.*';


-- View of slices derived from battery_stats events. Battery stats records all
-- events as instants, however some may indicate whether something started or
-- stopped with a '+' or '-' prefix. Events such as jobs, top apps, foreground
-- apps or long wakes include these details and allow drawing slices between
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- instant events found in a trace.
--
-- For example, we may see an event like the following on 'battery_stats.top':
--
--     -top=10215:"com.google.android.apps.nexuslauncher"
--
-- This view will find the associated start ('+top') with the matching suffix
-- (everything after the '=') to construct a slice. It computes the timestamp
-- and duration from the events and extract the details as follows:
--
--     track_name='battery_stats.top'
--     str_value='com.google.android.apps.nexuslauncher'
--     int_value=10215
CREATE PERFETTO VIEW android_battery_stats_event_slices(
  -- Start of a new battery state.
  ts TIMESTAMP,
  -- The duration the state was active, -1 for incomplete slices.
  dur DURATION,
  -- The same as `dur`, but extends to trace end for incomplete slices.
  safe_dur DURATION,
  -- The name of the counter track.
  track_name STRING,
  -- String value.
  str_value STRING,
  -- Int value.
  int_value LONG
) AS
WITH
  event_markers AS (
    SELECT
      ts,
      track.name AS track_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      str_split(slice.name, '=', 1) AS key,
      substr(slice.name, 1, 1) = '+' AS start
    FROM slice
    JOIN track
      ON slice.track_id = track.id
    WHERE
      track_name GLOB 'battery_stats.*'
      AND substr(slice.name, 1, 1) IN ('+', '-')
  ),
  with_neighbors AS (
    SELECT
      *,
      LAG(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS last_ts,
      LEAD(ts) OVER (PARTITION BY track_name, key ORDER BY ts) AS next_ts
    FROM event_markers
  ),
  -- Note: query performance depends on the ability to push down filters on
  -- the track_name. It would be more clear below to have two queries and union
  -- them, but doing so prevents push down through the above window functions.
  event_spans AS (
    SELECT
      track_name, key,
      IIF(start, ts, trace_start()) AS ts,
      IIF(start, next_ts, ts) AS end_ts
    FROM with_neighbors
    -- For the majority of events, we take the `start` event and compute the dur
    -- based on next_ts. In the off chance we get an end event with no prior
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- start (matched by the second half of this where), we can create an event
    -- starting from the beginning of the trace ending at the current event.
    WHERE (start OR last_ts IS NULL)
  )
SELECT
  ts,
  IFNULL(end_ts-ts, -1) AS dur,
  IFNULL(end_ts, TRACE_END()) - ts AS safe_dur,
  track_name,
  str_split(key, '"', 1) AS str_value,
  cast_int!(str_split(key, ':', 0)) AS int_value
FROM event_spans;

)_d3l1m1t3r_"
;

const char kAndroidBinder[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.process_metadata;
INCLUDE PERFETTO MODULE android.suspend;
INCLUDE PERFETTO MODULE slices.flow;

-- Count Binder transactions per process.
CREATE PERFETTO VIEW android_binder_metrics_by_process(
  -- Name of the process that started the binder transaction.
  process_name STRING,
  -- PID of the process that started the binder transaction.
  pid LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Name of the slice with binder transaction.
  slice_name STRING,
  -- Number of binder transactions in process in slice.
  event_count LONG
) AS
SELECT
  process.name AS process_name,
  process.pid AS pid,
  slice.name AS slice_name,
  COUNT(*) AS event_count
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread ON thread.utid = thread_track.utid
JOIN process ON thread.upid = process.upid
WHERE
  slice.name GLOB 'binder*'
GROUP BY
  process_name,
  slice_name;

CREATE PERFETTO TABLE _binder_txn_merged AS
WITH maybe_broken_binder_txn AS (
  -- Fetch the broken binder txns first, i.e, the txns that have children slices
  -- They may be broken because synchronous txns are typically blocked sleeping while
  -- waiting for a response.
  -- These broken txns will be excluded below in the binder_txn CTE
    SELECT ancestor.id
    FROM slice
    JOIN slice ancestor
      ON ancestor.id = slice.parent_id
    WHERE ancestor.name = 'binder transaction'
    GROUP BY ancestor.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ), nested_binder_txn AS (
    -- Detect the non-broken cases which are just nested binder txns
    SELECT DISTINCT root_node_id AS id FROM _slice_following_flow!(maybe_broken_binder_txn)
  ), broken_binder_txn AS (
  -- Exclude the nested txns from the 'maybe broken' set
    SELECT * FROM maybe_broken_binder_txn
    EXCEPT
    SELECT * FROM nested_binder_txn
  ),
  -- Adding MATERIALIZED here matters in cases where there are few/no binder
  -- transactions in the trace. Our cost estimation is not good enough to allow
  -- the query planner to see through to this fact. Instead, our cost estimation
  -- causes repeated queries on this table which is slow because it's an O(n)
  -- query.
  --
  -- We should fix this by doing some (ideally all) of the following:
  --  1) Add support for columnar tables in SQL which will allow for
  --     "subsetting" the slice table to only contain binder transactions.
  --  2) Make this query faster by adding improving string filtering.
  --  3) Add caching so that even if these queries happen many times, they are
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  --     fast.
  --  4) Improve cost estimation algorithm to allow the joins to happen the
  --     right way around.
  binder_txn AS MATERIALIZED (
    SELECT
      slice.id AS binder_txn_id,
      process.name AS process_name,
      thread.name AS thread_name,
      thread.utid AS utid,
      thread.tid AS tid,
      process.pid AS pid,
      process.upid AS upid,
      slice.ts,
      slice.dur,
      thread.is_main_thread
    FROM slice
    JOIN thread_track ON slice.track_id = thread_track.id
    JOIN thread USING (utid)
    JOIN process USING (upid)
    LEFT JOIN broken_binder_txn ON broken_binder_txn.id = slice.id
    WHERE slice.name = 'binder transaction'
    AND broken_binder_txn.id IS NULL
  ),
  binder_reply AS (
    SELECT
      binder_txn.*,
      binder_reply.ts AS server_ts,
      binder_reply.dur AS server_dur,
      binder_reply.id AS binder_reply_id,
      reply_thread.name AS server_thread,
      reply_process.name AS server_process,
      reply_thread.utid AS server_utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      reply_thread.tid AS server_tid,
      reply_process.pid AS server_pid,
      reply_process.upid AS server_upid,
      aidl.name AS aidl_name,
      aidl.ts AS aidl_ts,
      aidl.dur AS aidl_dur
    FROM binder_txn
    JOIN flow binder_flow ON binder_txn.binder_txn_id = binder_flow.slice_out
    JOIN slice binder_reply ON binder_flow.slice_in = binder_reply.id
    JOIN thread_track reply_thread_track
      ON binder_reply.track_id = reply_thread_track.id
    JOIN thread reply_thread ON reply_thread.utid = reply_thread_track.utid
    JOIN process reply_process ON reply_process.upid = reply_thread.upid
    LEFT JOIN slice aidl ON aidl.parent_id = binder_reply.id
        -- Filter for only server side AIDL slices as there are some client side ones for cpp
        AND (aidl.name GLOB 'AIDL::*Server'
             OR aidl.name GLOB 'AIDL::*server'
             OR aidl.name GLOB 'HIDL::*server')
  )
SELECT
  MIN(aidl_name) AS aidl_name,
  aidl_ts,
  aidl_dur,
  binder_txn_id,
  process_name AS client_process,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread_name AS client_thread,
  upid AS client_upid,
  utid AS client_utid,
  tid AS client_tid,
  pid AS client_pid,
  is_main_thread,
  ts AS client_ts,
  dur AS client_dur,
  binder_reply_id,
  server_process,
  server_thread,
  server_upid,
  server_utid,
  server_tid,
  server_pid,
  server_ts,
  server_dur
FROM binder_reply
WHERE client_dur != -1 AND server_dur != -1 AND client_dur >= server_dur
GROUP BY
  process_name,
  thread_name,
  binder_txn_id,
  binder_reply_id;

CREATE PERFETTO TABLE _oom_score AS
  SELECT
    process.upid,
    cast_int!(c.value) AS value,
    c.ts,
    IFNULL(LEAD(ts) OVER (PARTITION BY upid ORDER BY ts), trace_end()) AS end_ts
    FROM counter c
         JOIN process_counter_track t ON c.track_id = t.id
         JOIN process USING (upid)
   WHERE t.name = 'oom_score_adj';

CREATE PERFETTO INDEX _oom_score_idx ON _oom_score(upid, ts);

-- Breakdown synchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW _sync_binder_metrics_by_txn AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
FROM _binder_txn_merged binder
LEFT JOIN _oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN _oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

CREATE PERFETTO VIEW _binder_txn
AS
SELECT client_ts AS ts, client_dur AS dur, client_utid AS utid, *
FROM _sync_binder_metrics_by_txn;

CREATE PERFETTO VIEW _binder_reply
AS
SELECT server_ts AS ts, server_dur AS dur, server_utid AS utid, *
FROM _sync_binder_metrics_by_txn;

CREATE VIRTUAL TABLE _sp_binder_txn_thread_state
USING
  SPAN_JOIN(_binder_txn PARTITIONED utid, thread_state PARTITIONED utid);

CREATE VIRTUAL TABLE _sp_binder_reply_thread_state
USING
  SPAN_JOIN(_binder_reply PARTITIONED utid, thread_state PARTITIONED utid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Aggregated thread_states on the client and server side per binder txn
-- This builds on the data from |_sync_binder_metrics_by_txn| and
-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the thread state durations.
-- The |thread_state_type| column represents whether a given 'aggregated thread_state'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
-- is server side.
CREATE PERFETTO VIEW android_sync_binder_thread_state_by_txn(
  -- slice id of the binder txn
  binder_txn_id LONG,
  -- Client timestamp
  client_ts TIMESTAMP,
  -- Client tid
  client_tid LONG,
  -- slice id of the binder reply
  binder_reply_id LONG,
  -- Server timestamp
  server_ts TIMESTAMP,
  -- Server tid
  server_tid LONG,
  -- whether thread state is on the txn or reply side
  thread_state_type STRING,
  -- a thread_state that occurred in the txn
  thread_state STRING,
  -- aggregated dur of the |thread_state| in the txn
  thread_state_dur DURATION,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- aggregated count of the |thread_state| in the txn
  thread_state_count LONG
) AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM _sp_binder_txn_thread_state
GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state
UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM _sp_binder_reply_thread_state
GROUP BY binder_txn_id, binder_reply_id, thread_state_type, thread_state;

-- Aggregated blocked_functions on the client and server side per binder txn
-- This builds on the data from |_sync_binder_metrics_by_txn| and
-- for each end (client and server) of the transaction, it returns
-- the aggregated sum of all the kernel blocked function durations.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The |thread_state_type| column represents whether a given 'aggregated blocked_function'
-- row is on the client or server side. 'binder_txn' is client side and 'binder_reply'
-- is server side.
CREATE PERFETTO VIEW android_sync_binder_blocked_functions_by_txn(
  -- slice id of the binder txn
  binder_txn_id LONG,
  -- Client ts
  client_ts TIMESTAMP,
  -- Client tid
  client_tid LONG,
  -- slice id of the binder reply
  binder_reply_id LONG,
  -- Server ts
  server_ts TIMESTAMP,
  -- Server tid
  server_tid LONG,
  -- whether thread state is on the txn or reply side
  thread_state_type STRING,
  -- blocked kernel function in a thread state
  blocked_function STRING,
  -- aggregated dur of the |blocked_function| in the txn
  blocked_function_dur DURATION,
  -- aggregated count of the |blocked_function| in the txn
  blocked_function_count LONG
) AS
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_txn' AS thread_state_type,
  blocked_function,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM _sp_binder_txn_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function
UNION ALL
SELECT
  binder_txn_id,
  client_ts,
  client_tid,
  binder_reply_id,
  server_ts,
  server_tid,
  'binder_reply' AS thread_state_type,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM _sp_binder_reply_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY binder_txn_id, binder_reply_id, blocked_function;

CREATE PERFETTO TABLE _async_binder_reply AS
WITH async_reply AS MATERIALIZED (
  SELECT id, ts, dur, track_id, name
  FROM slice
  WHERE
    -- Filter for only server side AIDL slices as there are some client side ones for cpp
    name GLOB 'AIDL::*Server'
    OR name GLOB 'AIDL::*server'
    OR name GLOB 'HIDL::*server'
    OR name = 'binder async rcv'
) SELECT *, LEAD(name) OVER (PARTITION BY track_id ORDER BY ts) AS next_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    LEAD(ts) OVER (PARTITION BY track_id ORDER BY ts) AS next_ts,
    LEAD(dur) OVER (PARTITION BY track_id ORDER BY ts) AS next_dur
    FROM async_reply;

CREATE PERFETTO TABLE _binder_async_txn_raw AS
SELECT
  slice.id AS binder_txn_id,
  process.name AS client_process,
  thread.name AS client_thread,
  process.upid AS client_upid,
  thread.utid AS client_utid,
  thread.tid AS client_tid,
  process.pid AS client_pid,
  thread.is_main_thread,
  slice.ts AS client_ts,
  slice.dur AS client_dur
FROM slice
JOIN thread_track
  ON slice.track_id = thread_track.id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name = 'binder transaction async';

CREATE PERFETTO TABLE _binder_async_txn AS
SELECT
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_name) AS aidl_name,
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_ts) AS aidl_ts,
  IIF(binder_reply.next_name = 'binder async rcv', NULL, binder_reply.next_dur) AS aidl_dur,
  binder_txn.*,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  binder_reply.id AS binder_reply_id,
  reply_process.name AS server_process,
  reply_thread.name AS server_thread,
  reply_process.upid AS server_upid,
  reply_thread.utid AS server_utid,
  reply_thread.tid AS server_tid,
  reply_process.pid AS server_pid,
  binder_reply.ts AS server_ts,
  binder_reply.dur AS server_dur
FROM _binder_async_txn_raw binder_txn
JOIN flow binder_flow
  ON binder_txn.binder_txn_id = binder_flow.slice_out
JOIN _async_binder_reply binder_reply
  ON binder_flow.slice_in = binder_reply.id
JOIN thread_track reply_thread_track
  ON binder_reply.track_id = reply_thread_track.id
JOIN thread reply_thread
  ON reply_thread.utid = reply_thread_track.utid
JOIN process reply_process
  ON reply_process.upid = reply_thread.upid
WHERE binder_reply.name = 'binder async rcv';

-- Breakdown asynchronous binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
CREATE PERFETTO VIEW _async_binder_metrics_by_txn AS
SELECT binder.*, client_oom.value AS client_oom_score, server_oom.value AS server_oom_score
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _binder_async_txn binder
LEFT JOIN _oom_score client_oom
  ON
    binder.client_upid = client_oom.upid
    AND binder.client_ts BETWEEN client_oom.ts AND client_oom.end_ts
LEFT JOIN _oom_score server_oom
  ON
    binder.server_upid = server_oom.upid
    AND binder.server_ts BETWEEN server_oom.ts AND server_oom.end_ts;

-- Breakdown binder transactions per txn.
-- It returns data about the client and server ends of every binder transaction async.
CREATE PERFETTO TABLE android_binder_txns(
  -- name of the binder interface if existing.
  aidl_name STRING,
  -- Timestamp the binder interface name was emitted. Proxy to 'ts' and 'dur' for async txns.
  aidl_ts TIMESTAMP,
  -- Duration of the binder interface name. Proxy to 'ts' and 'dur' for async txns.
  aidl_dur DURATION,
  -- slice id of the binder txn.
  binder_txn_id LONG,
  -- name of the client process.
  client_process STRING,
  -- name of the client thread.
  client_thread STRING,
  -- Upid of the client process.
  client_upid JOINID(process.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Utid of the client thread.
  client_utid JOINID(thread.id),
  -- Tid of the client thread.
  client_tid LONG,
  -- Pid of the client thread.
  client_pid LONG,
  -- Whether the txn was initiated from the main thread of the client process.
  is_main_thread BOOL,
  -- timestamp of the client txn.
  client_ts TIMESTAMP,
  -- wall clock dur of the client txn.
  client_dur DURATION,
  -- slice id of the binder reply.
  binder_reply_id LONG,
  -- name of the server process.
  server_process STRING,
  -- name of the server thread.
  server_thread STRING,
  -- Upid of the server process.
  server_upid JOINID(process.id),
  -- Utid of the server thread.
  server_utid JOINID(thread.id),
  -- Tid of the server thread.
  server_tid LONG,
  -- Pid of the server thread.
  server_pid LONG,
  -- timestamp of the server txn.
  server_ts TIMESTAMP,
  -- wall clock dur of the server txn.
  server_dur DURATION,
  -- oom score of the client process at the start of the txn.
  client_oom_score LONG,
  -- oom score of the server process at the start of the reply.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  server_oom_score LONG,
  -- whether the txn is synchronous or async (oneway).
  is_sync BOOL,
  -- monotonic clock dur of the client txn.
  client_monotonic_dur DURATION,
  -- monotonic clock dur of the server txn.
  server_monotonic_dur DURATION,
  -- Client package version_code.
  client_package_version_code LONG,
  -- Server package version_code.
  server_package_version_code LONG,
  -- Whether client package is debuggable.
  is_client_package_debuggable LONG,
  -- Whether server package is debuggable.
  is_server_package_debuggable LONG
) AS WITH all_binder AS (
  SELECT *, 1 AS is_sync FROM _sync_binder_metrics_by_txn
UNION ALL
SELECT *, 0 AS is_sync FROM _async_binder_metrics_by_txn
) SELECT
  all_binder.*,
  _extract_duration_without_suspend(client_ts, client_dur) AS client_monotonic_dur,
  _extract_duration_without_suspend(server_ts, server_dur) AS server_monotonic_dur,
  client_process_metadata.version_code AS client_package_version_code,
  server_process_metadata.version_code AS server_package_version_code,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  client_process_metadata.debuggable AS is_client_package_debuggable,
  server_process_metadata.debuggable AS is_server_package_debuggable
FROM all_binder
LEFT JOIN android_process_metadata client_process_metadata
  ON all_binder.client_upid = client_process_metadata.upid
LEFT JOIN android_process_metadata server_process_metadata
  ON all_binder.server_upid = server_process_metadata.upid;

-- Returns a DAG of all outgoing binder txns from a process.
-- The roots of the graph are the threads making the txns and the graph flows from:
-- thread -> server_process -> AIDL interface -> AIDL method.
-- The weights of each node represent the wall execution time in the server_process.
CREATE PERFETTO FUNCTION android_binder_outgoing_graph(
  -- Upid of process to generate an outgoing graph for.
  upid JOINID(process.id))
RETURNS TABLE(
  -- Pprof of outgoing binder txns.
  pprof BYTES) AS
WITH threads AS (
  SELECT binder_txn_id, CAT_STACKS(client_thread) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND client_upid = $upid) OR ($upid IS NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(), server_process AS (
  SELECT binder_txn_id, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN threads USING(binder_txn_id)
), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
  FROM android_binder_txns
  JOIN server_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a DAG of all incoming binder txns from a process.
-- The roots of the graph are the clients making the txns and the graph flows from:
-- client_process -> AIDL interface -> AIDL method.
-- The weights of each node represent the wall execution time in the server_process.
CREATE PERFETTO FUNCTION android_binder_incoming_graph(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Upid of process to generate an incoming graph for.
  upid JOINID(process.id))
RETURNS TABLE(
  -- Pprof of incoming binder txns.
  pprof BYTES) AS
WITH client_process AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
  FROM android_binder_txns
  WHERE ($upid IS NOT NULL AND server_upid = $upid) OR ($upid IS NULL)
), end_points AS (
  SELECT binder_txn_id,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 2, 1))) AS stack
  FROM android_binder_txns
  JOIN client_process USING(binder_txn_id)
), aidl_names AS (
  SELECT binder_txn_id, server_dur,
         CAT_STACKS(stack, STR_SPLIT(aidl_name, '::', IIF(aidl_name GLOB 'AIDL*', 3, 2))) AS stack
  FROM android_binder_txns
  JOIN end_points USING(binder_txn_id)
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
  FROM aidl_names;

-- Returns a graph of all binder txns in a trace.
-- The nodes are client_process and server_process.
-- The weights of each node represent the wall execution time in the server_process.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION android_binder_graph(
  -- Matches txns from client_processes greater than or equal to the OOM score.
  min_client_oom_score LONG,
  -- Matches txns from client_processes less than or equal to the OOM score.
  max_client_oom_score LONG,
  -- Matches txns to server_processes greater than or equal to the OOM score.
  min_server_oom_score LONG,
  -- Matches txns to server_processes less than or equal to the OOM score.
  max_server_oom_score LONG)
RETURNS TABLE(
  -- Pprof of binder txns.
  pprof BYTES) AS
WITH clients AS (
  SELECT binder_txn_id, CAT_STACKS(client_process) AS stack
   FROM android_binder_txns
   WHERE client_oom_score BETWEEN $min_client_oom_score AND $max_client_oom_score
), servers AS (
  SELECT binder_txn_id, server_dur, CAT_STACKS(stack, server_process) AS stack
  FROM android_binder_txns
  JOIN clients USING(binder_txn_id)
  WHERE server_oom_score BETWEEN $min_server_oom_score AND $max_server_oom_score
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', server_dur) AS pprof
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM servers;

)_d3l1m1t3r_"
;

const char kAndroidBinderBreakdown[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE intervals.overlap;
INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE slices.with_context;

-- Client side of all binder txns, sorted by client_ts. Suitable for interval_intersect.
CREATE PERFETTO VIEW _binder_client_view
AS
SELECT binder_txn_id AS id, client_upid AS upid, client_ts AS ts, client_dur AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM android_binder_txns
WHERE client_dur > 0
ORDER BY ts;

-- Server side of all binder txns, sorted by server_ts. Suitable for interval_intersect.
CREATE PERFETTO VIEW _binder_server_view
AS
SELECT binder_txn_id AS id, server_upid AS upid, server_ts AS ts, server_dur AS dur
FROM android_binder_txns
WHERE server_dur > 0
ORDER BY ts;

-- Thread state view suitable for interval intersect.
CREATE PERFETTO VIEW _thread_state_view
AS
SELECT id, ts, dur, utid, cpu, state, io_wait
FROM thread_state WHERE dur > 0
ORDER BY ts;

-- Partitions and flattens slices underneath the server or client side of binder txns.
-- The |name| column in the output is the lowest depth slice name in a given partition.
CREATE PERFETTO MACRO _binder_flatten_descendants(id ColumnName, ts ColumnName, dur ColumnName,
                                                  slice_name ColumnName)
RETURNS TableOrSubQuery
AS (
  WITH
  root_slices AS (
    SELECT $id AS id, $ts AS ts, $dur AS dur FROM android_binder_txns
  ),
  child_slices AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT slice.id AS root_id, dec.*
    FROM slice
    JOIN descendant_slice(slice.id) dec
    WHERE slice.name = $slice_name
  ),
  flat_slices AS (
    SELECT root_id, id, ts, dur
    FROM
      _intervals_flatten !(_intervals_merge_root_and_children !(root_slices, child_slices))
  )
SELECT
  row_number() OVER () AS id,
  root_slice.binder_txn_id,
  root_slice.binder_reply_id,
  flat_slices.id AS flat_id,
  flat_slices.ts,
  flat_slices.dur,
  thread_slice.name,
  thread_slice.utid
FROM flat_slices
JOIN thread_slice
  USING (id)
JOIN android_binder_txns root_slice
  ON root_slice.$id = root_id
WHERE flat_slices.dur > 0
);

-- Server side flattened descendant slices.
CREATE PERFETTO TABLE _binder_server_flat_descendants
AS
SELECT * FROM _binder_flatten_descendants!(binder_reply_id, server_ts, server_dur, 'binder reply')
ORDER BY ts;

-- Client side flattened descendant slices.
CREATE PERFETTO TABLE _binder_client_flat_descendants
AS
SELECT * FROM _binder_flatten_descendants!(binder_txn_id, client_ts, client_dur, 'binder transaction')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts;

-- Server side flattened descendants intersected with their thread_states.
CREATE PERFETTO TABLE _binder_server_flat_descendants_with_thread_state
AS
SELECT
  ii.ts,
  ii.dur,
  _server_flat.binder_txn_id,
  _server_flat.binder_reply_id,
  _server_flat.name,
  _server_flat.flat_id,
  _thread_state_view.state,
  _thread_state_view.io_wait
FROM _interval_intersect !((_binder_server_flat_descendants, _thread_state_view), (utid)) ii
JOIN _binder_server_flat_descendants _server_flat
  ON id_0 = _server_flat.id
JOIN _thread_state_view
  ON id_1 = _thread_state_view.id;

-- Client side flattened descendants intersected with their thread_states.
CREATE PERFETTO TABLE _binder_client_flat_descendants_with_thread_state
AS
SELECT
  ii.ts,
  ii.dur,
  _client_flat.binder_txn_id,
  _client_flat.binder_reply_id,
  _client_flat.name,
  _client_flat.flat_id,
  _thread_state_view.state,
  _thread_state_view.io_wait
FROM _interval_intersect !((_binder_client_flat_descendants, _thread_state_view), (utid)) ii
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN _binder_client_flat_descendants _client_flat
  ON id_0 = _client_flat.id
JOIN _thread_state_view
  ON id_1 = _thread_state_view.id;

-- Returns the 'reason' for a binder txn delay based on the descendant slice name and thread_state
-- information. It follows the following priority:
-- 1. direct_reclaim.
-- 2. GC blocking stall.
-- 3. Sleeping in monitor contention.
-- 4. Sleeping in ART lock contention.
-- 5. Sleeping in binder txn or reply.
-- 6. Sleeping in Mutex contention.
-- 7. IO.
-- 8. State itself.
CREATE PERFETTO FUNCTION _binder_reason(
  name STRING,
  state STRING,
  io_wait LONG,
  binder_txn_id LONG,
  binder_reply_id LONG,
  flat_id LONG)
RETURNS STRING
AS
SELECT
  CASE
    WHEN $name = 'mm_vmscan_direct_reclaim' THEN 'kernel_memory_reclaim'
    WHEN $name GLOB 'GC: Wait For*' THEN 'userspace_memory_reclaim'
    WHEN
      $state = 'S'
      AND ($name GLOB 'monitor contention*' OR $name GLOB 'Lock contention on a monitor lock*')
      THEN 'monitor_contention'
    WHEN $state = 'S' AND ($name GLOB 'Lock contention*') THEN 'art_lock_contention'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN
      $state = 'S'
      AND $binder_reply_id != $flat_id
      AND $binder_txn_id != $flat_id
      AND ($name = 'binder transaction' OR $name = 'binder reply')
      THEN 'binder'
    WHEN $state = 'S' AND ($name = 'Contending for pthread mutex') THEN 'mutex_contention'
    WHEN $state != 'S' AND $io_wait = 1 THEN 'io'
    ELSE $state
    END name;

-- Server side binder breakdowns per transactions per txn.
CREATE PERFETTO TABLE android_binder_server_breakdown(
  -- Client side id of the binder txn.
  binder_txn_id JOINID(slice.id),
  -- Server side id of the binder txn.
  binder_reply_id JOINID(slice.id),
  -- Timestamp of an exclusive interval during the binder reply with a single reason.
  ts TIMESTAMP,
  -- Duration of an exclusive interval during the binder reply with a single reason.
  dur DURATION,
  -- Cause of delay during an exclusive interval of the binder reply.
  reason STRING
)
AS
SELECT
  binder_txn_id,
  binder_reply_id,
  ts,
  dur,
  _binder_reason(name, state, io_wait, binder_txn_id, binder_reply_id, flat_id) AS reason
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _binder_server_flat_descendants_with_thread_state;

-- Client side binder breakdowns per transactions per txn.
CREATE PERFETTO TABLE android_binder_client_breakdown(
  -- Client side id of the binder txn.
  binder_txn_id JOINID(slice.id),
  -- Server side id of the binder txn.
  binder_reply_id JOINID(slice.id),
  -- Timestamp of an exclusive interval during the binder txn with a single latency reason.
  ts TIMESTAMP,
  -- Duration of an exclusive interval during the binder txn with a single latency reason.
  dur DURATION,
  -- Cause of delay during an exclusive interval of the binder txn.
  reason STRING
)
AS
SELECT
  binder_txn_id,
  binder_reply_id,
  ts,
  dur,
  _binder_reason(name, state, io_wait, binder_txn_id, binder_reply_id, flat_id) AS reason
FROM _binder_client_flat_descendants_with_thread_state;

)_d3l1m1t3r_"
;

const char kAndroidBroadcasts[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.freezer;

CREATE PERFETTO FUNCTION _extract_broadcast_process_name(name STRING)
RETURNS LONG
AS
WITH
  pid_and_name AS (
    SELECT STR_SPLIT(STR_SPLIT($name, '/', 0), ' ', 1) AS value
  ),
  start AS (
    SELECT cast_int!(INSTR(value, ':')) + 1 AS value FROM pid_and_name
  )
SELECT SUBSTR(pid_and_name.value, start.value) FROM pid_and_name, start;

-- Provides a list of broadcast names and processes they were sent to by the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- system_server process on U+ devices.
CREATE PERFETTO TABLE _android_broadcasts_minsdk_u(
  -- Broadcast record id.
  record_id STRING,
  -- Intent action of the broadcast.
  intent_action STRING,
  -- Name of the process the broadcast was sent to.
  process_name STRING,
  -- Pid of the process the broadcast was sent to.
  pid LONG,
  -- Upid of the process the broadcast was sent to.
  upid JOINID(process.id),
  -- Id of the broacast process queue the broadcast was dispatched from.
  process_queue_id STRING,
  -- Id of the broacast queue the broadcast was dispatched from.
  queue_id LONG,
  -- Broadcast dispatch slice.
  id JOINID(slice.id),
  -- Timestamp the broadcast was dispatched.
  ts TIMESTAMP,
  -- Duration to dispatch the broadcast.
  dur DURATION,
  -- Track id the broadcast was dispatched from.
  track_id JOINID(track.id)
) AS
WITH
  broadcast_queues AS (
    SELECT
      process_track.id,
      cast_int!(replace(str_split(process_track.name, '[', 1), ']', '')) AS queue_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM process_track
    JOIN process
      USING (upid)
    WHERE
      process_track.name GLOB 'BroadcastQueue.mRunning*'
      AND process.name = 'system_server'
  ),
  broadcast_process_running AS (
    SELECT
      slice.id AS id,
      slice.ts,
      slice.dur,
      str_split(slice.name, ' ', 0) AS process_queue_id,
      broadcast_queues.queue_id,
      _extract_broadcast_process_name(slice.name) AS process_name,
      cast_int!(str_split(str_split(str_split(slice.name, '/', 0), ' ', 1), ':', 0)) AS pid,
      queue_id
    FROM slice
    JOIN broadcast_queues
      ON broadcast_queues.id = slice.track_id
    WHERE slice.name GLOB '* running'
  ),
  broadcast_intent_action AS (
    SELECT
      str_split(str_split(slice.name, '/', 0), ' ', 1) AS intent_action,
      str_split(slice.name, ' ', 0) AS record_id,
      slice.parent_id,
      slice.id AS intent_id,
      slice.ts AS intent_ts,
      slice.track_id AS track_id,
      slice.dur AS intent_dur
    FROM slice
    WHERE slice.name GLOB '* scheduled'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  )
  SELECT
    broadcast_intent_action.record_id,
    broadcast_intent_action.intent_action,
    broadcast_process_running.process_name,
    broadcast_process_running.pid,
    _pid_to_upid(broadcast_process_running.pid, broadcast_intent_action.intent_ts) AS upid,
    broadcast_process_running.process_queue_id,
    broadcast_process_running.queue_id,
    broadcast_intent_action.intent_id AS id,
    broadcast_intent_action.intent_ts AS ts,
    broadcast_intent_action.intent_dur AS dur,
    broadcast_intent_action.track_id
  FROM broadcast_intent_action
  JOIN broadcast_process_running
    ON parent_id = id;

)_d3l1m1t3r_"
;

const char kAndroidCriticalBlockingCalls[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
INCLUDE PERFETTO MODULE android.slices;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO FUNCTION _is_relevant_blocking_call(name STRING, depth LONG)
RETURNS BOOL AS SELECT
  $name = 'measure'
  OR $name = 'layout'
  OR $name = 'configChanged'
  OR $name = 'animation'
  OR $name = 'input'
  OR $name = 'traversal'
  OR $name = 'Contending for pthread mutex'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  OR $name = 'postAndWait'
  OR $name GLOB 'monitor contention with*'
  OR $name GLOB 'SuspendThreadByThreadId*'
  OR $name GLOB 'LoadApkAssetsFd*'
  OR $name GLOB '*binder transaction*'
  OR $name GLOB 'inflate*'
  OR $name GLOB 'Lock contention on*'
  OR $name GLOB 'android.os.Handler: kotlinx.coroutines*'
  OR $name GLOB 'relayoutWindow*'
  OR $name GLOB 'ImageDecoder#decode*'
  OR $name GLOB 'NotificationStackScrollLayout#onMeasure'
  OR $name GLOB 'ExpNotRow#*'
  OR $name GLOB 'GC: Wait For*'
  OR $name GLOB 'Recomposer:*'
  OR $name GLOB 'Compose:*'
  OR (
    -- Some top level handler slices
    $depth = 0
    AND $name NOT GLOB '*Choreographer*'
    AND $name NOT GLOB '*Input*'
    AND $name NOT GLOB '*input*'
    AND $name NOT GLOB 'android.os.Handler: #*'
    AND (
      -- Handler pattern heuristics
      $name GLOB '*Handler: *$*'
      OR $name GLOB '*.*.*: *$*'
      OR $name GLOB '*.*$*: #*'
    )
  );


--Extract critical blocking calls from all processes.
CREATE PERFETTO TABLE _android_critical_blocking_calls AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  android_standardize_slice_name(s.name) AS name,
  s.ts,
  s.dur,
  s.id,
  s.process_name,
  thread.utid,
  s.upid
FROM thread_slice s JOIN
thread USING (utid)
WHERE
  _is_relevant_blocking_call(s.name, s.depth)
UNION ALL
-- As binder names are not included in slice table, extract these directly from the
-- android_binder_txns table.
SELECT
  tx.aidl_name AS name,
  tx.client_ts AS ts,
  tx.client_dur AS dur,
  tx.binder_txn_id AS id,
  tx.client_process as process_name,
  tx.client_utid as utid,
  tx.client_upid as upid
FROM android_binder_txns AS tx
WHERE aidl_name IS NOT NULL AND is_sync = 1;

)_d3l1m1t3r_"
;

const char kAndroidDesktopMode[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

include perfetto module android.statsd;

-- Desktop Windows with durations they were open.
CREATE PERFETTO TABLE android_desktop_mode_windows (
  -- Window add timestamp; NULL if no add event in the trace.
  raw_add_ts TIMESTAMP,
  -- Window remove timestamp; NULL if no remove event in the trace.
  raw_remove_ts TIMESTAMP,
  -- Timestamp that the window was added; or trace_start() if no add event in the trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Furation the window was open; or until trace_end() if no remove event in the trace.
  dur DURATION,
  -- Desktop Window instance ID - unique per window.
  instance_id LONG,
  -- UID of the app running in the window.
  uid LONG
) AS
WITH
  atoms AS (
    SELECT
      ts,
      extract_arg(arg_set_id, 'desktop_mode_session_task_update.task_event') AS type,
      extract_arg(arg_set_id, 'desktop_mode_session_task_update.instance_id') AS instance_id,
      extract_arg(arg_set_id, 'desktop_mode_session_task_update.uid') AS uid,
      extract_arg(arg_set_id, 'desktop_mode_session_task_update.session_id') AS session_id
    FROM android_statsd_atoms
    WHERE name = 'desktop_mode_session_task_update'),
  dw_statsd_events_add AS (
    SELECT *
    FROM atoms
    WHERE type = 'TASK_ADDED'),
  dw_statsd_events_remove AS (
    SELECT * FROM atoms
    WHERE type = 'TASK_REMOVED'),
  dw_statsd_events_update_by_instance AS (
    SELECT instance_id, session_id, min(uid) AS uid FROM atoms
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE type = 'TASK_INFO_CHANGED' GROUP BY instance_id, session_id),
  dw_statsd_reset_event AS (
    SELECT ts FROM atoms
    WHERE type = 'TASK_INIT_STATSD'
    UNION
    SELECT trace_end()),
  dw_windows AS (
    SELECT
      a.ts AS raw_add_ts,
      r.ts AS raw_remove_ts,
      ifnull(a.ts, trace_start()) AS ts,  -- Assume trace_start() if no add event found.
      ifnull(r.ts,
        (
          SELECT MIN(ts) FROM dw_statsd_reset_event
          WHERE ts > ifnull(a.ts, trace_start())
        )) - ifnull(a.ts, trace_start()) AS dur,  -- Assume next reset event or trace_end() if no remove event found.
      ifnull(a.instance_id, r.instance_id) AS instance_id,
      ifnull(a.uid, r.uid) AS uid
    FROM dw_statsd_events_add a
    FULL JOIN dw_statsd_events_remove r USING(instance_id, session_id)),
  -- Assume window was open for the entire trace if we only see change events for the instance ID.
  dw_windows_with_update_events AS (
    SELECT * FROM dw_windows
    UNION
    SELECT NULL, NULL, trace_start(), trace_end() - trace_start(), instance_id, uid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    FROM dw_statsd_events_update_by_instance
    WHERE
    instance_id NOT IN (SELECT instance_id FROM dw_windows))
SELECT * FROM dw_windows_with_update_events;


)_d3l1m1t3r_"
;

const char kAndroidDevice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Extract name of the device based on metadata from the trace.
CREATE PERFETTO TABLE android_device_name(
  -- Device name.
  name STRING
)
AS
WITH
  -- Example str_value:
  -- Android/aosp_raven/raven:VanillaIceCream/UDC/11197703:userdebug/test-keys
  -- Gets substring after first slash;
  after_first_slash(str) AS (
    SELECT SUBSTR(str_value, INSTR(str_value, '/') + 1)
    FROM metadata
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE name = 'android_build_fingerprint'
  ),
  -- Gets substring after second slash
  after_second_slash(str) AS (
    SELECT SUBSTR(str, INSTR(str, '/') + 1)
    FROM after_first_slash
  ),
  -- Gets substring after second slash and before the colon
  before_colon(str) AS (
    SELECT SUBSTR(str, 0, INSTR(str, ':'))
    FROM after_second_slash
  )
SELECT str AS name FROM before_colon;


)_d3l1m1t3r_"
;

const char kAndroidDvfs[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Dvfs counter with duration.
CREATE PERFETTO VIEW android_dvfs_counters(
  -- Counter name.
  name STRING,
  -- Timestamp when counter value changed.
  ts TIMESTAMP,
  -- Counter value.
  value DOUBLE,
  -- Counter duration.
  dur DURATION
) AS
SELECT
  counter_track.name,
  counter.ts,
  counter.value,
  LEAD(counter.ts, 1, trace_end()) OVER (PARTITION BY counter_track.id ORDER BY counter.ts) - counter.ts AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM counter
JOIN counter_track
  ON counter.track_id = counter_track.id
WHERE
  counter_track.name IN (
    'domain@0 Frequency',
    'domain@1 Frequency',
    'domain@2 Frequency',
    '17000010.devfreq_mif Frequency',
    '17000020.devfreq_int Frequency',
    '17000090.devfreq_dsu Frequency',
    '170000a0.devfreq_bci Frequency',
    'dsu_throughput Frequency',
    'bus_throughput Frequency',
    'cpu0dsu Frequency',
    'cpu1dsu Frequency',
    'cpu2dsu Frequency',
    'cpu3dsu Frequency',
    'cpu4dsu Frequency',
    'cpu5dsu Frequency',
    'cpu6dsu Frequency',
    'cpu7dsu Frequency',
    'cpu8dsu Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu0_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu1_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu2_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu3_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu4_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu5_memlat@17000010 Frequency',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'gs_memlat_devfreq:devfreq_mif_cpu6_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu7_memlat@17000010 Frequency',
    'gs_memlat_devfreq:devfreq_mif_cpu8_memlat@17000010 Frequency')
ORDER BY ts;

-- Aggregates dvfs counter slice for statistic.
CREATE PERFETTO TABLE android_dvfs_counter_stats(
  -- Counter name on which all the other values are aggregated on.
  name STRING,
  -- Max of all counter values for the counter name.
  max DOUBLE,
  -- Min of all counter values for the counter name.
  min DOUBLE,
  -- Duration between the first and last counter value for the counter name.
  dur DURATION,
  -- Weighted avergate of all the counter values for the counter name.
  wgt_avg DOUBLE
) AS
SELECT
  name,
  MAX(value) AS max,
  MIN(value) AS min,
  (MAX(ts) - MIN(ts)) AS dur,
  (SUM(dur * value) / SUM(dur)) AS wgt_avg
FROM android_dvfs_counters
WHERE android_dvfs_counters.dur > 0
GROUP BY name;


-- Aggregates dvfs counter slice for residency
CREATE PERFETTO VIEW android_dvfs_counter_residency(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Counter name.
  name STRING,
  -- Counter value.
  value DOUBLE,
  -- Counter duration.
  dur DURATION,
  -- Counter duration as a percentage of total duration.
  pct DOUBLE
) AS
WITH
total AS (
  SELECT
    name,
    SUM(dur) AS dur
  FROM android_dvfs_counters
  WHERE dur > 0
  GROUP BY name
)
SELECT
  android_dvfs_counters.name,
  android_dvfs_counters.value,
  SUM(android_dvfs_counters.dur) AS dur,
  (SUM(android_dvfs_counters.dur) * 100.0 / total.dur) AS pct
FROM android_dvfs_counters
JOIN total
  USING (name)
WHERE android_dvfs_counters.dur > 0
GROUP BY 1, 2;

)_d3l1m1t3r_"
;

const char kAndroidFreezer[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

CREATE PERFETTO FUNCTION _extract_freezer_pid(name STRING)
RETURNS LONG
AS
SELECT cast_int!(reverse(str_split(reverse(str_split($name, ' ', 1)), ':', 0)));

-- Converts a pid to a upid using the timestamp of occurence of an event from
-- |pid| to disambiguate duplicate pids.
--
-- This is still best effort because it relies on having information about
-- process start and end in the trace. In the edge case that we are missing this,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- it best effort returns the last upid.
CREATE PERFETTO FUNCTION _pid_to_upid(
  -- Pid to convert from.
  pid LONG,
  -- Timestamp of an event from the |pid|.
  event_ts TIMESTAMP)
-- Returns the converted upid.
RETURNS LONG
AS
WITH
  process_lifetime AS (
    SELECT
      pid,
      upid,
      COALESCE(start_ts, trace_start()) AS start_ts,
      COALESCE(end_ts, trace_end()) AS end_ts
    FROM process
  )
SELECT upid
FROM process_lifetime
WHERE pid = $pid AND $event_ts BETWEEN start_ts AND end_ts
ORDER BY upid DESC
LIMIT 1;

-- Translate unfreeze reason from INT to STRING.
-- See: frameworks/proto_logging/stats/atoms.proto
CREATE PERFETTO FUNCTION _translate_unfreeze_reason(reason LONG)
RETURNS STRING
AS
SELECT
  CASE
    WHEN $reason = 0 THEN 'none'
    WHEN $reason = 1 THEN 'activity'
    WHEN $reason = 2 THEN 'finish_receiver'
    WHEN $reason = 3 THEN 'start_receiver'
    WHEN $reason = 4 THEN 'bind_service'
    WHEN $reason = 5 THEN 'unbind_service'
    WHEN $reason = 6 THEN 'start_service'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $reason = 7 THEN 'get_provider'
    WHEN $reason = 8 THEN 'remove_provider'
    WHEN $reason = 9 THEN 'ui_visibility'
    WHEN $reason = 10 THEN 'allowlist'
    WHEN $reason = 11 THEN 'process_begin'
    WHEN $reason = 12 THEN 'process_end'
    WHEN $reason = 13 THEN 'trim_memory'
    WHEN $reason = 15 THEN 'ping'
    WHEN $reason = 16 THEN 'file_locks'
    WHEN $reason = 17 THEN 'file_lock_check_failure'
    WHEN $reason = 18 THEN 'binder_txns'
    WHEN $reason = 19 THEN 'feature_flags'
    WHEN $reason = 20 THEN 'short_fgs_timeout'
    WHEN $reason = 21 THEN 'system_init'
    WHEN $reason = 22 THEN 'backup'
    WHEN $reason = 23 THEN 'shell'
    WHEN $reason = 24 THEN 'remove_task'
    WHEN $reason = 25 THEN 'uid_idle'
    WHEN $reason = 26 THEN 'stop_service'
    WHEN $reason = 27 THEN 'executing_service'
    WHEN $reason = 28 THEN 'restriction_change'
    WHEN $reason = 29 THEN 'component_disabled'
    ELSE NULL
  END;

-- All frozen processes and their frozen duration.
CREATE PERFETTO TABLE android_freezer_events (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Upid of frozen process
  upid JOINID(process.id),
  -- Pid of frozen process
  pid LONG,
  -- Timestamp process was frozen.
  ts TIMESTAMP,
  -- Duration process was frozen for.
  dur DURATION,
  -- Unfreeze reason Integer.
  unfreeze_reason_int LONG,
  -- Unfreeze reason String.
  unfreeze_reason_str STRING
  )
AS
WITH
  freeze AS (
    SELECT ts, _extract_freezer_pid(name) AS pid,
    _pid_to_upid(_extract_freezer_pid(name), ts) AS upid, 'freeze' AS type,
    NULL AS unfreeze_reason
    FROM slice
    WHERE name GLOB 'Freeze *:*'
  ),
  unfreeze AS (
    SELECT ts, _extract_freezer_pid(name) AS pid,
    _pid_to_upid(_extract_freezer_pid(name), ts) AS upid, 'unfreeze' AS type,
    str_split(name, ' ', 2) AS unfreeze_reason
    FROM slice
    WHERE name GLOB 'Unfreeze *:*'
  ),
  merged AS (
    SELECT * FROM freeze
    UNION ALL
    SELECT * FROM unfreeze
  ),
  starts AS (
    SELECT
      type,
      upid,
      pid,
      ts,
      ifnull(lead(ts) OVER (PARTITION BY upid ORDER BY ts), trace_end()) - ts AS dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      cast_int!(lead(unfreeze_reason) OVER (PARTITION BY upid ORDER BY ts)) AS unfreeze_reason
    FROM merged
  )
SELECT
  upid,
  pid,
  ts,
  dur,
  unfreeze_reason AS unfreeze_reason_int,
  _translate_unfreeze_reason(unfreeze_reason) AS unfreeze_reason_str
FROM starts
WHERE starts.type = 'freeze' AND upid IS NOT NULL;

)_d3l1m1t3r_"
;

const char kAndroidGarbageCollection[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;

-- Collect all GC slices. There's typically one enclosing slice but sometimes the
-- CompactionPhase is outside the nesting and we need to include that.
CREATE PERFETTO VIEW _gc_slice
AS
WITH concurrent AS (
SELECT
  id AS gc_id,
  name AS gc_name,
  LEAD(name) OVER (PARTITION BY track_id ORDER BY ts) AS compact_name,
  LEAD(dur) OVER (PARTITION BY track_id ORDER BY ts) AS compact_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts AS gc_ts,
  IIF(dur = -1, trace_end() - slice.ts, slice.dur) AS gc_dur,
  ts,
  dur,
  tid,
  utid,
  pid,
  upid,
  thread_name,
  process_name
FROM thread_slice slice
WHERE depth = 0
) SELECT
  gc_id,
  gc_name,
  ts AS gc_ts,
  ts,
  gc_dur + IIF(
    compact_name = 'CompactionPhase' OR compact_name = 'Background concurrent copying GC',
    compact_dur,
    0) AS gc_dur,
  gc_dur + IIF(
    compact_name = 'CompactionPhase' OR compact_name = 'Background concurrent copying GC',
    compact_dur,
    0) AS dur,
  utid,
  tid,
  upid,
  pid,
  thread_name,
  process_name
FROM concurrent WHERE gc_name GLOB '*concurrent*GC';

-- Extract the heap counter into <ts, dur, upid>
CREATE PERFETTO VIEW _gc_heap_counter
AS
SELECT
  c.ts,
  IFNULL(lead(c.ts) OVER (PARTITION BY track_id ORDER BY c.ts), trace_end()) - ts
    AS dur,
  process.upid,
  cast_int!(c.value ) AS value
FROM counter c
JOIN process_counter_track t
  ON c.track_id = t.id
INNER JOIN process
  USING (upid)
WHERE
  t.name = 'Heap size (KB)';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Find the last heap counter after the GC slice dur. This is the best effort to find the
-- final heap size after GC. The algorithm is like so:
-- 1. Merge end_ts of the GC events with the start_ts of the heap counters.
-- 2. Find the heap counter value right after each GC event.
CREATE PERFETTO VIEW _gc_slice_with_final_heap
AS
WITH
  slice_and_heap AS (
    SELECT upid, gc_id, gc_ts + gc_dur AS ts, NULL AS value FROM _gc_slice
    UNION ALL
    SELECT upid, NULL AS gc_id, ts, value FROM _gc_heap_counter
  ),
  next_heap AS (
    SELECT *, lead(value) OVER (PARTITION BY upid ORDER BY ts) AS last_value FROM slice_and_heap
  ),
  slice_with_last_heap AS (
    SELECT * FROM next_heap WHERE gc_id IS NOT NULL
  )
  SELECT _gc_slice.*, last_value FROM _gc_slice LEFT JOIN slice_with_last_heap USING (gc_id);

-- Span join with all the other heap counters to find the overall min and max heap size.
CREATE VIRTUAL TABLE _gc_slice_heap_sp
USING
  SPAN_JOIN(_gc_slice_with_final_heap PARTITIONED upid, _gc_heap_counter PARTITIONED upid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Aggregate the min and max heap across the GC event, taking into account the last heap size
-- derived earlier.
CREATE PERFETTO TABLE _gc_slice_heap
AS
SELECT
  gc_ts as ts,
  gc_dur as dur,
  upid, gc_id, gc_name, gc_ts, gc_dur, utid, tid, pid,
  thread_name, process_name, last_value, value,
  CASE
    WHEN gc_name GLOB '*young*' THEN 'young'
    WHEN gc_name GLOB '*NativeAlloc*' THEN 'native_alloc'
    WHEN gc_name GLOB '*Alloc*' THEN 'alloc'
    WHEN gc_name GLOB '*CollectorTransition*' THEN 'collector_transition'
    WHEN gc_name GLOB '*Explicit*' THEN 'explicit'
    ELSE 'full'
    END AS gc_type,
  IIF(gc_name GLOB '*mark compact*', 1, 0) AS is_mark_compact,
  MAX(MAX(value, last_value))/1e3 AS max_heap_mb,
  MIN(MIN(value, last_value))/1e3 AS min_heap_mb
FROM _gc_slice_heap_sp
GROUP BY gc_id;

-- Span join GC events with thread states to breakdown the time spent.
CREATE VIRTUAL TABLE _gc_slice_heap_thread_state_sp
USING
  SPAN_LEFT_JOIN(_gc_slice_heap PARTITIONED utid, thread_state PARTITIONED utid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- All Garbage collection events with a breakdown of the time spent and heap reclaimed.
CREATE PERFETTO TABLE android_garbage_collection_events (
  -- Tid of thread running garbage collection.
  tid LONG,
  -- Pid of process running garbage collection.
  pid LONG,
  -- Utid of thread running garbage collection.
  utid JOINID(thread.id),
  -- Upid of process running garbage collection.
  upid JOINID(process.id),
  -- Name of thread running garbage collection.
  thread_name STRING,
  -- Name of process running garbage collection.
  process_name STRING,
  -- Type of garbage collection.
  gc_type STRING,
  -- Whether gargage collection is mark compact or copying.
  is_mark_compact LONG,
  -- MB reclaimed after garbage collection.
  reclaimed_mb DOUBLE,
  -- Minimum heap size in MB during garbage collection.
  min_heap_mb DOUBLE,
  -- Maximum heap size in MB during garbage collection.
  max_heap_mb DOUBLE,
  -- Garbage collection id.
  gc_id LONG,
  -- Garbage collection timestamp.
  gc_ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Garbage collection wall duration.
  gc_dur DURATION,
  -- Garbage collection duration spent executing on CPU.
  gc_running_dur DURATION,
  -- Garbage collection duration spent waiting for CPU.
  gc_runnable_dur DURATION,
  -- Garbage collection duration spent waiting in the Linux kernel on IO.
  gc_unint_io_dur DURATION,
  -- Garbage collection duration spent waiting in the Linux kernel without IO.
  gc_unint_non_io_dur DURATION,
    -- Garbage collection duration spent waiting in interruptible sleep.
  gc_int_dur LONG
  )
AS
WITH
  agg_events AS (
    SELECT
      tid,
      pid,
      utid,
      upid,
      thread_name,
      process_name,
      gc_type,
      is_mark_compact,
      gc_id,
      gc_ts,
      gc_dur,
      SUM(dur) AS dur,
      max_heap_mb - min_heap_mb AS reclaimed_mb,
      min_heap_mb,
      max_heap_mb,
      state,
      io_wait
    FROM _gc_slice_heap_thread_state_sp
    GROUP BY gc_id, state, io_wait
  )
SELECT
  tid,
  pid,
  utid,
  upid,
  thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process_name,
  gc_type,
  is_mark_compact,
  reclaimed_mb,
  min_heap_mb,
  max_heap_mb,
  gc_id,
  gc_ts,
  gc_dur,
  SUM(IIF(state = 'Running', dur, 0)) AS gc_running_dur,
  SUM(IIF(state = 'R' OR state = 'R+', dur, 0)) AS gc_runnable_dur,
  SUM(IIF(state = 'D' AND io_wait = 1, dur, 0)) AS gc_unint_io_dur,
  SUM(IIF(state = 'D' AND io_wait != 1, dur, 0)) AS gc_unint_non_io_dur,
  SUM(IIF(state = 'S', dur, 0)) AS gc_int_dur
FROM agg_events
GROUP BY gc_id;

)_d3l1m1t3r_"
;

const char kAndroidInput[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.frames.timeline;
INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO TABLE _input_message_sent
AS
SELECT
  STR_SPLIT(STR_SPLIT(slice.name, '=', 3), ')', 0) AS event_type,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 2), ',', 0) AS event_seq,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 1), ',', 0) AS event_channel,
  thread.tid,
  thread.name AS thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  process.pid,
  process.name AS process_name,
  slice.ts,
  slice.dur,
  slice.track_id
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name GLOB 'sendMessage(*'
order by event_seq;

CREATE PERFETTO TABLE _input_message_received
AS
SELECT
  STR_SPLIT(STR_SPLIT(slice.name, '=', 3), ')', 0) AS event_type,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 2), ',', 0) AS event_seq,
  STR_SPLIT(STR_SPLIT(slice.name, '=', 1), ',', 0) AS event_channel,
  thread.tid,
  thread.name AS thread_name,
  process.pid,
  process.name AS process_name,
  slice.ts,
  slice.dur,
  slice.track_id
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
WHERE slice.name GLOB 'receiveMessage(*'
ORDER BY event_seq;

CREATE PERFETTO TABLE _input_read_time
AS
SELECT
  name,
  STR_SPLIT(STR_SPLIT(name, '=', 1), ')', 0) AS input_event_id,
  ts as read_time
FROM slice
WHERE name GLOB 'UnwantedInteractionBlocker::notifyMotion*';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _event_seq_to_input_event_id
AS
SELECT
  STR_SPLIT(STR_SPLIT(send_message_slice.name, '=', 2), ',', 0) AS event_seq,
  STR_SPLIT(STR_SPLIT(send_message_slice.name, '=', 1), ',', 0) AS event_channel,
  STR_SPLIT(STR_SPLIT(enqeue_slice.name, '=', 2), ')', 0) AS input_event_id,
  thread_slice.thread_name
FROM slice send_message_slice
JOIN slice publish_slice
  ON send_message_slice.parent_id = publish_slice.id
JOIN slice start_dispatch_slice
  ON publish_slice.parent_id = start_dispatch_slice.id
JOIN slice enqeue_slice
  ON start_dispatch_slice.parent_id = enqeue_slice.id
JOIN thread_slice
  ON send_message_slice.id = thread_slice.id
WHERE send_message_slice.name GLOB 'sendMessage(*' AND thread_slice.thread_name = 'InputDispatcher';

CREATE PERFETTO TABLE _input_event_id_to_android_frame
AS
SELECT
  STR_SPLIT(deliver_input_slice.name, '=', 3) AS input_event_id,
  STR_SPLIT(STR_SPLIT(dispatch_input_slice.name, '_', 1), ' ', 0) AS event_action,
  dispatch_input_slice.ts AS consume_time,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dispatch_input_slice.ts + dispatch_input_slice.dur AS finish_time,
  thread_slice.utid,
  thread_slice.process_name AS process_name,
  (
    SELECT
      android_frames.frame_id
    FROM android_frames
    WHERE android_frames.ts > dispatch_input_slice.ts
    LIMIT 1
  ) as frame_id,
  (
    SELECT
      android_frames.ts
    FROM android_frames
    WHERE android_frames.ts > dispatch_input_slice.ts
    LIMIT 1
  ) as ts,
  (
    SELECT
      _input_message_received.event_channel
    FROM _input_message_received
    WHERE _input_message_received.ts < deliver_input_slice.ts
      AND _input_message_received.track_id = deliver_input_slice.track_id
    ORDER BY _input_message_received.ts DESC
    LIMIT 1
  ) as event_channel
FROM slice deliver_input_slice
JOIN slice dispatch_input_slice
  ON deliver_input_slice.parent_id = dispatch_input_slice.id
JOIN thread_slice
  ON deliver_input_slice.id = thread_slice.id
WHERE deliver_input_slice.name GLOB 'deliverInputEvent src=*';

CREATE PERFETTO TABLE _app_frame_to_surface_flinger_frame
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
SELECT
  app.surface_frame_token as app_surface_frame_token,
  surface_flinger.ts as surface_flinger_ts,
  surface_flinger.dur as surface_flinger_dur,
  app.ts as app_ts,
  app.present_type,
  app.upid
FROM actual_frame_timeline_slice surface_flinger
JOIN actual_frame_timeline_slice app
  ON surface_flinger.display_frame_token = app.display_frame_token
  AND surface_flinger.id != app.id
WHERE surface_flinger.surface_frame_token = 0 AND app.present_type != 'Dropped Frame';

CREATE PERFETTO TABLE _first_non_dropped_frame_after_input
AS
SELECT
  _input_read_time.input_event_id,
  _input_read_time.read_time,
  (
    SELECT
      surface_flinger_ts + surface_flinger_dur
    FROM _app_frame_to_surface_flinger_frame sf_frames
    WHERE sf_frames.app_ts >= _input_event_id_to_android_frame.ts
    LIMIT 1
  ) AS present_time,
  (
    SELECT
      app_surface_frame_token
    FROM _app_frame_to_surface_flinger_frame sf_frames
    WHERE sf_frames.app_ts >= _input_event_id_to_android_frame.ts
    LIMIT 1
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ) as frame_id,
  event_seq,
  event_action
FROM _input_event_id_to_android_frame
RIGHT JOIN _event_seq_to_input_event_id
  ON _input_event_id_to_android_frame.input_event_id = _event_seq_to_input_event_id.input_event_id
  AND _input_event_id_to_android_frame.event_channel = _event_seq_to_input_event_id.event_channel
JOIN _input_read_time
  ON _input_read_time.input_event_id = _event_seq_to_input_event_id.input_event_id;

-- All input events with round trip latency breakdown. Input delivery is socket based and every
-- input event sent from the OS needs to be ACK'ed by the app. This gives us 4 subevents to measure
-- latencies between:
-- 1. Input dispatch event sent from OS.
-- 2. Input dispatch event received in app.
-- 3. Input ACK event sent from app.
-- 4. Input ACk event received in OS.
CREATE PERFETTO TABLE android_input_events (
  -- Duration from input dispatch to input received.
  dispatch_latency_dur DURATION,
  -- Duration from input received to input ACK sent.
  handling_latency_dur DURATION,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Duration from input ACK sent to input ACK recieved.
  ack_latency_dur DURATION,
  -- Duration from input dispatch to input event ACK received.
  total_latency_dur DURATION,
  -- Duration from input read to frame present time. Null if an input event has no associated frame event.
  end_to_end_latency_dur DURATION,
  -- Tid of thread receiving the input event.
  tid LONG,
  -- Name of thread receiving the input event.
  thread_name STRING,
  -- Pid of process receiving the input event.
  pid LONG,
  -- Name of process receiving the input event.
  process_name STRING,
  -- Input event type. See InputTransport.h: InputMessage#Type
  event_type STRING,
  -- Input event action.
  event_action STRING,
  -- Input event sequence number, monotonically increasing for an event channel and pid.
  event_seq STRING,
  -- Input event channel name.
  event_channel STRING,
  -- Unique identifier for the input event.
  input_event_id STRING,
  -- Timestamp input event was read by InputReader.
  read_time LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Thread track id of input event dispatching thread.
  dispatch_track_id JOINID(track.id),
  -- Timestamp input event was dispatched.
  dispatch_ts TIMESTAMP,
  -- Duration of input event dispatch.
  dispatch_dur DURATION,
  -- Thread track id of input event receiving thread.
  receive_track_id JOINID(track.id),
  -- Timestamp input event was received.
  receive_ts TIMESTAMP,
  -- Duration of input event receipt.
  receive_dur DURATION,
  -- Vsync Id associated with the input. Null if an input event has no associated frame event.
  frame_id LONG
  )
AS
WITH dispatch AS MATERIALIZED (
  SELECT * FROM _input_message_sent
  WHERE thread_name = 'InputDispatcher'
  ORDER BY event_seq, event_channel
),
receive AS MATERIALIZED (
  SELECT
    *,
    REPLACE(event_channel, '(client)', '(server)') AS dispatch_event_channel
  FROM _input_message_received
  WHERE event_type NOT IN ('0x2', 'FINISHED')
  ORDER BY event_seq, dispatch_event_channel
),
finish AS MATERIALIZED (
  SELECT
    *,
    REPLACE(event_channel, '(client)', '(server)') AS dispatch_event_channel
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM _input_message_sent
  WHERE thread_name != 'InputDispatcher'
  ORDER BY event_seq, dispatch_event_channel
),
finish_ack AS MATERIALIZED(
  SELECT * FROM _input_message_received
  WHERE event_type IN ('0x2', 'FINISHED')
  ORDER BY event_seq, event_channel
)
SELECT
  receive.ts - dispatch.ts AS dispatch_latency_dur,
  finish.ts - receive.ts AS handling_latency_dur,
  finish_ack.ts - finish.ts AS ack_latency_dur,
  finish_ack.ts - dispatch.ts AS total_latency_dur,
  frame.present_time - frame.read_time AS end_to_end_latency_dur,
  finish.tid AS tid,
  finish.thread_name AS thread_name,
  finish.pid AS pid,
  finish.process_name AS process_name,
  dispatch.event_type,
  frame.event_action,
  dispatch.event_seq,
  dispatch.event_channel,
  frame.input_event_id,
  frame.read_time,
  dispatch.track_id AS dispatch_track_id,
  dispatch.ts AS dispatch_ts,
  dispatch.dur AS dispatch_dur,
  receive.ts AS receive_ts,
  receive.dur AS receive_dur,
  receive.track_id AS receive_track_id,
  frame.frame_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM dispatch
JOIN receive
  ON
    receive.dispatch_event_channel = dispatch.event_channel
    AND dispatch.event_seq = receive.event_seq
JOIN finish
  ON
    finish.dispatch_event_channel = dispatch.event_channel
    AND dispatch.event_seq = finish.event_seq
JOIN finish_ack
  ON
    finish_ack.event_channel = dispatch.event_channel
    AND dispatch.event_seq = finish_ack.event_seq
LEFT JOIN _first_non_dropped_frame_after_input frame
  ON frame.event_seq = dispatch.event_seq;

-- Key events processed by the Android framework (from android.input.inputevent data source).
CREATE PERFETTO VIEW android_key_events(
  -- ID of the trace entry
  id LONG,
  -- The randomly-generated ID associated with each input event processed
  -- by Android Framework, used to track the event through the input pipeline
  event_id LONG,
  -- The timestamp of when the input event was processed by the system
  ts TIMESTAMP,
  -- Details of the input event parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
) AS
SELECT
  id,
  event_id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_android_key_events;

-- Motion events processed by the Android framework (from android.input.inputevent data source).
CREATE PERFETTO VIEW android_motion_events(
  -- ID of the trace entry
  id LONG,
  -- The randomly-generated ID associated with each input event processed
  -- by Android Framework, used to track the event through the input pipeline
  event_id LONG,
  -- The timestamp of when the input event was processed by the system
  ts TIMESTAMP,
  -- Details of the input event parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG
) AS
SELECT
  id,
  event_id,
  ts,
  arg_set_id,
  base64_proto,
  base64_proto_id
FROM __intrinsic_android_motion_events;

-- Input event dispatching information in Android (from android.input.inputevent data source).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_input_event_dispatch(
  -- ID of the trace entry
  id LONG,
  -- Event ID of the input event that was dispatched
  event_id LONG,
  -- Details of the input event parsed from the proto message
  arg_set_id ARGSETID,
  -- Raw proto message encoded in base64
  base64_proto STRING,
  -- String id for raw proto message
  base64_proto_id LONG,
  -- Vsync ID that identifies the state of the windows during which the dispatch decision was made
  vsync_id LONG,
  -- Window ID of the window receiving the event
  window_id LONG
) AS
SELECT
  id,
  event_id,
  arg_set_id,
  base64_proto,
  base64_proto_id,
  vsync_id,
  window_id
FROM __intrinsic_android_input_event_dispatch;

)_d3l1m1t3r_"
;

const char kAndroidIo[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(b/329344794): Rewrite to fetch data from other tables than `raw`.

-- Aggregates f2fs IO and latency stats by counter name.
CREATE PERFETTO VIEW _android_io_f2fs_counter_stats(
  -- Counter name on which all the other values are aggregated on.
  name STRING,
  -- Sum of all counter values for the counter name.
  sum DOUBLE,
  -- Max of all counter values for the counter name.
  max DOUBLE,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Min of all counter values for the counter name.
  min DOUBLE,
  -- Duration between the first and last counter value for the counter name.
  dur DURATION,
  -- Count of all the counter values for the counter name.
  count LONG,
  -- Avergate of all the counter values for the counter name.
  avg DOUBLE
) AS
SELECT
  STR_SPLIT(counter_track.name, '].', 1) AS name,
  SUM(counter.value) AS sum,
  MAX(counter.value) AS max,
  MIN(counter.value) AS min,
  MAX(ts) - MIN(ts) AS dur,
  COUNT(ts) AS count,
  AVG(counter.value) AS avg
FROM counter
JOIN counter_track
  ON counter_track.id = counter.track_id AND counter_track.name GLOB '*f2fs*'
GROUP BY name
ORDER BY sum DESC;

-- Aggregates f2fs_write stats by inode and thread.
CREATE PERFETTO VIEW _android_io_f2fs_write_stats(
  -- Utid of the thread.
  utid JOINID(thread.id),
  -- Tid of the thread.
  tid LONG,
  -- Name of the thread.
  thread_name STRING,
  -- Upid of the process.
  upid JOINID(process.id),
  -- Pid of the process.
  pid LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Name of the thread.
  process_name STRING,
  -- Inode number of the file being written.
  ino LONG,
  -- Device node number of the file being written.
  dev LONG,
  -- Total number of bytes written on this file by the |utid|.
  bytes LONG,
  -- Total count of write requests for this file.
  write_count LONG
) AS
WITH
  f2fs_write_end AS (
    SELECT
      *,
      EXTRACT_ARG(arg_set_id, 'len') AS len,
      EXTRACT_ARG(arg_set_id, 'dev') AS dev,
      EXTRACT_ARG(arg_set_id, 'ino') AS ino,
      EXTRACT_ARG(arg_set_id, 'copied') AS copied
    FROM raw
    WHERE name GLOB 'f2fs_write_end*'
  )
SELECT
  thread.utid,
  thread.tid,
  thread.name AS thread_name,
  process.upid,
  process.pid,
  process.name AS process_name,
  f.ino,
  f.dev,
  SUM(copied) AS bytes,
  COUNT(len) AS write_count
FROM f2fs_write_end f
JOIN thread
  USING (utid)
JOIN process
  USING (upid)
GROUP BY utid, ino, dev
ORDER BY bytes DESC;

-- Aggregates f2fs write stats. Counts distinct datapoints, total write operations,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- and bytes written
CREATE PERFETTO VIEW _android_io_f2fs_aggregate_write_stats(
  -- Total number of writes in the trace.
  total_write_count LONG,
  -- Number of distinct processes.
  distinct_processes LONG,
  -- Total number of bytes written.
  total_bytes_written LONG,
  -- Count of distinct devices written to.
  distinct_device_count LONG,
  -- Count of distinct inodes written to.
  distinct_inode_count LONG,
  -- Count of distinct threads writing.
  distinct_thread_count LONG
) AS
select SUM(write_count) as total_write_count,
      COUNT(DISTINCT pid) distinct_processes,
      SUM(bytes) as total_bytes_written,
      COUNT(DISTINCT dev) as distinct_device_count,
      COUNT(DISTINCT ino) distinct_inode_count,
      COUNT(DISTINCT tid) distinct_thread_count
from _android_io_f2fs_write_stats;
)_d3l1m1t3r_"
;

const char kAndroidJobScheduler[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- All scheduled jobs and their latencies.
--
-- The table is populated by ATrace using the system server ATrace category
-- (`atrace_categories: "ss"`). You can also set the `atrace_apps` of interest.
--
-- This differs from the `android_job_scheduler_states` table
-- in the `android.job_scheduler_states` module which is populated
-- by the `ScheduledJobStateChanged` atom.
--
-- Using `android_job_scheduler_states` is preferred when the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- `ATOM_SCHEDULED_JOB_STATE_CHANGED` is available in the trace since
-- it includes the constraint, screen, or charging state changes for
-- each job in a trace.
CREATE PERFETTO TABLE android_job_scheduler_events (
  -- Id of the scheduled job assigned by the app developer.
  job_id LONG,
  -- Uid of the process running the scheduled job.
  uid LONG,
  -- Package name of the process running the scheduled job.
  package_name STRING,
  -- Service component name of the scheduled job.
  job_service_name STRING,
  -- Thread track id of the job scheduler event slice.
  track_id JOINID(track.id),
  -- Slice id of the job scheduler event slice.
  id LONG,
  -- Timestamp the job was scheduled.
  ts TIMESTAMP,
  -- Duration of the scheduled job.
  dur DURATION
  ) AS
SELECT
  cast_int!(STR_SPLIT(slice.name, '#', 1)) AS job_id,
  cast_int!(STR_SPLIT(STR_SPLIT(slice.name, '<', 1), '>', 0)) AS uid,
  STR_SPLIT(STR_SPLIT(slice.name, '>', 1), '/', 0) AS package_name,
  STR_SPLIT(STR_SPLIT(slice.name, '/', 1), '#', 0) AS job_service_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  track_id,
  slice.id,
  slice.ts,
  IIF(slice.dur = -1, trace_end() - slice.ts, slice.dur) AS dur
FROM
  slice
JOIN process_track
  ON slice.track_id = process_track.id
JOIN process
  ON process.upid = process_track.upid
WHERE
  process.name = 'system_server'
  AND slice.name GLOB '*job*'
  AND process_track.name = 'JobScheduler';

)_d3l1m1t3r_"
;

const char kAndroidJobSchedulerStates[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;
INCLUDE PERFETTO MODULE android.battery.charging_states;
INCLUDE PERFETTO MODULE intervals.intersect;

CREATE PERFETTO TABLE _screen_states AS
SELECT
  id,
  ts,
  dur,
  screen_state
FROM (
  WITH _screen_state_span AS (
  SELECT *
  FROM counter_leading_intervals!((
    SELECT counter.id, ts, 0 AS track_id, value
    FROM counter
    JOIN counter_track ON counter_track.id = counter.track_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHERE name = 'ScreenState'
  ))) SELECT
    id,
    ts,
    dur,
    CASE value
      WHEN 1 THEN 'Screen off'
      WHEN 2 THEN 'Screen on'
      WHEN 3 THEN 'Always-on display (doze)'
      ELSE 'Unknown'
      END AS screen_state
    FROM _screen_state_span
    WHERE dur > 0
    -- Either the above select statement is populated or the
    -- select statement after the union is populated but not both.
    UNION
     -- When the trace does not have a slice in the screen state track then
    -- we will assume that the screen state for the entire trace is Unknown.
    -- This ensures that we still have job data even if the screen state is
    -- not known. The following statement will only ever return a single row.
    SELECT 1, TRACE_START() as ts, TRACE_DUR() as dur, 'Unknown'
    WHERE NOT EXISTS (
      SELECT * FROM _screen_state_span
    ) AND TRACE_DUR() > 0
);

CREATE PERFETTO TABLE _job_states AS
SELECT
  t.id as track_id,
  s.ts,
  s.id AS slice_id,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.job_name') AS job_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  extract_arg(arg_set_id, 'scheduled_job_state_changed.attribution_node[0].uid') AS uid,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.state') AS state,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.internal_stop_reason')
    AS internal_stop_reason,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.public_stop_reason')
    AS public_stop_reason,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.effective_priority')
    AS effective_priority,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_battery_not_low_constraint')
    AS has_battery_not_low_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_charging_constraint')
    AS has_charging_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_connectivity_constraint')
    AS has_connectivity_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_content_trigger_constraint')
    AS has_content_trigger_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_deadline_constraint')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS has_deadline_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_idle_constraint')
    AS has_idle_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_storage_not_low_constraint')
    AS has_storage_not_low_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.has_timing_delay_constraint')
    AS has_timing_delay_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_prefetch') == 1
    AS is_prefetch,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_requested_expedited_job')
    AS is_requested_expedited_job,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_running_as_expedited_job')
    AS is_running_as_expedited_job,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.job_id') AS job_id,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.num_previous_attempts')
    AS num_previous_attempts,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.requested_priority')
    AS requested_priority,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  extract_arg(arg_set_id, 'scheduled_job_state_changed.standby_bucket')
    AS standby_bucket,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_periodic')
    AS is_periodic,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_periodic')
    AS has_flex_constraint,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_requested_as_user_initiated_job')
    AS is_requested_as_user_initiated_job,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.is_running_as_user_initiated_job')
    AS is_running_as_user_initiated_job,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.deadline_ms')
    AS deadline_ms,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.job_start_latency_ms')
    AS job_start_latency_ms,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.num_uncompleted_work_items')
    AS num_uncompleted_work_items,
  extract_arg(arg_set_id, 'scheduled_job_state_changed.proc_state')
    AS proc_state
FROM
  track t
JOIN slice s
  ON (s.track_id = t.id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE
  t.name = 'Statsd Atoms' AND s.name = 'scheduled_job_state_changed';

CREATE PERFETTO TABLE _job_started AS
WITH cte AS (
  SELECT
    *,
    LEAD(state, 1)
      OVER (PARTITION BY uid, job_name, job_id ORDER BY uid, job_name, job_id, ts) AS lead_state,
    LEAD(ts, 1, TRACE_END())
      OVER (PARTITION BY uid, job_name, job_id ORDER BY uid, job_name, job_id, ts) AS ts_lead,
    --- Filter out statsd lossy issue.
    LEAD(ts, 1)
      OVER (PARTITION BY uid, job_name, job_id ORDER BY uid, job_name, job_id, ts) IS NULL AS is_end_slice,
    LEAD(internal_stop_reason, 1, 'INTERNAL_STOP_REASON_UNKNOWN')
      OVER (
        PARTITION BY uid, job_name, job_id
        ORDER BY uid, job_name, job_id, ts
      ) AS lead_internal_stop_reason,
    LEAD(public_stop_reason, 1, 'PUBLIC_STOP_REASON_UNKNOWN')
      OVER (
        PARTITION BY uid, job_name, job_id
        ORDER BY uid, job_name, job_id, ts
      ) AS lead_public_stop_reason
  FROM _job_states
  WHERE state != 'CANCELLED'
)
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Job name is based on whether the tag and/or namespace are present:
  -- 1. Both tag and namespace are present: @<namespace>@<tag>:<package name>
  -- 2. Only tag is present:  <tag>:<package name>
  -- 3. Only namespace is present: @<namespace>@<package name>/<class name>
  CASE
    WHEN substr(job_name, 1, 1) = '@'
      THEN
        CASE
          WHEN substr(STR_SPLIT(job_name, '/', 1), 1, 3) = 'com' THEN STR_SPLIT(job_name, '/', 1)
          ELSE STR_SPLIT(STR_SPLIT(job_name, '/', 0), '@', 2)
          END
    ELSE STR_SPLIT(job_name, '/', 0)
    END AS package_name,
  CASE
    WHEN substr(job_name, 1, 1) = '@' THEN STR_SPLIT(job_name, '@', 1)
    ELSE STR_SPLIT(job_name, '/', 1)
    END AS job_namespace,
  ts_lead - ts AS dur,
  IIF(lead_state = 'SCHEDULED', TRUE, FALSE) AS is_rescheduled,
  *
FROM cte
WHERE
  is_end_slice = FALSE
  AND (ts_lead - ts) > 0
  AND state = 'STARTED'
  AND lead_state IN ('FINISHED', 'SCHEDULED');

CREATE PERFETTO TABLE _charging_screen_states AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ROW_NUMBER() OVER () AS id,
  ii.ts,
  ii.dur,
  c.charging_state,
  s.screen_state
FROM _interval_intersect!(
  (android_charging_states, _screen_states),
  ()
) ii
JOIN android_charging_states c ON c.id = ii.id_0
JOIN _screen_states s ON s.id = ii.id_1;

-- This table returns constraint changes that a
-- job will go through in a single trace.
--
-- Values in this table are derived from the the `ScheduledJobStateChanged`
-- atom. This table differs from the
-- `android_job_scheduler_with_screen_charging_states` in this module
-- (`android.job_scheduler_states`) by only having job constraint information.
--
-- See documentation for the `android_job_scheduler_with_screen_charging_states`
-- for how tables in this module differ from `android_job_scheduler_events`
-- table in the `android.job_scheduler` module and how to populate this table.
CREATE PERFETTO TABLE android_job_scheduler_states(
  -- Unique identifier for job scheduler state.
  id ID,
  -- Timestamp of job state slice.
  ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Duration of job state slice.
  dur DURATION,
  -- Id of the slice.
  slice_id JOINID(slice.id),
  -- Name of the job (as named by the app).
  job_name STRING,
  -- Uid associated with job.
  uid LONG,
  -- Id of job (assigned by app for T- builds and system generated in U+
  -- builds).
  job_id LONG,
  -- Package that the job belongs (ex: associated app).
  package_name STRING,
  -- Namespace of job.
  job_namespace STRING,
  -- Priority at which JobScheduler ran the job.
  effective_priority LONG,
  -- True if app requested job should run when the device battery is not low.
  has_battery_not_low_constraint BOOL,
  -- True if app requested job should run when the device is charging.
  has_charging_constraint BOOL,
  -- True if app requested job should run when device has connectivity.
  has_connectivity_constraint BOOL,
  -- True if app requested job should run when there is a content trigger.
  has_content_trigger_constraint BOOL,
  -- True if app requested there is a deadline by which the job should run.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  has_deadline_constraint BOOL,
  -- True if app requested job should run when device is idle.
  has_idle_constraint BOOL,
  -- True if app requested job should run when device storage is not low.
  has_storage_not_low_constraint BOOL,
  -- True if app requested job has a timing delay.
  has_timing_delay_constraint BOOL,
  -- True if app requested job should run within hours of app launch.
  is_prefetch BOOL,
  -- True if app requested that the job is run as an expedited job.
  is_requested_expedited_job BOOL,
  -- The job is run as an expedited job.
  is_running_as_expedited_job BOOL,
  -- Number of previous attempts at running job.
  num_previous_attempts TIMESTAMP,
  -- The requested priority at which the job should run.
  requested_priority LONG,
  -- The job's standby bucket (one of: Active, Working Set, Frequent, Rare,
  -- Never, Restricted, Exempt).
  standby_bucket STRING,
  -- Job should run in intervals.
  is_periodic BOOL,
  -- True if the job should run as a flex job.
  has_flex_constraint BOOL,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- True is app has requested that a job be run as a user initiated job.
  is_requested_as_user_initiated_job BOOL,
  -- True if job is running as a user initiated job.
  is_running_as_user_initiated_job BOOL,
  -- Deadline that job has requested and valid if has_deadline_constraint is
  -- true.
  deadline_ms LONG,
  -- The latency in ms between when a job is scheduled and when it actually
  -- starts.
  job_start_latency_ms LONG,
  -- Number of uncompleted job work items.
  num_uncompleted_work_items LONG,
  -- Process state of the process responsible for running the job.
  proc_state STRING,
  -- Internal stop reason for a job.
  internal_stop_reason STRING,
  -- Public stop reason for a job.
  public_stop_reason STRING

) AS
SELECT
  ROW_NUMBER() OVER (ORDER BY ts) AS id,
  ts,
  dur,
  slice_id,
  job_name,
  uid,
  job_id,
  package_name,
  job_namespace,
  effective_priority,
  has_battery_not_low_constraint,
  has_charging_constraint,
  has_connectivity_constraint,
  has_content_trigger_constraint,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  has_deadline_constraint,
  has_idle_constraint,
  has_storage_not_low_constraint,
  has_timing_delay_constraint,
  is_prefetch,
  is_requested_expedited_job,
  is_running_as_expedited_job,
  num_previous_attempts,
  requested_priority,
  standby_bucket,
  is_periodic,
  has_flex_constraint,
  is_requested_as_user_initiated_job,
  is_running_as_user_initiated_job,
  deadline_ms,
  job_start_latency_ms,
  num_uncompleted_work_items,
  proc_state,
  lead_internal_stop_reason AS internal_stop_reason,
  lead_public_stop_reason AS public_stop_reason
FROM _job_started;

-- This table returns the constraint, charging,
-- and screen state changes that a job will go through
-- in a single trace.
--
-- Values from this table are derived from
-- the `ScheduledJobStateChanged` atom. This differs from the
-- `android_job_scheduler_events` table in the `android.job_scheduler` module
-- which is derived from ATrace the system server category
-- (`atrace_categories: "ss"`).
--
-- This also differs from the `android_job_scheduler_states` in this module
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- (`android.job_scheduler_states`) by providing charging and screen state
-- changes.
--
-- To populate this table, enable the Statsd Tracing Config with the
-- ATOM_SCHEDULED_JOB_STATE_CHANGED push atom id.
-- https://perfetto.dev/docs/reference/trace-config-proto#StatsdTracingConfig
--
-- This table is preferred over `android_job_scheduler_events`
-- since it contains more information and should be used whenever
-- `ATOM_SCHEDULED_JOB_STATE_CHANGED` is available in a trace.
CREATE PERFETTO TABLE android_job_scheduler_with_screen_charging_states(
  -- Timestamp of job.
  ts TIMESTAMP,
  -- Duration of slice in ns.
  dur DURATION,
  -- Id of the slice.
  slice_id JOINID(slice.id),
  -- Name of the job (as named by the app).
  job_name STRING,
  -- Id of job (assigned by app for T- builds and system generated in U+
  -- builds).
  job_id LONG,
  -- Uid associated with job.
  uid LONG,
  -- Duration of entire job in ns.
  job_dur DURATION,
  -- Package that the job belongs (ex: associated app).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  package_name STRING,
  -- Namespace of job.
  job_namespace STRING,
  -- Device charging state during job (one of: Charging, Discharging, Not charging,
  -- Full, Unknown).
  charging_state STRING,
  -- Device screen state during job (one of: Screen off, Screen on, Always-on display
  -- (doze), Unknown).
  screen_state STRING,
  -- Priority at which JobScheduler ran the job.
  effective_priority LONG,
  -- True if app requested job should run when the device battery is not low.
  has_battery_not_low_constraint BOOL,
  -- True if app requested job should run when the device is charging.
  has_charging_constraint BOOL,
  -- True if app requested job should run when device has connectivity.
  has_connectivity_constraint BOOL,
  -- True if app requested job should run when there is a content trigger.
  has_content_trigger_constraint BOOL,
  -- True if app requested there is a deadline by which the job should run.
  has_deadline_constraint BOOL,
  -- True if app requested job should run when device is idle.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  has_idle_constraint BOOL,
  -- True if app requested job should run when device storage is not low.
  has_storage_not_low_constraint BOOL,
  -- True if app requested job has a timing delay.
  has_timing_delay_constraint BOOL,
  -- True if app requested job should run within hours of app launch.
  is_prefetch BOOL,
  -- True if app requested that the job is run as an expedited job.
  is_requested_expedited_job BOOL,
  -- The job is run as an expedited job.
  is_running_as_expedited_job BOOL,
  -- Number of previous attempts at running job.
  num_previous_attempts TIMESTAMP,
  -- The requested priority at which the job should run.
  requested_priority LONG,
  -- The job's standby bucket (one of: Active, Working Set, Frequent, Rare,
  -- Never, Restricted, Exempt).
  standby_bucket STRING,
  -- Job should run in intervals.
  is_periodic BOOL,
  -- True if the job should run as a flex job.
  has_flex_constraint BOOL,
  -- True is app has requested that a job be run as a user initiated job.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_requested_as_user_initiated_job BOOL,
  -- True if job is running as a user initiated job.
  is_running_as_user_initiated_job BOOL,
  -- Deadline that job has requested and valid if has_deadline_constraint is
  -- true.
  deadline_ms LONG,
  -- The latency in ms between when a job is scheduled and when it actually
  -- starts.
  job_start_latency_ms LONG,
  -- Number of uncompleted job work items.
  num_uncompleted_work_items LONG,
  -- Process state of the process responsible for running the job.
  proc_state STRING,
  -- Internal stop reason for a job.
  internal_stop_reason STRING,
  -- Public stop reason for a job.
  public_stop_reason STRING
) AS
SELECT
  ii.ts,
  ii.dur,
  js.slice_id,
  js.job_name || '_' || js.job_id AS job_name,
  js.uid,
  js.job_id,
  js.dur AS job_dur,
  js.package_name,
  js.job_namespace,
  c.charging_state,
  c.screen_state,
  js.effective_priority,
  js.has_battery_not_low_constraint,
  js.has_charging_constraint,
  js.has_connectivity_constraint,
  js.has_content_trigger_constraint,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  js.has_deadline_constraint,
  js.has_idle_constraint,
  js.has_storage_not_low_constraint,
  js.has_timing_delay_constraint,
  js.is_prefetch,
  js.is_requested_expedited_job,
  js.is_running_as_expedited_job,
  js.num_previous_attempts,
  js.requested_priority,
  js.standby_bucket,
  js.is_periodic,
  js.has_flex_constraint,
  js.is_requested_as_user_initiated_job,
  js.is_running_as_user_initiated_job,
  js.deadline_ms,
  js.job_start_latency_ms,
  js.num_uncompleted_work_items,
  js.proc_state,
  js.internal_stop_reason,
  js.public_stop_reason
  FROM _interval_intersect!(
        (_charging_screen_states,
        android_job_scheduler_states),
        ()
      ) ii
  JOIN _charging_screen_states c ON c.id = ii.id_0
  JOIN android_job_scheduler_states js ON js.id = ii.id_1;

)_d3l1m1t3r_"
;

const char kAndroidMonitorContention[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE android.suspend;

-- Extracts the blocking thread from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_thread(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "with owner ", 1), " (", 0);

-- Extracts the blocking thread tid from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_tid(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Name of slice
  slice_name STRING
)
-- Blocking thread tid
RETURNS LONG AS
SELECT cast_int!(STR_SPLIT(STR_SPLIT($slice_name, " (", 1), ")", 0));

-- Extracts the blocking method from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, ") at ", 1), "(", 1);

-- Extracts a shortened form of the blocking method name from a slice name.
-- The shortened form discards the parameter and return
-- types.
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocking_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocking_method($slice_name), " ", 1), "(", 0);

-- Extracts the monitor contention blocked method from a slice name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 0)
    || "("
    || STR_SPLIT(STR_SPLIT($slice_name, "blocking from ", 1), "(", 1);

-- Extracts a shortened form of the monitor contention blocked method name
-- from a slice name. The shortened form discards the parameter and return
-- types.
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_short_blocked_method(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT
    STR_SPLIT(STR_SPLIT(android_extract_android_monitor_contention_blocked_method($slice_name), " ", 1), "(", 0);

-- Extracts the number of waiters on the monitor from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_waiter_count(
  -- Name of slice
  slice_name STRING
)
-- Count of waiters on the lock
RETURNS LONG AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT cast_int!(STR_SPLIT(STR_SPLIT($slice_name, "waiters=", 1), " ", 0));

-- Extracts the monitor contention blocking source location from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocking_src(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 1), ")", 0);

-- Extracts the monitor contention blocked source location from a slice name
CREATE PERFETTO FUNCTION android_extract_android_monitor_contention_blocked_src(
  -- Name of slice
  slice_name STRING
)
-- Blocking thread
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT($slice_name, ")(", 2), ")", 0);

CREATE PERFETTO TABLE _valid_android_monitor_contention AS
SELECT slice.id AS id
FROM slice
LEFT JOIN slice child
  ON child.parent_id = slice.id
LEFT JOIN slice grand_child
  ON grand_child.parent_id = child.id
WHERE
  slice.name GLOB 'monitor contention*'
  AND (child.name GLOB 'Lock contention*' OR child.name IS NULL)
  AND (grand_child.name IS NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY slice.id;

-- Contains parsed monitor contention slices.
CREATE PERFETTO TABLE android_monitor_contention(
  -- Name of the method holding the lock.
  blocking_method STRING,
  -- Blocked_method without arguments and return types.
  blocked_method STRING,
  -- Blocking_method without arguments and return types.
  short_blocking_method STRING,
  -- Blocked_method without arguments and return types.
  short_blocked_method STRING,
  -- File location of blocking_method in form <filename:linenumber>.
  blocking_src STRING,
  -- File location of blocked_method in form <filename:linenumber>.
  blocked_src STRING,
  -- Zero indexed number of threads trying to acquire the lock.
  waiter_count LONG,
  -- Utid of thread holding the lock.
  blocked_utid JOINID(thread.id),
  -- Thread name of thread holding the lock.
  blocked_thread_name STRING,
  -- Utid of thread holding the lock.
  blocking_utid JOINID(thread.id),
  -- Thread name of thread holding the lock.
  blocking_thread_name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Tid of thread holding the lock.
  blocking_tid LONG,
  -- Upid of process experiencing lock contention.
  upid JOINID(process.id),
  -- Process name of process experiencing lock contention.
  process_name STRING,
  -- Slice id of lock contention.
  id LONG,
  -- Timestamp of lock contention start.
  ts TIMESTAMP,
  -- Wall clock duration of lock contention.
  dur DURATION,
  -- Monotonic clock duration of lock contention.
  monotonic_dur DURATION,
  -- Thread track id of blocked thread.
  track_id JOINID(track.id),
  -- Whether the blocked thread is the main thread.
  is_blocked_thread_main LONG,
  -- Tid of the blocked thread
  blocked_thread_tid LONG,
  -- Whether the blocking thread is the main thread.
  is_blocking_thread_main LONG,
  -- Tid of thread holding the lock.
  blocking_thread_tid LONG,
  -- Slice id of binder reply slice if lock contention was part of a binder txn.
  binder_reply_id LONG,
  -- Timestamp of binder reply slice if lock contention was part of a binder txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  binder_reply_ts TIMESTAMP,
  -- Tid of binder reply slice if lock contention was part of a binder txn.
  binder_reply_tid LONG,
  -- Pid of process experiencing lock contention.
  pid LONG
) AS
SELECT
  android_extract_android_monitor_contention_blocking_method(slice.name) AS blocking_method,
  android_extract_android_monitor_contention_blocked_method(slice.name)  AS blocked_method,
  android_extract_android_monitor_contention_short_blocking_method(slice.name) AS short_blocking_method,
  android_extract_android_monitor_contention_short_blocked_method(slice.name)  AS short_blocked_method,
  android_extract_android_monitor_contention_blocking_src(slice.name) AS blocking_src,
  android_extract_android_monitor_contention_blocked_src(slice.name) AS blocked_src,
  android_extract_android_monitor_contention_waiter_count(slice.name) AS waiter_count,
  thread.utid AS blocked_utid,
  thread.name AS blocked_thread_name,
  blocking_thread.utid AS blocking_utid,
  android_extract_android_monitor_contention_blocking_thread(slice.name) AS blocking_thread_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  android_extract_android_monitor_contention_blocking_tid(slice.name) AS blocking_tid,
  thread.upid AS upid,
  process.name AS process_name,
  slice.id,
  slice.ts,
  slice.dur,
  _extract_duration_without_suspend(slice.ts, slice.dur) AS monotonic_dur,
  slice.track_id,
  thread.is_main_thread AS is_blocked_thread_main,
  thread.tid AS blocked_thread_tid,
  blocking_thread.is_main_thread AS is_blocking_thread_main,
  blocking_thread.tid AS blocking_thread_tid,
  binder_reply.id AS binder_reply_id,
  binder_reply.ts AS binder_reply_ts,
  binder_reply_thread.tid AS binder_reply_tid,
  process.pid
FROM slice
JOIN thread_track
  ON thread_track.id = slice.track_id
LEFT JOIN thread
  USING (utid)
LEFT JOIN process
  USING (upid)
LEFT JOIN ANCESTOR_SLICE(slice.id) binder_reply ON binder_reply.name = 'binder reply'
LEFT JOIN thread_track binder_reply_thread_track ON binder_reply.track_id = binder_reply_thread_track.id
LEFT JOIN thread binder_reply_thread ON binder_reply_thread_track.utid = binder_reply_thread.utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Before Android U, we didn't have blocking_thread tid (aosp/3000578). We do a LEFT JOIN instead
-- of JOIN so that on older devices we can at least capture the list of contentions without edges.
LEFT JOIN thread blocking_thread ON blocking_thread.tid = blocking_tid AND blocking_thread.upid = thread.upid
JOIN _valid_android_monitor_contention ON _valid_android_monitor_contention.id = slice.id
WHERE slice.name GLOB 'monitor contention*'
  AND slice.dur != -1
  AND short_blocking_method IS NOT NULL
  AND short_blocked_method IS NOT NULL
GROUP BY slice.id;

CREATE PERFETTO INDEX _android_monitor_contention_blocking_utid_idx
  ON android_monitor_contention (blocking_utid, ts);

CREATE PERFETTO INDEX _android_monitor_contention_id_idx
  ON android_monitor_contention (id);

-- Monitor contention slices that are blocked by another monitor contention slice.
-- They will have a |parent_id| field which is the id of the slice they are blocked by.
CREATE PERFETTO TABLE _children AS
SELECT parent.id AS parent_id, child.* FROM android_monitor_contention child
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN android_monitor_contention parent ON parent.blocked_utid = child.blocking_utid
AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;

-- Monitor contention slices that are blocking another monitor contention slice.
-- They will have a |child_id| field which is the id of the slice they are blocking.
CREATE PERFETTO TABLE _parents AS
SELECT parent.*, child.id AS child_id FROM android_monitor_contention parent
JOIN android_monitor_contention child ON parent.blocked_utid = child.blocking_utid
AND child.ts BETWEEN parent.ts AND parent.ts + parent.dur;

-- Monitor contention slices that are neither blocking nor blocked by another monitor contention
-- slice. They neither have |parent_id| nor |child_id| fields.
CREATE PERFETTO TABLE _isolated AS
WITH parents_and_children AS (
 SELECT id FROM _children
 UNION ALL
 SELECT id FROM _parents
), isolated AS (
    SELECT id FROM android_monitor_contention
    EXCEPT
    SELECT id FROM parents_and_children
  )
SELECT * FROM android_monitor_contention JOIN isolated USING (id);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Contains parsed monitor contention slices with the parent-child relationships.
CREATE PERFETTO TABLE android_monitor_contention_chain(
  -- Id of monitor contention slice blocking this contention.
  parent_id LONG,
  -- Name of the method holding the lock.
  blocking_method STRING,
  -- Blocked_method without arguments and return types.
  blocked_method STRING,
  -- Blocking_method without arguments and return types.
  short_blocking_method STRING,
  -- Blocked_method without arguments and return types.
  short_blocked_method STRING,
  -- File location of blocking_method in form <filename:linenumber>.
  blocking_src STRING,
  -- File location of blocked_method in form <filename:linenumber>.
  blocked_src STRING,
  -- Zero indexed number of threads trying to acquire the lock.
  waiter_count LONG,
  -- Utid of thread holding the lock.
  blocked_utid JOINID(thread.id),
  -- Thread name of thread holding the lock.
  blocked_thread_name STRING,
  -- Utid of thread holding the lock.
  blocking_utid JOINID(thread.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Thread name of thread holding the lock.
  blocking_thread_name STRING,
  -- Tid of thread holding the lock.
  blocking_tid LONG,
  -- Upid of process experiencing lock contention.
  upid JOINID(process.id),
  -- Process name of process experiencing lock contention.
  process_name STRING,
  -- Slice id of lock contention.
  id LONG,
  -- Timestamp of lock contention start.
  ts TIMESTAMP,
  -- Wall clock duration of lock contention.
  dur DURATION,
  -- Monotonic clock duration of lock contention.
  monotonic_dur DURATION,
  -- Thread track id of blocked thread.
  track_id JOINID(track.id),
  -- Whether the blocked thread is the main thread.
  is_blocked_thread_main LONG,
  -- Tid of the blocked thread
  blocked_thread_tid LONG,
  -- Whether the blocking thread is the main thread.
  is_blocking_thread_main LONG,
  -- Tid of thread holding the lock.
  blocking_thread_tid LONG,
  -- Slice id of binder reply slice if lock contention was part of a binder txn.
  binder_reply_id LONG,
  -- Timestamp of binder reply slice if lock contention was part of a binder txn.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  binder_reply_ts TIMESTAMP,
  -- Tid of binder reply slice if lock contention was part of a binder txn.
  binder_reply_tid LONG,
  -- Pid of process experiencing lock contention.
  pid LONG,
  -- Id of monitor contention slice blocked by this contention.
  child_id LONG
) AS
SELECT NULL AS parent_id, *, NULL AS child_id FROM _isolated
UNION ALL
SELECT c.*, p.child_id FROM _children c
LEFT JOIN _parents p USING(id)
UNION
SELECT c.parent_id, p.* FROM _parents p
LEFT JOIN _children c USING(id);

CREATE PERFETTO INDEX _android_monitor_contention_chain_idx
  ON android_monitor_contention_chain (blocking_method, blocking_utid, ts);

-- First blocked node on a lock, i.e nodes with |waiter_count| = 0. The |dur| here is adjusted
-- to only account for the time between the first thread waiting and the first thread to acquire
-- the lock. That way, the thread state span joins below only compute the thread states where
-- the blocking thread is actually holding the lock. This avoids counting the time when another
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- waiter acquired the lock before the first waiter.
CREATE PERFETTO VIEW _first_blocked_contention
  AS
SELECT start.id, start.blocking_utid, start.ts, MIN(end.ts + end.dur) - start.ts AS dur
FROM android_monitor_contention_chain start
JOIN android_monitor_contention_chain end
  ON
    start.blocking_utid = end.blocking_utid
    AND start.blocking_method = end.blocking_method
    AND end.ts BETWEEN start.ts AND start.ts + start.dur
WHERE start.waiter_count = 0
GROUP BY start.id;

CREATE PERFETTO VIEW _blocking_thread_state
AS
SELECT utid AS blocking_utid, ts, dur, state, blocked_function
FROM thread_state;

CREATE VIRTUAL TABLE _android_monitor_contention_chain_thread_state
USING
  SPAN_JOIN(_first_blocked_contention PARTITIONED blocking_utid,
            _blocking_thread_state PARTITIONED blocking_utid);

-- Contains the span join of the first waiters in the |android_monitor_contention_chain| with their
-- blocking_thread thread state.
--
-- Note that we only span join the duration where the lock was actually held and contended.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- This can be less than the duration the lock was 'waited on' when a different waiter acquired the
-- lock earlier than the first waiter.
CREATE PERFETTO TABLE android_monitor_contention_chain_thread_state(
  -- Slice id of lock contention.
  id LONG,
  -- Timestamp of lock contention start.
  ts TIMESTAMP,
  -- Wall clock duration of lock contention.
  dur DURATION,
  -- Utid of the blocking |thread_state|.
  blocking_utid JOINID(thread.id),
  -- Blocked kernel function of the blocking thread.
  blocked_function STRING,
  -- Thread state of the blocking thread.
  state STRING
) AS
SELECT
  id,
  ts,
  dur,
  blocking_utid,
  blocked_function,
  state
FROM _android_monitor_contention_chain_thread_state;

-- Aggregated thread_states on the 'blocking thread', the thread holding the lock.
-- This builds on the data from |android_monitor_contention_chain| and
-- for each contention slice, it returns the aggregated sum of all the thread states on the
-- blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
CREATE PERFETTO VIEW android_monitor_contention_chain_thread_state_by_txn(
  -- Slice id of the monitor contention.
  id LONG,
  -- A |thread_state| that occurred in the blocking thread during the contention.
  thread_state STRING,
  -- Total time the blocking thread spent in the |thread_state| during contention.
  thread_state_dur DURATION,
  -- Count of all times the blocking thread entered |thread_state| during the contention.
  thread_state_count LONG
) AS
SELECT
  id,
  state AS thread_state,
  SUM(dur) AS thread_state_dur,
  COUNT(dur) AS thread_state_count
FROM android_monitor_contention_chain_thread_state
GROUP BY id, thread_state;

-- Aggregated blocked_functions on the 'blocking thread', the thread holding the lock.
-- This builds on the data from |android_monitor_contention_chain| and
-- for each contention, it returns the aggregated sum of all the kernel
-- blocked function durations on the blocking thread.
--
-- Note that this data is only available for the first waiter on a lock.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW android_monitor_contention_chain_blocked_functions_by_txn(
  -- Slice id of the monitor contention.
  id LONG,
  -- Blocked kernel function in a thread state in the blocking thread during the contention.
  blocked_function STRING,
  -- Total time the blocking thread spent in the |blocked_function| during the contention.
  blocked_function_dur DURATION,
  -- Count of all times the blocking thread executed the |blocked_function| during the contention.
  blocked_function_count LONG
) AS
SELECT
  id,
  blocked_function,
  SUM(dur) AS blocked_function_dur,
  COUNT(dur) AS blocked_function_count
FROM android_monitor_contention_chain_thread_state
WHERE blocked_function IS NOT NULL
GROUP BY id, blocked_function;

-- Returns a DAG of all Java lock contentions in a process.
-- Each node in the graph is a <thread:Java method> pair.
-- Each edge connects from a node waiting on a lock to a node holding a lock.
-- The weights of each node represent the cumulative wall time the node blocked
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- other nodes connected to it.
CREATE PERFETTO FUNCTION android_monitor_contention_graph(
  -- Upid of process to generate a lock graph for.
  upid JOINID(process.id))
RETURNS TABLE(
  -- Pprof of lock graph.
  pprof BYTES) AS
WITH contention_chain AS (
SELECT *,
       IIF(blocked_thread_name GLOB 'binder:*', 'binder', blocked_thread_name)
        AS blocked_thread_name_norm,
       IIF(blocking_thread_name GLOB 'binder:*', 'binder', blocking_thread_name)
        AS blocking_thread_name_norm
FROM android_monitor_contention_chain WHERE upid = $upid
GROUP BY id, parent_id
), graph AS (
SELECT
  id,
  dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
    blocking_thread_name_norm || ':' || short_blocking_method) AS stack
FROM contention_chain
WHERE parent_id IS NULL
UNION ALL
SELECT
c.id,
c.dur AS dur,
  CAT_STACKS(blocked_thread_name_norm || ':' || short_blocked_method,
             blocking_thread_name_norm || ':' || short_blocking_method, stack) AS stack
FROM contention_chain c, graph AS p
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE p.id = c.parent_id
) SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', dur) AS pprof
  FROM graph;

)_d3l1m1t3r_"
;

const char kAndroidNetworkPackets[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Android network packet events (from android.network_packets data source).
CREATE PERFETTO VIEW android_network_packets(
  -- Timestamp.
  ts TIMESTAMP,
  -- Duration (non-zero only in aggregate events)
  dur DURATION,
  -- The track name (interface and direction)
  track_name STRING,
  -- Traffic package source (or uid=$X if not found)
  package_name STRING,
  -- Traffic interface name (linux interface name)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  iface STRING,
  -- Traffic direction ('Transmitted' or 'Received')
  direction STRING,
  -- Number of packets in this event
  packet_count LONG,
  -- Number of bytes in this event (wire size)
  packet_length LONG,
  -- Transport used for traffic in this event
  packet_transport STRING,
  -- TCP flags used by tcp frames in this event
  packet_tcp_flags LONG,
  -- The Android traffic tag of the network socket
  socket_tag STRING,
  -- The Linux user id of the network socket
  socket_uid LONG,
  -- The local port number (for udp or tcp only)
  local_port LONG,
  -- The remote port number (for udp or tcp only)
  remote_port LONG,
  -- 1-byte ICMP type identifier.
  packet_icmp_type LONG,
  -- 1-byte ICMP code identifier.
  packet_icmp_code LONG,
  -- Packet's tcp flags bitmask (e.g. FIN=0x1, SYN=0x2).
  packet_tcp_flags_int LONG,
  -- Packet's socket tag as an integer.
  socket_tag_int LONG
) AS
SELECT
  ts,
  dur,
  category AS track_name,
  name AS package_name,
  iface,
  direction,
  packet_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  packet_length,
  packet_transport,
  -- For backwards compatibility, the _str suffixed flags (which the ui shows)
  -- are exposed without suffix, and the integer fields get suffix instead.
  packet_tcp_flags_str AS packet_tcp_flags,
  packet_tcp_flags AS packet_tcp_flags_int,
  socket_tag_str AS socket_tag,
  socket_tag AS socket_tag_int,
  socket_uid,
  local_port,
  remote_port,
  packet_icmp_type,
  packet_icmp_code
FROM __intrinsic_android_network_packets;

)_d3l1m1t3r_"
;

const char kAndroidOomAdjuster[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE counters.intervals;

-- Converts an oom_adj score Integer to String sample name.
-- One of: cached, background, job, foreground_service, bfgs, foreground and
-- system.
CREATE PERFETTO FUNCTION android_oom_adj_score_to_bucket_name(
  -- `oom_score` value
  oom_score LONG
)
-- Returns the sample bucket based on the oom score.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS STRING
AS
SELECT
  CASE
    WHEN $oom_score >= 900 THEN 'cached'
    WHEN $oom_score BETWEEN 250 AND 900 THEN 'background'
    WHEN $oom_score BETWEEN 201 AND 250 THEN 'job'
    WHEN $oom_score = 200 THEN 'foreground_service'
    WHEN $oom_score BETWEEN 100 AND 200 THEN 'bfgs'
    WHEN $oom_score BETWEEN 0 AND 100 THEN 'foreground'
    WHEN $oom_score < 0 THEN 'system'
END;

-- Converts an oom_adj score Integer to String bucket name.
-- Deprecated: use `android_oom_adj_score_to_bucket_name` instead.
CREATE PERFETTO FUNCTION android_oom_adj_score_to_detailed_bucket_name(
  -- oom_adj score.
  value LONG,
  -- android_app id of the process.
  android_appid LONG)
-- Returns the oom_adj bucket.
RETURNS STRING
AS
SELECT
  CASE
    WHEN $value = -1000 THEN 'native'
    WHEN $value = -900 THEN 'system'
    WHEN $value = -800 THEN 'persistent_proc'
    WHEN $value = -700 THEN 'persistent_service'
    WHEN $value = -600 THEN 'logcat'
    WHEN $value = 0 THEN 'foreground_app'
    WHEN $value = 50 THEN 'perceptible_foreground_app'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $value BETWEEN 100 AND 199 THEN 'visible_app'
    WHEN $value BETWEEN 200 AND 224 THEN 'perceptible_app'
    WHEN $value BETWEEN 225 AND 249 THEN 'perceptible_medium_app'
    WHEN $value BETWEEN 250 AND 299 THEN 'perceptible_low_app'
    WHEN $value BETWEEN 300 AND 399 THEN 'backup'
    WHEN $value BETWEEN 400 AND 499 THEN 'heavy_weight_app'
    WHEN $value BETWEEN 500 AND 599 THEN 'service'
    WHEN $value BETWEEN 600 AND 699 THEN 'home_app'
    WHEN $value BETWEEN 700 AND 799 THEN 'previous_app'
    WHEN $value BETWEEN 800 AND 899 THEN 'service_b'
    WHEN $value BETWEEN 900 AND 949 THEN 'cached_app'
    WHEN $value >= 950 THEN 'cached_app_lmk_first'
    WHEN $android_appid IS NULL THEN 'unknown'
    WHEN $android_appid < 10000 THEN 'unknown_native'
    ELSE 'unknown_app'
  END;

CREATE PERFETTO TABLE _oom_adjuster_intervals AS
WITH reason AS (
  SELECT
    thread_slice.id AS oom_adj_id,
    thread_slice.ts AS oom_adj_ts,
    thread_slice.dur AS oom_adj_dur,
    thread_slice.track_id AS oom_adj_track_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    utid AS oom_adj_utid,
    thread_name AS oom_adj_thread_name,
    str_split(thread_slice.name, '_', 1) AS oom_adj_reason,
    slice.name AS oom_adj_trigger,
    LEAD(thread_slice.ts) OVER (ORDER BY thread_slice.ts) AS oom_adj_next_ts
  FROM thread_slice
  LEFT JOIN slice ON slice.id = thread_slice.parent_id AND slice.dur != -1
  WHERE thread_slice.name GLOB 'updateOomAdj_*' AND process_name = 'system_server'
)
SELECT
  ts,
  dur,
  cast_int!(value) AS score,
  process.upid,
  process.name AS process_name,
  reason.oom_adj_id,
  reason.oom_adj_ts,
  reason.oom_adj_dur,
  reason.oom_adj_track_id,
  reason.oom_adj_thread_name,
  reason.oom_adj_utid,
  reason.oom_adj_reason,
  reason.oom_adj_trigger,
  android_appid
FROM
  counter_leading_intervals
    !(
      (
        SELECT counter.*
        FROM counter
        JOIN counter_track track
          ON track.id = counter.track_id AND track.name = 'oom_score_adj'
      ))
      counter
JOIN process_counter_track track
  ON counter.track_id = track.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN process
  USING (upid)
LEFT JOIN reason
  ON counter.ts BETWEEN oom_adj_ts AND COALESCE(oom_adj_next_ts, trace_end())
WHERE track.name = 'oom_score_adj';


-- All oom adj state intervals across all processes along with the reason for the state update.
CREATE PERFETTO VIEW android_oom_adj_intervals (
  -- Timestamp the oom_adj score of the process changed
  ts TIMESTAMP,
  -- Duration until the next oom_adj score change of the process.
  dur DURATION,
  -- oom_adj score of the process.
  score LONG,
  -- oom_adj bucket of the process.
  bucket STRING,
  -- Upid of the process having an oom_adj update.
  upid JOINID(process.id),
  -- Name of the process having an oom_adj update.
  process_name STRING,
  -- Slice id of the latest oom_adj update in the system_server.
  oom_adj_id LONG,
  -- Timestamp of the latest oom_adj update in the system_server.
  oom_adj_ts TIMESTAMP,
  -- Duration of the latest oom_adj update in the system_server.
  oom_adj_dur DURATION,
  -- Track id of the latest oom_adj update in the system_server
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  oom_adj_track_id JOINID(track.id),
  -- Thread name of the latest oom_adj update in the system_server.
  oom_adj_thread_name STRING,
  -- Reason for the latest oom_adj update in the system_server.
  oom_adj_reason STRING,
  -- Trigger for the latest oom_adj update in the system_server.
  oom_adj_trigger STRING
  ) AS
SELECT
  ts,
  dur,
  score,
  android_oom_adj_score_to_bucket_name(score) AS bucket,
  upid,
  process_name,
  oom_adj_id,
  oom_adj_ts,
  oom_adj_dur,
  oom_adj_track_id,
  oom_adj_thread_name,
  oom_adj_reason,
  oom_adj_trigger
FROM _oom_adjuster_intervals;

)_d3l1m1t3r_"
;

const char kAndroidPowerRails[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE counters.intervals;
INCLUDE PERFETTO MODULE time.conversion;

-- Android power rails counters data.
-- For details see: https://perfetto.dev/docs/data-sources/battery-counters#odpm
-- NOTE: Requires dedicated hardware - table is only populated on Pixels.
CREATE PERFETTO TABLE android_power_rails_counters (
    -- `counter.id`
    id LONG,
    -- Timestamp of the energy measurement.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ts TIMESTAMP,
    -- Time until the next energy measurement.
    dur DURATION,
    -- Power rail name. Alias of `counter_track.name`.
    power_rail_name STRING,
    -- Raw power rail name.
    raw_power_rail_name STRING,
    -- Energy accumulated by this rail since boot in microwatt-seconds
    -- (uWs) (AKA micro-joules). Alias of `counter.value`.
    energy_since_boot DOUBLE,
    -- Energy accumulated by this rail at next energy measurement in
    -- microwatt-seconds (uWs) (AKA micro-joules). Alias of `counter.value` of
    -- the next meaningful (with value change) counter value.
    energy_since_boot_at_end DOUBLE,
    -- Average power in mW (milliwatts) over between ts and the next energy
    -- measurement.
    average_power DOUBLE,
    -- The change of energy accumulated by this rails since the last
    -- measurement in microwatt-seconds (uWs) (AKA micro-joules).
    energy_delta DOUBLE,
    -- Power rail track id. Alias of `counter_track.id`.
    track_id JOINID(track.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- DEPRECATED. Use `energy_since_boot` instead.
    value DOUBLE
) AS
WITH counter_table AS (
SELECT
    c.*
FROM counter c
JOIN counter_track t ON c.track_id = t.id
WHERE name GLOB 'power.*'
)
SELECT
    c.id,
    c.ts,
    c.dur,
    t.name AS power_rail_name,
    EXTRACT_ARG(source_arg_set_id, 'raw_name') AS raw_power_rail_name,
    c.value AS energy_since_boot,
    c.next_value AS energy_since_boot_at_end,
    1e3*(c.delta_value/(time_to_s(c.dur))) AS average_power,
    c.delta_value AS energy_delta,
    c.track_id,
    c.value
FROM counter_leading_intervals!(counter_table) c
JOIN counter_track t ON c.track_id = t.id;

)_d3l1m1t3r_"
;

const char kAndroidProcessMetadata[] = R"_d3l1m1t3r_(--
-- Copyright 2019 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Count packages by package UID.
CREATE PERFETTO TABLE _uid_package_count AS
SELECT uid, COUNT(1) AS cnt
FROM package_list
GROUP BY 1;

CREATE PERFETTO FUNCTION _android_package_for_process(
  uid LONG,
  uid_count LONG,
  process_name STRING
)
RETURNS TABLE(
  package_name STRING,
  version_code LONG,
  debuggable BOOL
)
AS
WITH min_distance AS (
  SELECT
    -- SQLite allows omitting the group-by for the MIN: the other columns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- will match the row with the minimum value.
    MIN(LENGTH($process_name) - LENGTH(package_name)),
    package_name,
    version_code,
    debuggable
  FROM package_list
  WHERE (
    (
      $uid = uid
      AND (
        -- unique match
        $uid_count = 1
        -- or process name is a prefix the package name
        OR $process_name GLOB package_name || '*'
      )
    )
    OR
    (
      -- isolated processes can only be matched based on the name
      $uid >= 90000 AND $uid < 100000
      AND STR_SPLIT($process_name, ':', 0) GLOB package_name || '*'
    )
  )
)
SELECT package_name, version_code, debuggable
FROM min_distance;

-- Data about packages running on the process.
CREATE PERFETTO TABLE android_process_metadata(
  -- Process upid.
  upid JOINID(process.id),
  -- Process pid.
  pid LONG,
  -- Process name.
  process_name STRING,
  -- Android app UID.
  uid LONG,
  -- Whether the UID is shared by multiple packages.
  shared_uid BOOL,
  -- Name of the packages running in this process.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  package_name STRING,
  -- Package version code.
  version_code LONG,
  -- Whether package is debuggable.
  debuggable LONG
) AS
SELECT
  process.upid,
  process.pid,
  -- workaround for b/169226092: the bug has been fixed it Android T, but
  -- we support ingesting traces from older Android versions.
  CASE
    -- cmdline gets rewritten after fork, if these are still there we must
    -- have seen a racy capture.
    WHEN length(process.name) = 15 AND (
      process.cmdline IN ('zygote', 'zygote64', '<pre-initialized>')
      OR process.cmdline GLOB '*' || process.name)
      THEN process.cmdline
    ELSE process.name
  END AS process_name,
  process.android_appid AS uid,
  CASE WHEN _uid_package_count.cnt > 1 THEN TRUE ELSE NULL END AS shared_uid,
  plist.package_name,
  plist.version_code,
  plist.debuggable
FROM process
LEFT JOIN _uid_package_count ON process.android_appid = _uid_package_count.uid
LEFT JOIN _android_package_for_process(
  process.android_appid, _uid_package_count.cnt, process.name
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS plist
ORDER BY upid;

)_d3l1m1t3r_"
;

const char kAndroidScreenshots[] = R"_d3l1m1t3r_(-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Screenshot slices, used in perfetto UI.
CREATE PERFETTO TABLE android_screenshots(
  -- Id of the screenshot slice.
  id JOINID(slice.id),
  -- Slice timestamp.
  ts TIMESTAMP,
  -- Slice duration, should be typically 0 since screeenshot slices are of instant
  -- type.
  dur DURATION,
  -- Slice name.
  name STRING
) AS
SELECT
  slice.id as id,
  slice.ts as ts,
  slice.dur as dur,
  slice.name as name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM slice
JOIN args USING(arg_set_id)
WHERE slice.name = "Screenshot"
  AND slice.category = "android_screenshot"
  AND args.key = "screenshot.jpg_image";

)_d3l1m1t3r_"
;

const char kAndroidServices[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE android.binder;
INCLUDE PERFETTO MODULE graphs.search;

-- Details of all Service#onBind dispatched events.
CREATE PERFETTO TABLE _bind_dispatch
AS
WITH
  next_sibling AS MATERIALIZED (
    SELECT *
    FROM
      graph_next_sibling!(
          (
            SELECT id AS node_id, parent_id AS node_parent_id, ts AS sort_key
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            FROM slice
            WHERE dur = 0
          )
      )
  ),
  service AS (
    SELECT
      next_slice.id,
      next_slice.ts,
      next_slice.dur,
      next_slice.name,
      slice.utid,
      slice.name AS bind_seq_name
    FROM next_sibling
    JOIN thread_slice slice
      ON slice.id = next_sibling.node_id
    JOIN slice next_slice
      ON next_slice.id = next_sibling.next_node_id
  )
  SELECT
  id,
  ts,
  dur,
  utid,
  cast_int!(STR_SPLIT(STR_SPLIT(bind_seq_name, 'bindSeq=', 1), ' ', 0)) AS bind_seq
FROM service
WHERE bind_seq_name GLOB 'requestServiceBinding*' AND name = 'binder transaction async';

-- Details of all Service#onBind received events.
CREATE PERFETTO TABLE _bind_receive
AS
SELECT
  id,
  ts,
  dur,
  track_id,
  REPLACE(STR_SPLIT(STR_SPLIT(name, 'token=', 1), ' ', 0), 'ServiceRecord{', '') AS token,
  STR_SPLIT(STR_SPLIT(name, 'act=', 1), ' ', 0) AS act,
  STR_SPLIT(STR_SPLIT(name, 'cmp=', 1), ' ', 0) AS cmp,
  STR_SPLIT(STR_SPLIT(name, 'flg=', 1), ' ', 0) AS flg,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cast_int!(STR_SPLIT(STR_SPLIT(name, 'bindSeq=', 1), '}', 0)) AS bind_seq
FROM slice
WHERE name GLOB 'serviceBind:*';

-- All service bindings from client app to server app.
CREATE PERFETTO TABLE android_service_bindings(
  -- OOM score of client process making the binding.
  client_oom_score LONG,
  -- Name of client process making the binding.
  client_process STRING,
  -- Name of client thread making the binding.
  client_thread STRING,
  -- Pid of client process making the binding.
  client_pid LONG,
  -- Tid of client process making the binding.
  client_tid LONG,
  -- Upid of client process making the binding.
  client_upid JOINID(process.id),
  -- Utid of client thread making the binding.
  client_utid JOINID(thread.id),
  -- Timestamp the client process made the request.
  client_ts TIMESTAMP,
  -- Duration of the client binding request.
  client_dur DURATION,
  -- OOM score of server process getting bound to.
  server_oom_score LONG,
  -- Name of server process getting bound to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  server_process STRING,
  -- Name of server thread getting bound to.
  server_thread STRING,
  -- Pid of server process getting bound to.
  server_pid LONG,
  -- Tid of server process getting bound to.
  server_tid LONG,
  -- Upid of server process getting bound to.
  server_upid JOINID(process.id),
  -- Utid of server process getting bound to.
  server_utid JOINID(thread.id),
  -- Timestamp the server process got bound to.
  server_ts TIMESTAMP,
  -- Duration of the server process handling the binding.
  server_dur DURATION,
  -- Unique binder identifier for the Service binding.
  token STRING,
  -- Intent action name for the service binding.
  act STRING,
  -- Intent component name for the service binding.
  cmp STRING,
  -- Intent flag for the service binding.
  flg STRING,
  -- Monotonically increasing id for the service binding.
  bind_seq LONG)
AS
SELECT
  COALESCE(client_binder.client_oom_score, server_binder.client_oom_score) AS client_oom_score,
  COALESCE(client_binder.client_process, server_binder.client_process) AS client_process,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COALESCE(client_binder.client_thread, server_binder.client_thread) AS client_thread,
  COALESCE(client_binder.client_pid, server_binder.client_pid) AS client_pid,
  COALESCE(client_binder.client_tid, server_binder.client_tid) AS client_tid,
  COALESCE(client_binder.client_upid, server_binder.client_upid) AS client_upid,
  COALESCE(client_binder.client_utid, server_binder.client_utid) AS client_utid,
  COALESCE(client_binder.client_ts, server_binder.client_ts) AS client_ts,
  COALESCE(client_binder.client_dur, server_binder.client_dur) AS client_dur,
  server_binder.server_oom_score,
  server_binder.server_process,
  server_binder.server_thread,
  server_binder.server_pid,
  server_binder.server_tid,
  server_binder.server_upid,
  server_binder.server_utid,
  receive.ts AS server_ts,
  receive.dur AS server_dur,
  receive.token,
  receive.act,
  receive.cmp,
  receive.flg,
  receive.bind_seq
FROM _bind_dispatch dispatch
JOIN _bind_receive receive
  ON dispatch.bind_seq = receive.bind_seq
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN android_binder_txns server_binder
  ON server_binder.binder_txn_id = dispatch.id
LEFT JOIN ancestor_slice(dispatch.id) anc ON anc.depth = 0
LEFT JOIN android_binder_txns client_binder
  ON client_binder.server_ts = anc.ts AND dispatch.utid = client_binder.server_utid;

)_d3l1m1t3r_"
;

const char kAndroidSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


CREATE PERFETTO FUNCTION _remove_lambda_name(
-- Raw slice name containing at least one "$"
  name STRING)
-- Removes everything after the first "$"
RETURNS STRING AS
SELECT
    substr($name, 0, instr($name, "$"))
END;

-- Some slice names have params in them. This functions removes them to make it
-- possible to aggregate by name.
-- Some examples are:
--  - Lock/monitor contention slices. The name includes where the lock
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--    contention is in the code. That part is removed.
--  - DrawFrames/ooFrame. The name also includes the frame number.
--  - Apk/oat/dex loading: The name of the apk is removed
CREATE PERFETTO FUNCTION android_standardize_slice_name(
  -- The raw slice name.
  name STRING)
-- Simplified name.
RETURNS STRING AS
SELECT
  CASE
    WHEN $name GLOB "monitor contention with*" THEN "monitor contention with <...>"
    WHEN $name GLOB "SuspendThreadByThreadId*" THEN "SuspendThreadByThreadId <...>"
    WHEN $name GLOB "LoadApkAssetsFd*" THEN "LoadApkAssetsFd <...>"
    WHEN $name GLOB "relayoutWindow*" THEN "relayoutWindow <...>"
    WHEN $name GLOB "android.os.Handler: kotlinx.coroutines*" THEN "CoroutineContinuation"
    WHEN $name GLOB "Choreographer#doFrame*" THEN "Choreographer#doFrame"
    WHEN $name GLOB "DrawFrames*" THEN "DrawFrames"
    WHEN $name GLOB "/data/app*.apk" THEN "APK load"
    WHEN $name GLOB "OpenDexFilesFromOat*" THEN "OpenDexFilesFromOat"
    WHEN $name GLOB "Open oat file*" THEN "Open oat file"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN $name GLOB "GC: Wait For*" THEN "Garbage Collector"
    -- E.g. Lock contention on thread list lock (owner tid: 1665)
    -- To: Lock contention on thread list lock <...>
    WHEN $name GLOB "Lock contention on* (*" THEN substr($name, 0, instr($name, "(")) || "<...>"
    -- Top level handlers slices heuristics:
        -- E.g. android.os.Handler: com.android.systemui.qs.external.TileServiceManager$1
        -- To: Handler: com.android.systemui.qs.external.TileServiceManager
    WHEN $name GLOB "*Handler: *$*" THEN _remove_lambda_name(substr($name, instr($name, "Handler:")))
        -- E.g. : android.view.ViewRootImpl$ViewRootHandler: com.android.systemui.someClass$enableMarquee$1
        -- To: Handler: android.view.ViewRootImpl
    WHEN $name GLOB "*.*.*: *$*" THEN "Handler: " || _remove_lambda_name(substr($name, ": "))
        -- E.g.: android.os.AsyncTask$InternalHandler: #1
        -- To: Handler: android.os.AsyncTask
    WHEN $name GLOB "*.*$*: #*" THEN "Handler: " || _remove_lambda_name($name)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ELSE $name
  END;

)_d3l1m1t3r_"
;

const char kAndroidStatsd[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Statsd atoms.
--
-- A subset of the slice table containing statsd atom instant events.
CREATE PERFETTO VIEW android_statsd_atoms(
  -- Unique identifier for this slice.
  id LONG,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The id of the argument set associated with this slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_set_id ARGSETID,
  -- The value of the CPU instruction counter at the start of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
  thread_instruction_count LONG,
  -- The change in value of the CPU instruction counter between the start and end of the slice. This column will only be populated if thread instruction collection is enabled with track_event.
  thread_instruction_delta LONG,
  -- The id of the track this slice is located on.
  track_id JOINID(track.id),
  -- The "category" of the slice. If this slice originated with track_event, this column contains the category emitted. Otherwise, it is likely to be null (with limited exceptions).
  category STRING,
  -- The name of the slice. The name describes what was happening during the slice.
  name STRING,
  -- The depth of the slice in the current stack of slices.
  depth LONG,
  -- A unique identifier obtained from the names of all slices in this stack. This is rarely useful and kept around only for legacy reasons.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  stack_id LONG,
  -- The stack_id for the parent of this slice. Rarely useful.
  parent_stack_id LONG,
  -- The id of the parent (i.e. immediate ancestor) slice for this slice.
  parent_id LONG,
  -- The thread timestamp at the start of the slice. This column will only be populated if thread timestamp collection is enabled with track_event.
  thread_ts TIMESTAMP,
  -- The thread time used by this slice. This column will only be populated if thread timestamp collection is enabled with track_event.
  thread_dur LONG
) AS
SELECT
  slice.id AS id,
  slice.type AS type,
  slice.ts AS ts,
  slice.dur AS dur,
  slice.arg_set_id AS arg_set_id,
  slice.thread_instruction_count AS thread_instruction_count,
  slice.thread_instruction_delta AS thread_instruction_delta,
  slice.track_id AS track_id,
  slice.category AS category,
  slice.name AS name,
  slice.depth AS depth,
  slice.stack_id AS stack_id,
  slice.parent_stack_id AS parent_stack_id,
  slice.parent_id AS parent_id,
  slice.thread_ts AS thread_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.thread_dur AS thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
WHERE
  track.name = 'Statsd Atoms';

-- Information about Perfetto triggers, extracted from statsd atoms, which
-- happened during the trace.
--
-- This requires the `android.statsd` data-source to be enabled and the
-- `ATOM_PERFETTO_TRIGGER` push atom to be configured.
CREATE PERFETTO TABLE _android_statsd_perfetto_triggers(
  -- Timestamp of the trigger.
  ts TIMESTAMP,
  -- The name of the trigger.
  trigger_name STRING
)
AS
SELECT
  ts,
  extract_arg(arg_set_id, 'perfetto_trigger.trigger_name') AS trigger_name
FROM android_statsd_atoms
WHERE name = 'perfetto_trigger';

)_d3l1m1t3r_"
;

const char kAndroidSuspend[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Table of suspended and awake slices.
--
-- Selects either the minimal or full ftrace source depending on what's
-- available, marks suspended periods, and complements them to give awake
-- periods.
CREATE PERFETTO TABLE android_suspend_state(
  -- Timestamp
  ts TIMESTAMP,
  -- Duration
  dur DURATION,
  -- 'awake' or 'suspended'
  power_state STRING) AS
WITH suspend_slice_from_minimal AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT ts, dur
  FROM track t JOIN slice s ON s.track_id = t.id
  WHERE t.name = 'Suspend/Resume Minimal'
),
suspend_slice as (
  SELECT ts, dur FROM suspend_slice_from_minimal
  UNION ALL
  SELECT
    ts,
    dur
  FROM
    slice
  JOIN
    track
    ON slice.track_id = track.id
  WHERE
    track.name = 'Suspend/Resume Latency'
    AND (slice.name = 'syscore_resume(0)' OR slice.name = 'timekeeping_freeze(0)')
    AND dur != -1
    AND NOT EXISTS(SELECT * FROM suspend_slice_from_minimal)
),
awake_slice AS (
  -- If we don't have any rows, use the trace bounds if bounds are defined.
  SELECT
    trace_start() AS ts,
    trace_dur() AS dur
  WHERE (SELECT COUNT(*) FROM suspend_slice) = 0 AND dur > 0
  UNION ALL
  -- If we do have rows, create one slice from the trace start to the first suspend.
  SELECT
    trace_start() AS ts,
    (SELECT min(ts) FROM suspend_slice) - trace_start() AS dur
  WHERE (SELECT COUNT(*) FROM suspend_slice) != 0
  UNION ALL
  -- And then one slice for each suspend, from the end of the suspend to the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- start of the next one (or the end of the trace if there is no next one).
  SELECT
    ts + dur AS ts,
    ifnull(lead(ts) OVER (ORDER BY ts), trace_end()) - ts - dur
      AS dur
  FROM suspend_slice
)
SELECT ts, dur, 'awake' AS power_state
FROM awake_slice
UNION ALL
SELECT ts, dur, 'suspended' AS power_state
FROM suspend_slice
ORDER BY ts; -- Order by will cause Perfetto table to index by ts.


-- Extracts the duration without counting CPU suspended time from an event.
-- This is the same as converting an event duration from wall clock to monotonic clock.
-- If there was no CPU suspend, the result is same as |dur|.
CREATE PERFETTO FUNCTION _extract_duration_without_suspend(
  -- Timestamp of event.
  ts TIMESTAMP,
  -- Duration of event.
  dur DURATION)
RETURNS LONG
AS
SELECT to_monotonic($ts + $dur) - to_monotonic($ts);

)_d3l1m1t3r_"
;

const char kAndroidThread[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO FUNCTION _thread_prefix(thread_name STRING)
RETURNS STRING AS
SELECT STR_SPLIT(STR_SPLIT(STR_SPLIT(STR_SPLIT($thread_name, "-", 0), "[", 0), ":", 0), " ", 0);

-- Per process stats of threads created in a process
CREATE PERFETTO FUNCTION _android_thread_creation_spam(
  -- Minimum duration between creating and destroying a thread before their the
  -- thread creation event is considered. If NULL, considers all thread creations.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  min_thread_dur DOUBLE,
  -- Sliding window duration for counting the thread creations. Each window
  -- starts at the first thread creation per <process, thread_name_prefix>.
  sliding_window_dur DOUBLE)
RETURNS TABLE(
  -- Process name creating threads.
  process_name STRING,
  -- Process pid creating threads.
  pid LONG,
  -- String prefix of thread names created.
  thread_name_prefix STRING,
  -- Max number of threads created within a time window.
  max_count_per_sec LONG
) AS
WITH
x AS (
  SELECT
    pid,
    upid,
    _THREAD_PREFIX(thread.name) AS thread_name_prefix,
    process.name AS process_name,
    COUNT(thread.start_ts)
      OVER (
        PARTITION BY upid, thread.name
        ORDER BY thread.start_ts
        RANGE BETWEEN CURRENT ROW AND cast_int!($sliding_window_dur) FOLLOWING
      ) AS count
  FROM thread
  JOIN process
    USING (upid)
  WHERE
    ($min_thread_dur AND (thread.end_ts - thread.start_ts) <= $min_thread_dur)
    OR $min_thread_dur IS NULL
)
SELECT process_name, pid, thread_name_prefix, MAX(count) AS max_count_per_sec
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM x
GROUP BY upid, thread_name_prefix
HAVING max_count_per_sec > 0
ORDER BY count DESC;

)_d3l1m1t3r_"
;

const char kAndroidVersion[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO FUNCTION _android_sdk_version()
RETURNS LONG AS
SELECT int_value AS sdk_version
FROM metadata
WHERE name = 'android_sdk_version';

)_d3l1m1t3r_"
;

const char kCallstacksStackProfile[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.hierarchy;
INCLUDE PERFETTO MODULE graphs.scan;

CREATE PERFETTO TABLE _callstack_spf_summary AS
SELECT
  id,
  symbol_set_id,
  (
    SELECT id
    FROM stack_profile_symbol s
    WHERE s.symbol_set_id = f.symbol_set_id
    ORDER BY id
    LIMIT 1
  ) AS min_symbol_id,
  (
    SELECT id
    FROM stack_profile_symbol s
    WHERE s.symbol_set_id = f.symbol_set_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ORDER BY id DESC
    LIMIT 1
  ) AS max_symbol_id
FROM stack_profile_frame f
ORDER BY id;

CREATE PERFETTO TABLE _callstack_spc_raw_forest AS
SELECT
  c.id AS callsite_id,
  s.id AS symbol_id,
  IIF(
    s.id IS f.min_symbol_id,
    c.parent_id,
    c.id
  ) AS parent_callsite_id,
  IIF(
    s.id IS f.min_symbol_id,
    pf.max_symbol_id,
    s.id - 1
  ) AS parent_symbol_id,
  f.id AS frame_id,
  s.id IS f.max_symbol_id AS is_leaf
FROM stack_profile_callsite c
JOIN _callstack_spf_summary f ON c.frame_id = f.id
LEFT JOIN stack_profile_symbol s USING (symbol_set_id)
LEFT JOIN stack_profile_callsite p ON c.parent_id = p.id
LEFT JOIN _callstack_spf_summary pf ON p.frame_id = pf.id
ORDER BY c.id;

CREATE PERFETTO TABLE _callstack_spc_forest AS
SELECT
  c._auto_id AS id,
  p._auto_id AS parent_id,
  -- TODO(lalitm): consider demangling in a separate table as
  -- demangling is suprisingly inefficient and is taking a
  -- significant fraction of the runtime on big traces.
  IFNULL(
    DEMANGLE(COALESCE(s.name, f.deobfuscated_name, f.name)),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    COALESCE(s.name, f.deobfuscated_name, f.name, '[Unknown]')
  ) AS name,
  f.mapping AS mapping_id,
  s.source_file,
  s.line_number,
  c.callsite_id,
  c.is_leaf AS is_leaf_function_in_callsite_frame
FROM _callstack_spc_raw_forest c
JOIN stack_profile_frame f ON c.frame_id = f.id
LEFT JOIN stack_profile_symbol s ON c.symbol_id = s.id
LEFT JOIN _callstack_spc_raw_forest p ON
  p.callsite_id = c.parent_callsite_id
  AND p.symbol_id IS c.parent_symbol_id
ORDER BY c._auto_id;

CREATE PERFETTO INDEX _callstack_spc_index
ON _callstack_spc_forest(callsite_id);

CREATE PERFETTO MACRO _callstacks_for_stack_profile_samples(
  spc_samples TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  SELECT
    f.id,
    f.parent_id,
    f.callsite_id,
    f.name,
    m.name AS mapping_name,
    f.source_file,
    f.line_number
  FROM _tree_reachable_ancestors_or_self!(
    _callstack_spc_forest,
    (
      SELECT f.id
      FROM $spc_samples s
      JOIN _callstack_spc_forest f USING (callsite_id)
      WHERE f.is_leaf_function_in_callsite_frame
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  ) g
  JOIN _callstack_spc_forest f USING (id)
  JOIN stack_profile_mapping m ON f.mapping_id = m.id
);

CREATE PERFETTO MACRO _callstacks_for_callsites(
  samples TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  WITH metrics AS MATERIALIZED (
    SELECT
      callsite_id,
      COUNT() AS self_count
    FROM $samples
    GROUP BY callsite_id
  )
  SELECT
    c.id,
    c.parent_id,
    c.name,
    c.mapping_name,
    c.source_file,
    c.line_number,
    IFNULL(m.self_count, 0) AS self_count
  FROM _callstacks_for_stack_profile_samples!(metrics) c
  LEFT JOIN metrics m USING (callsite_id)
);

CREATE PERFETTO MACRO _callstacks_self_to_cumulative(
  callstacks TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  SELECT a.*
  FROM _graph_aggregating_scan!(
    (
      SELECT id AS source_node_id, parent_id AS dest_node_id
      FROM $callstacks
      WHERE parent_id IS NOT NULL
    ),
    (
      SELECT p.id, p.self_count AS cumulative_count
      FROM $callstacks p
      LEFT JOIN $callstacks c ON c.parent_id = p.id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      WHERE c.id IS NULL
    ),
    (cumulative_count),
    (
      WITH agg AS (
        SELECT t.id, SUM(t.cumulative_count) AS child_count
        FROM $table t
        GROUP BY t.id
      )
      SELECT
        a.id,
        a.child_count + r.self_count as cumulative_count
      FROM agg a
      JOIN $callstacks r USING (id)
    )
  ) a
)
)_d3l1m1t3r_"
;

const char kChromeAndroidInput[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- This module defines tables with information about Android input pipeline
-- steps. The trace needs to be recorded with the 'view' atrace category.

-- On Android, input goes through the following path before getting to Chrome:
--  * InputReader thread (part of Android system_server)
--  * InputDispatcher thread (part of Android system_server)
--  * Browser Main thread (Chromium/Chrome)

-- In traces, each of these three steps have slices which are implicitly linked
-- together by an input id (part of slice name) assigned by the Android system.

-- The following queries correlate the three steps mentioned above
-- with the rest of the `LatencyInfo.Flow` pipeline.

-- InputReader is the first step in the input pipeline.
-- It is responsible for reading the input events from the system_server
-- process and sending them to the InputDispatcher (which then sends them
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- to the browser process).

CREATE PERFETTO TABLE _chrome_android_motion_input_reader_step(
-- Input reader step timestamp.
  ts TIMESTAMP,
  -- Input reader step duration.
  dur DURATION,
  -- Input reader step slice id.
  id LONG,
  -- Input id.
  android_input_id STRING,
   -- Input reader step utid.
  utid LONG
)
AS
SELECT
  ts,
  dur,
  id,
  -- Get the substring that starts with 'id=', remove the 'id=' and remove the trailing ')'.
  -- 'id=0x344bb0f9)' ->  '0x344bb0f9'
  TRIM(
    SUBSTR(
      SUBSTR(name, INSTR(name, 'id='))
    , 4),
  ')')
  AS android_input_id,
  utid
FROM thread_slice AS slice
WHERE
  name GLOB 'UnwantedInteractionBlocker::notifyMotion*';

-- InputDispatcher is the second step in the input pipeline.
-- It is responsible for dispatching the input events to the browser process.
CREATE PERFETTO TABLE _chrome_android_motion_input_dispatcher_step(
  -- Input dispatcher step timestamp.
  ts TIMESTAMP,
  -- Input dispatcher step duration.
  dur DURATION,
  -- Input dispatcher step slice id.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  id LONG,
  -- Input id.
  android_input_id STRING,
   -- Input dispatcher step utid.
  utid LONG
)
AS
SELECT
  ts,
  dur,
  id,
  TRIM(
  SUBSTR(
  SUBSTR(name, INSTR(name, 'id='))
  , 4), ')')
  AS android_input_id,
  utid
FROM thread_slice AS slice
WHERE
  name GLOB 'prepareDispatchCycleLocked*chrome*';

-- DeliverInputEvent is the third step in the input pipeline.
-- It is responsible for routing the input events within browser process.
CREATE PERFETTO TABLE chrome_deliver_android_input_event(
  -- Timestamp.
  ts TIMESTAMP,
  -- Touch move processing duration.
  dur DURATION,
  -- Utid.
  utid LONG,
  -- Input id (assigned by the system, used by InputReader and InputDispatcher)
  android_input_id STRING
) AS
SELECT
  slice.ts,
  slice.dur,
  slice.utid,
  SUBSTR(SUBSTR(name, INSTR(name, 'id=')), 4) AS android_input_id
FROM
  thread_slice AS slice
WHERE
  slice.name GLOB 'deliverInputEvent*';

-- Collects information about input reader, input dispatcher and
-- DeliverInputEvent steps for the given Android input id.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE chrome_android_input(
  -- Input id.
  android_input_id STRING,
  -- Input reader step start timestamp.
  input_reader_processing_start_ts TIMESTAMP,
  -- Input reader step end timestamp.
  input_reader_processing_end_ts TIMESTAMP,
  -- Input reader step utid.
  input_reader_utid LONG,
  -- Input dispatcher step start timestamp.
  input_dispatcher_processing_start_ts TIMESTAMP,
  -- Input dispatcher step end timestamp.
  input_dispatcher_processing_end_ts TIMESTAMP,
  -- Input dispatcher step utid.
  input_dispatcher_utid LONG,
  -- DeliverInputEvent step start timestamp.
  deliver_input_event_start_ts TIMESTAMP,
  -- DeliverInputEvent step end timestamp.
  deliver_input_event_end_ts TIMESTAMP,
  -- DeliverInputEvent step utid.
  deliver_input_event_utid LONG
) AS
SELECT
  _chrome_android_motion_input_reader_step.android_input_id,
  _chrome_android_motion_input_reader_step.ts AS input_reader_processing_start_ts,
  _chrome_android_motion_input_reader_step.ts +
  _chrome_android_motion_input_reader_step.dur AS input_reader_processing_end_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  _chrome_android_motion_input_reader_step.utid AS input_reader_utid,
  _chrome_android_motion_input_dispatcher_step.ts AS input_dispatcher_processing_start_ts,
  _chrome_android_motion_input_dispatcher_step.ts +
  _chrome_android_motion_input_dispatcher_step.dur AS input_dispatcher_processing_end_ts,
  _chrome_android_motion_input_dispatcher_step.utid AS input_dispatcher_utid,
  chrome_deliver_android_input_event.ts AS deliver_input_event_start_ts,
  chrome_deliver_android_input_event.ts +
  chrome_deliver_android_input_event.dur AS deliver_input_event_end_ts,
  chrome_deliver_android_input_event.utid AS deliver_input_event_utid
FROM
  _chrome_android_motion_input_reader_step
LEFT JOIN
  _chrome_android_motion_input_dispatcher_step USING(android_input_id)
LEFT JOIN
  chrome_deliver_android_input_event USING(android_input_id)

)_d3l1m1t3r_"
;

const char kChromeChromeScrolls[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.event_latency;
INCLUDE PERFETTO MODULE chrome.graphics_pipeline;
INCLUDE PERFETTO MODULE chrome.input;
INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Ties together input (`LatencyInfo.Flow`) and frame (`Graphics.Pipeline`)
-- trace events. Only covers input events of the `GESTURE_SCROLL_UPDATE_EVENT`
-- type.
CREATE PERFETTO TABLE _chrome_scroll_update_refs(
  -- Id of the Chrome input pipeline (`LatencyInfo.Flow`).
  scroll_update_latency_id LONG,
  -- Id of the touch move input corresponding to this scroll update.
  touch_move_latency_id LONG,
  -- Id of the frame pipeline (`Graphics.Pipeline`), pre-surface aggregation.
  surface_frame_id LONG,
  -- Id of the frame pipeline (`Graphics.Pipeline`), post-surface aggregation.
  display_trace_id LONG)
AS
SELECT
  scroll_update.latency_id AS scroll_update_latency_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  chrome_touch_move_to_scroll_update.touch_move_latency_id,
  chrome_graphics_pipeline_inputs_to_surface_frames.surface_frame_trace_id
    AS surface_frame_id,
  chrome_graphics_pipeline_aggregated_frames.display_trace_id
FROM
  chrome_inputs scroll_update
LEFT JOIN chrome_graphics_pipeline_inputs_to_surface_frames
  USING (latency_id)
LEFT JOIN chrome_graphics_pipeline_aggregated_frames
  ON
    chrome_graphics_pipeline_aggregated_frames.surface_frame_trace_id
    = chrome_graphics_pipeline_inputs_to_surface_frames.surface_frame_trace_id
LEFT JOIN chrome_touch_move_to_scroll_update
  ON
    chrome_touch_move_to_scroll_update.scroll_update_latency_id
    = scroll_update.latency_id
WHERE scroll_update.input_type = 'GESTURE_SCROLL_UPDATE_EVENT';

-- Timestamps and other related information for events during the critical path
-- for scrolling.
CREATE PERFETTO TABLE _scroll_update_timestamps_and_metadata
AS
SELECT
  refs.scroll_update_latency_id AS id,
  chrome_coalesced_input.presented_latency_id AS coalesced_into,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  chrome_event_latency.vsync_interval_ms AS vsync_interval_ms,
  chrome_event_latency.is_presented AS is_presented,
  chrome_event_latency.is_janky_scrolled_frame AS is_janky,
  chrome_event_latency.event_type
    = 'INERTIAL_GESTURE_SCROLL_UPDATE' AS is_inertial,
  chrome_event_latency.ts AS generation_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  touch_move_received_step.slice_id AS touch_move_received_slice_id,
  touch_move_received_step.ts AS touch_move_received_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  touch_move_processed_step.slice_id AS touch_move_processed_slice_id,
  touch_move_processed_step.ts AS touch_move_processed_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  scroll_update_created_step.slice_id AS scroll_update_created_slice_id,
  scroll_update_created_step.utid AS browser_utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  scroll_update_created_step.ts AS scroll_update_created_ts,
  scroll_update_created_step.ts + scroll_update_created_step.dur
    AS scroll_update_created_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  compositor_dispatch_step.slice_id AS compositor_dispatch_slice_id,
  compositor_dispatch_step.task_start_time_ts
    AS compositor_dispatch_task_ts,
  compositor_dispatch_step.ts AS compositor_dispatch_ts,
  compositor_dispatch_step.ts + compositor_dispatch_step.dur
    AS compositor_dispatch_end_ts,
  compositor_dispatch_step.utid AS compositor_utid,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  compositor_resample_step.slice_id AS compositor_resample_slice_id,
  compositor_resample_step.task_start_time_ts
    AS compositor_resample_task_ts,
  compositor_resample_step.ts AS compositor_resample_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  compositor_coalesced_input_handled_step.slice_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS compositor_coalesced_input_handled_slice_id,
  compositor_coalesced_input_handled_step.ts
    AS compositor_coalesced_input_handled_ts,
  compositor_coalesced_input_handled_step.ts
    + compositor_coalesced_input_handled_step.dur
    AS compositor_coalesced_input_handled_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  compositor_generate_compositor_frame_step.id
    AS compositor_generate_compositor_frame_slice_id,
  compositor_generate_compositor_frame_step.task_start_time_ts
    AS compositor_generate_compositor_frame_task_ts,
  compositor_generate_compositor_frame_step.ts
    AS compositor_generate_compositor_frame_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  compositor_submit_compositor_frame_step.id
    AS compositor_submit_compositor_frame_slice_id,
  compositor_submit_compositor_frame_step.ts
    AS compositor_submit_compositor_frame_ts,
  compositor_submit_compositor_frame_step.ts
    + compositor_submit_compositor_frame_step.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS compositor_submit_compositor_frame_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_receive_compositor_frame_step.id
    AS viz_receive_compositor_frame_slice_id,
  viz_receive_compositor_frame_step.task_start_time_ts
    AS viz_receive_compositor_frame_task_ts,
  viz_receive_compositor_frame_step.ts AS viz_receive_compositor_frame_ts,
  viz_receive_compositor_frame_step.ts
    + viz_receive_compositor_frame_step.dur
    AS viz_receive_compositor_frame_end_ts,
  viz_receive_compositor_frame_step.utid AS viz_compositor_utid,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_draw_and_swap_step.id AS viz_draw_and_swap_slice_id,
  viz_draw_and_swap_step.task_start_time_ts
    AS viz_draw_and_swap_task_ts,
  viz_draw_and_swap_step.ts AS viz_draw_and_swap_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_send_buffer_swap_step.id AS viz_send_buffer_swap_slice_id,
  viz_send_buffer_swap_step.ts + viz_send_buffer_swap_step.dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS viz_send_buffer_swap_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_swap_buffers_step.id AS viz_swap_buffers_slice_id,
  viz_swap_buffers_step.task_start_time_ts AS viz_swap_buffers_task_ts,
  viz_swap_buffers_step.ts AS viz_swap_buffers_ts,
  viz_swap_buffers_step.ts + viz_swap_buffers_step.dur
    AS viz_swap_buffers_end_ts,
  viz_swap_buffers_step.utid AS viz_gpu_thread_utid,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  chrome_event_latency.buffer_available_timestamp,
  chrome_event_latency.buffer_ready_timestamp,
  chrome_event_latency.latch_timestamp,
  chrome_event_latency.swap_end_timestamp,
  chrome_event_latency.presentation_timestamp
FROM _chrome_scroll_update_refs refs
LEFT JOIN chrome_coalesced_inputs chrome_coalesced_input
  ON chrome_coalesced_input.coalesced_latency_id = refs.scroll_update_latency_id
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_event_latencies chrome_event_latency
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ON chrome_event_latency.scroll_update_id = refs.scroll_update_latency_id
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps touch_move_received_step
  ON
    refs.touch_move_latency_id = touch_move_received_step.latency_id
    AND touch_move_received_step.step = 'STEP_SEND_INPUT_EVENT_UI'
    AND touch_move_received_step.input_type = 'TOUCH_MOVE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps touch_move_processed_step
  ON
    touch_move_processed_step.latency_id = refs.touch_move_latency_id
    AND touch_move_processed_step.step = 'STEP_TOUCH_EVENT_HANDLED'
    AND touch_move_processed_step.input_type = 'TOUCH_MOVE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps scroll_update_created_step
  ON
    scroll_update_created_step.latency_id = refs.scroll_update_latency_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND scroll_update_created_step.step = 'STEP_SEND_INPUT_EVENT_UI'
    AND scroll_update_created_step.input_type
      = 'GESTURE_SCROLL_UPDATE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps compositor_dispatch_step
  ON
    compositor_dispatch_step.latency_id = refs.scroll_update_latency_id
    AND compositor_dispatch_step.step = 'STEP_HANDLE_INPUT_EVENT_IMPL'
    AND compositor_dispatch_step.input_type
      = 'GESTURE_SCROLL_UPDATE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps compositor_resample_step
  ON
    compositor_resample_step.latency_id = refs.scroll_update_latency_id
    AND compositor_resample_step.step = 'STEP_RESAMPLE_SCROLL_EVENTS'
    AND compositor_resample_step.input_type
      = 'GESTURE_SCROLL_UPDATE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN chrome_input_pipeline_steps compositor_coalesced_input_handled_step
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ON
    compositor_coalesced_input_handled_step.latency_id
      = refs.scroll_update_latency_id
    AND compositor_coalesced_input_handled_step.step
      = 'STEP_DID_HANDLE_INPUT_AND_OVERSCROLL'
    AND compositor_coalesced_input_handled_step.input_type
      = 'GESTURE_SCROLL_UPDATE_EVENT'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN
  chrome_graphics_pipeline_surface_frame_steps
    compositor_generate_compositor_frame_step
  ON
    compositor_generate_compositor_frame_step.surface_frame_trace_id
      = refs.surface_frame_id
    AND compositor_generate_compositor_frame_step.step
      = 'STEP_GENERATE_COMPOSITOR_FRAME'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN
  chrome_graphics_pipeline_surface_frame_steps
    compositor_submit_compositor_frame_step
  ON
    compositor_submit_compositor_frame_step.surface_frame_trace_id
      = refs.surface_frame_id
    AND compositor_submit_compositor_frame_step.step
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      = 'STEP_SUBMIT_COMPOSITOR_FRAME'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN
  chrome_graphics_pipeline_surface_frame_steps
    viz_receive_compositor_frame_step
  ON
    viz_receive_compositor_frame_step.surface_frame_trace_id
      = refs.surface_frame_id
    AND viz_receive_compositor_frame_step.step
      = 'STEP_RECEIVE_COMPOSITOR_FRAME'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN
  chrome_graphics_pipeline_display_frame_steps viz_draw_and_swap_step
  ON
    viz_draw_and_swap_step.display_trace_id = refs.display_trace_id
    AND viz_draw_and_swap_step.step = 'STEP_DRAW_AND_SWAP'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
LEFT JOIN
  chrome_graphics_pipeline_display_frame_steps viz_send_buffer_swap_step
  ON
    viz_send_buffer_swap_step.display_trace_id = refs.display_trace_id
    AND viz_send_buffer_swap_step.step = 'STEP_SEND_BUFFER_SWAP'
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN chrome_graphics_pipeline_display_frame_steps viz_swap_buffers_step
  ON
    viz_swap_buffers_step.display_trace_id = refs.display_trace_id
    AND viz_swap_buffers_step.step = 'STEP_BUFFER_SWAP_POST_SUBMIT';

-- Intermediate helper table with timestamps and slice ids for the critical path
-- stages during scrolling.
CREATE PERFETTO TABLE _scroll_update_durations_and_metadata
AS
SELECT
  id,
  vsync_interval_ms,
  is_presented,
  is_janky,
  is_inertial,
  coalesced_into IS NOT NULL AS is_coalesced,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  browser_utid,
  touch_move_received_slice_id,
  -- Timestamps
  generation_ts,
  touch_move_received_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  scroll_update_created_slice_id,
  -- Timestamps
  scroll_update_created_ts,
  scroll_update_created_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  compositor_utid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  compositor_dispatch_slice_id,
  -- Timestamps
  COALESCE(compositor_dispatch_task_ts, compositor_dispatch_ts)
    AS compositor_dispatch_ts,
  compositor_dispatch_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  compositor_resample_slice_id,
  compositor_coalesced_input_handled_slice_id,
  -- Timestamps
  COALESCE(
    compositor_resample_task_ts,
    compositor_resample_ts,
    compositor_coalesced_input_handled_ts) AS compositor_on_begin_frame_ts,
  compositor_coalesced_input_handled_end_ts AS compositor_on_begin_frame_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  compositor_generate_compositor_frame_slice_id,
  -- Timestamps
  COALESCE(
    compositor_generate_compositor_frame_task_ts,
    compositor_generate_compositor_frame_ts)
    AS compositor_generate_compositor_frame_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  compositor_submit_compositor_frame_slice_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Timestamps
  compositor_submit_compositor_frame_ts,
  compositor_submit_compositor_frame_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  viz_compositor_utid,
  viz_receive_compositor_frame_slice_id,
  -- Timestamps
  COALESCE(
    viz_receive_compositor_frame_task_ts, viz_receive_compositor_frame_ts)
    AS viz_receive_compositor_frame_ts,
  viz_receive_compositor_frame_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  viz_draw_and_swap_slice_id,
  -- Timestamps
  COALESCE(viz_draw_and_swap_task_ts, viz_draw_and_swap_ts)
    AS viz_draw_and_swap_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  viz_send_buffer_swap_slice_id,
  -- Timestamps
  viz_send_buffer_swap_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Ids
  viz_gpu_thread_utid,
  viz_swap_buffers_slice_id,
  -- Timestamps
  COALESCE(viz_swap_buffers_task_ts, viz_swap_buffers_ts)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS viz_swap_buffers_ts,
  viz_swap_buffers_end_ts,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Timestamps
  latch_timestamp,
  swap_end_timestamp,
  presentation_timestamp
FROM _scroll_update_timestamps_and_metadata;

-- Defines slices for all of the individual scrolls in a trace based on the
-- LatencyInfo-based scroll definition.
--
-- NOTE: this view of top level scrolls is based on the LatencyInfo definition
-- of a scroll, which differs subtly from the definition based on
-- EventLatencies.
-- TODO(b/278684408): add support for tracking scrolls across multiple Chrome/
-- WebView instances. Currently gesture_scroll_id unique within an instance, but
-- is not unique across multiple instances. Switching to an EventLatency based
-- definition of scrolls should resolve this.
CREATE PERFETTO TABLE chrome_scrolls(
  -- The unique identifier of the scroll.
  id LONG,
  -- The start timestamp of the scroll.
  ts TIMESTAMP,
  -- The duration of the scroll.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_BEGIN type for the
  -- corresponding scroll id.
  gesture_scroll_begin_ts TIMESTAMP,
  -- The earliest timestamp of the EventLatency slice of the GESTURE_SCROLL_END type /
  -- the latest timestamp of the EventLatency slice of the GESTURE_SCROLL_UPDATE type for the
  -- corresponding scroll id.
  gesture_scroll_end_ts TIMESTAMP
) AS
WITH all_scrolls AS (
  SELECT
    event_type AS name,
    ts,
    dur,
    scroll_id
  FROM chrome_gesture_scroll_events
),
scroll_starts AS (
  SELECT
    scroll_id,
    MIN(ts) AS gesture_scroll_begin_ts
  FROM all_scrolls
  WHERE name = 'GESTURE_SCROLL_BEGIN'
  GROUP BY scroll_id
),
scroll_ends AS (
  SELECT
    scroll_id,
    MAX(ts) AS gesture_scroll_end_ts
  FROM all_scrolls
  WHERE name IN (
    'GESTURE_SCROLL_UPDATE',
    'FIRST_GESTURE_SCROLL_UPDATE',
    'INERTIAL_GESTURE_SCROLL_UPDATE',
    'GESTURE_SCROLL_END'
  )
  GROUP BY scroll_id
)
SELECT
  sa.scroll_id AS id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(ts) AS ts,
  cast_int!(MAX(ts + dur) - MIN(ts)) AS dur,
  ss.gesture_scroll_begin_ts AS gesture_scroll_begin_ts,
  se.gesture_scroll_end_ts AS gesture_scroll_end_ts
FROM all_scrolls sa
  LEFT JOIN scroll_starts ss ON
    sa.scroll_id = ss.scroll_id
  LEFT JOIN scroll_ends se ON
    sa.scroll_id = se.scroll_id
GROUP BY sa.scroll_id;

-- Timestamps and durations for the critical path stages during scrolling.
CREATE PERFETTO TABLE chrome_scroll_update_info(
  -- Id of the `LatencyInfo.Flow` slices corresponding to this scroll event.
  id LONG,
  -- Vsync interval (in milliseconds).
  vsync_interval_ms DOUBLE,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- Whether the corresponding frame is janky. This comes directly from
  -- `perfetto.protos.EventLatency`.
  is_janky BOOL,
  -- Whether the corresponding scroll is inertial (fling).
  -- If this is `true`, "generation" and "touch_move" related timestamps and
  -- durations will be null.
  is_inertial BOOL,
  -- Whether the corresponding input event was coalesced into another.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_coalesced BOOL,
  -- Input generation timestamp (from the Android system).
  generation_ts TIMESTAMP,
  -- Duration from input generation to when the browser received the input.
  generation_to_browser_main_dur DURATION,
  -- Utid for the browser main thread.
  browser_utid LONG,
  -- Slice id for the `STEP_SEND_INPUT_EVENT_UI` slice for the touch move.
  touch_move_received_slice_id LONG,
  -- Timestamp for the `STEP_SEND_INPUT_EVENT_UI` slice for the touch move.
  touch_move_received_ts TIMESTAMP,
  -- Duration for processing  a `TouchMove` event.
  touch_move_processing_dur DURATION,
  -- Slice id for the `STEP_SEND_INPUT_EVENT_UI` slice for the gesture scroll.
  scroll_update_created_slice_id LONG,
  -- Timestamp for the `STEP_SEND_INPUT_EVENT_UI` slice for the gesture scroll.
  scroll_update_created_ts TIMESTAMP,
  -- Duration for creating a `GestureScrollUpdate` from a `TouchMove` event.
  scroll_update_processing_dur DURATION,
  -- End timestamp for the `STEP_SEND_INPUT_EVENT_UI` slice for the above.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  scroll_update_created_end_ts TIMESTAMP,
  -- Duration between the browser and compositor dispatch.
  browser_to_compositor_delay_dur DURATION,
  -- Utid for the renderer compositor thread.
  compositor_utid LONG,
  -- Slice id for the `STEP_HANDLE_INPUT_EVENT_IMPL` slice.
  compositor_dispatch_slice_id LONG,
  -- Timestamp for the `STEP_HANDLE_INPUT_EVENT_IMPL` slice or the
  -- containing task (if available).
  compositor_dispatch_ts TIMESTAMP,
  -- Duration for the compositor dispatch itself.
  compositor_dispatch_dur DURATION,
  -- End timestamp for the `STEP_HANDLE_INPUT_EVENT_IMPL` slice.
  compositor_dispatch_end_ts TIMESTAMP,
  -- Duration between compositor dispatch and input resampling work.
  compositor_dispatch_to_on_begin_frame_delay_dur DURATION,
  -- Slice id for the `STEP_RESAMPLE_SCROLL_EVENTS` slice.
  compositor_resample_slice_id LONG,
  -- Slice id for the `STEP_DID_HANDLE_INPUT_AND_OVERSCROLL` slice.
  compositor_coalesced_input_handled_slice_id LONG,
  -- Start timestamp for work done on the input during "OnBeginFrame".
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  compositor_on_begin_frame_ts TIMESTAMP,
  -- Duration of the "OnBeginFrame" work for this input.
  compositor_on_begin_frame_dur DURATION,
  -- End timestamp for work done on the input during "OnBeginFrame".
  compositor_on_begin_frame_end_ts TIMESTAMP,
  -- Delay until the compositor work for generating the frame begins.
  compositor_on_begin_frame_to_generation_delay_dur DURATION,
  -- Slice id for the `STEP_GENERATE_COMPOSITOR_FRAME` slice.
  compositor_generate_compositor_frame_slice_id LONG,
  -- Timestamp for the `STEP_GENERATE_COMPOSITOR_FRAME` slice or the
  -- containing task (if available).
  compositor_generate_compositor_frame_ts TIMESTAMP,
  -- Duration between generating and submitting the compositor frame.
  compositor_generate_frame_to_submit_frame_dur DURATION,
  -- Slice id for the `STEP_SUBMIT_COMPOSITOR_FRAME` slice.
  compositor_submit_compositor_frame_slice_id LONG,
  -- Timestamp for the `STEP_SUBMIT_COMPOSITOR_FRAME` slice.
  compositor_submit_compositor_frame_ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Duration for submitting the compositor frame (to viz).
  compositor_submit_frame_dur DURATION,
  -- End timestamp for the `STEP_SUBMIT_COMPOSITOR_FRAME` slice.
  compositor_submit_compositor_frame_end_ts TIMESTAMP,
  -- Delay when a compositor frame is sent from the renderer to viz.
  compositor_to_viz_delay_dur DURATION,
  -- Utid for the viz compositor thread.
  viz_compositor_utid LONG,
  -- Slice id for the `STEP_RECEIVE_COMPOSITOR_FRAME` slice.
  viz_receive_compositor_frame_slice_id LONG,
  -- Timestamp for the `STEP_RECEIVE_COMPOSITOR_FRAME` slice or the
  -- containing task (if available).
  viz_receive_compositor_frame_ts TIMESTAMP,
  -- Duration of the viz work done on receiving the compositor frame.
  viz_receive_compositor_frame_dur DURATION,
  -- End timestamp for the `STEP_RECEIVE_COMPOSITOR_FRAME` slice.
  viz_receive_compositor_frame_end_ts TIMESTAMP,
  -- Duration between viz receiving the compositor frame to frame draw.
  viz_wait_for_draw_dur DURATION,
  -- Slice id for the `STEP_DRAW_AND_SWAP` slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  viz_draw_and_swap_slice_id LONG,
  -- Timestamp for the `STEP_DRAW_AND_SWAP` slice or the
  -- containing task (if available).
  viz_draw_and_swap_ts TIMESTAMP,
  -- Duration for the viz drawing/swapping work for this frame.
  viz_draw_and_swap_dur DURATION,
  -- Slice id for the `STEP_SEND_BUFFER_SWAP` slice.
  viz_send_buffer_swap_slice_id LONG,
  -- End timestamp for the `STEP_SEND_BUFFER_SWAP` slice.
  viz_send_buffer_swap_end_ts TIMESTAMP,
  -- Delay between viz work on compositor thread and `CompositorGpuThread`.
  viz_to_gpu_delay_dur DURATION,
  -- Utid for the viz `CompositorGpuThread`.
  viz_gpu_thread_utid LONG,
  -- Slice id for the `STEP_BUFFER_SWAP_POST_SUBMIT` slice.
  viz_swap_buffers_slice_id LONG,
  -- Timestamp for the `STEP_BUFFER_SWAP_POST_SUBMIT` slice or the
  -- containing task (if available).
  viz_swap_buffers_ts TIMESTAMP,
  -- Duration of frame buffer swapping work on viz.
  viz_swap_buffers_dur DURATION,
  -- End timestamp for the `STEP_BUFFER_SWAP_POST_SUBMIT` slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  viz_swap_buffers_end_ts TIMESTAMP,
  -- Duration of `EventLatency`'s `BufferReadyToLatch` step.
  viz_swap_buffers_to_latch_dur DURATION,
  -- Timestamp for `EventLatency`'s `LatchToSwapEnd` step.
  latch_timestamp TIMESTAMP,
  -- Duration of `EventLatency`'s `LatchToSwapEnd` step.
  viz_latch_to_swap_end_dur DURATION,
  -- Timestamp for `EventLatency`'s `SwapEndToPresentationCompositorFrame` step.
  swap_end_timestamp TIMESTAMP,
  -- Duration of `EventLatency`'s `SwapEndToPresentationCompositorFrame` step.
  swap_end_to_presentation_dur DURATION,
  -- Presentation timestamp for the frame.
  presentation_timestamp TIMESTAMP)
AS
SELECT
  id,
  -- TODO(b:380868337): This is sometimes unexpectedly 0; check/fix this.
  vsync_interval_ms,
  is_presented,
  is_janky,
  is_inertial,
  -- TODO(b:380868337): Check/fix this for flings.
  is_coalesced,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- No applicable utid (duration between two threads).
  -- No applicable slice id (duration between two threads).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  generation_ts,
  touch_move_received_ts - generation_ts AS generation_to_browser_main_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  browser_utid,
  touch_move_received_slice_id,
  touch_move_received_ts,
  scroll_update_created_ts - touch_move_received_ts
    AS touch_move_processing_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `browser_utid`.
  scroll_update_created_slice_id,
  scroll_update_created_ts,
  scroll_update_created_end_ts - scroll_update_created_ts
    AS scroll_update_processing_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- No applicable utid (duration between two threads).
  -- No applicable slice id (duration between two threads).
  scroll_update_created_end_ts,
  -- TODO(b:380868337): This is sometimes negative; check/fix this.
  compositor_dispatch_ts - scroll_update_created_end_ts
    AS browser_to_compositor_delay_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  compositor_utid,
  compositor_dispatch_slice_id,
  compositor_dispatch_ts,
  compositor_dispatch_end_ts - compositor_dispatch_ts
    AS compositor_dispatch_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `compositor_utid`.
  -- No applicable slice id (duration between two slices).
  compositor_dispatch_end_ts,
  -- TODO(b:380868337): This is sometimes negative; check/fix this.
  compositor_on_begin_frame_ts - compositor_dispatch_end_ts
    AS compositor_dispatch_to_on_begin_frame_delay_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `compositor_utid`.
  -- `compositor_on_begin_frame_dur` can depend on two slices.
  compositor_resample_slice_id,
  compositor_coalesced_input_handled_slice_id,
  compositor_on_begin_frame_ts,
  compositor_on_begin_frame_end_ts - compositor_on_begin_frame_ts
    AS compositor_on_begin_frame_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- On `compositor_utid`.
  -- No applicable slice id (duration between two slices).
  compositor_on_begin_frame_end_ts,
  compositor_generate_compositor_frame_ts - compositor_on_begin_frame_end_ts
    AS compositor_on_begin_frame_to_generation_delay_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `compositor_utid`.
  compositor_generate_compositor_frame_slice_id,
  -- TODO(b:380868337): This is sometimes unexpectedly null; check/fix this.
  compositor_generate_compositor_frame_ts,
  compositor_submit_compositor_frame_ts
    - compositor_generate_compositor_frame_ts
    AS compositor_generate_frame_to_submit_frame_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `compositor_utid`.
  compositor_submit_compositor_frame_slice_id,
  compositor_submit_compositor_frame_ts,
  compositor_submit_compositor_frame_end_ts
    - compositor_submit_compositor_frame_ts AS compositor_submit_frame_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- No applicable utid (duration between two threads).
  -- No applicable slice id (duration between two threads).
  compositor_submit_compositor_frame_end_ts,
  -- TODO(b:380868337): This is sometimes negative; check/fix this.
  viz_receive_compositor_frame_ts - compositor_submit_compositor_frame_end_ts
    AS compositor_to_viz_delay_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_compositor_utid,
  viz_receive_compositor_frame_slice_id,
  viz_receive_compositor_frame_ts,
  viz_receive_compositor_frame_end_ts - viz_receive_compositor_frame_ts
    AS viz_receive_compositor_frame_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- On `viz_compositor_utid`.
  -- No applicable slice id (duration between two slices).
  viz_receive_compositor_frame_end_ts,
  viz_draw_and_swap_ts - viz_receive_compositor_frame_end_ts
    AS viz_wait_for_draw_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- On `viz_compositor_utid`.
  viz_draw_and_swap_slice_id,
  viz_draw_and_swap_ts,
  viz_send_buffer_swap_end_ts - viz_draw_and_swap_ts AS viz_draw_and_swap_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- No applicable utid (duration between two threads).
  viz_send_buffer_swap_slice_id,
  viz_send_buffer_swap_end_ts,
  viz_swap_buffers_ts - viz_send_buffer_swap_end_ts AS viz_to_gpu_delay_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_gpu_thread_utid,
  viz_swap_buffers_slice_id,
  viz_swap_buffers_ts,
  viz_swap_buffers_end_ts - viz_swap_buffers_ts AS viz_swap_buffers_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  viz_swap_buffers_end_ts,
  latch_timestamp - viz_swap_buffers_end_ts AS viz_swap_buffers_to_latch_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  latch_timestamp,
  swap_end_timestamp - latch_timestamp AS viz_latch_to_swap_end_dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  swap_end_timestamp,
  presentation_timestamp - swap_end_timestamp AS swap_end_to_presentation_dur,
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  presentation_timestamp
FROM _scroll_update_durations_and_metadata;

)_d3l1m1t3r_"
;

const char kChromeCpuPowerups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Find causes for CPUs powering up.
--
-- The scripts below analyse traces with the following tracing options
-- enabled:
--
--  - Linux kernel:
---    "power/*", "sched/*", "task/*",
--  - Chromium:
--      "toplevel", "toplevel.flow".

-- Noteworthy tables:
--
--   chrome_cpu_power_first_toplevel_slice_after_powerup :: The top-level
--      slices that ran after a CPU power-up.

-- The CPU power transitions in the trace.
-- Power states are encoded as non-negative integers, with zero representing
-- full-power operation and positive values representing increasingly deep
-- sleep states.
--
-- On ARM systems, power state 1 represents the WFI (Wait For Interrupt) sleep
-- state that the CPU enters while idle.
CREATE PERFETTO VIEW chrome_cpu_power_slice(
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- The CPU on which the transition occurred
  cpu LONG,
  -- The power state that the CPU was in at time 'ts' for duration 'dur'.
  power_state LONG,
  -- The power state that the CPU was previously in.
  previous_power_state LONG,
  -- A unique ID for the CPU power-up.
  powerup_id LONG
) AS
  WITH cpu_power_states AS (
    SELECT
      c.id AS id,
      cct.cpu AS cpu,
      c.ts,
      -- Encode the 'value' field as a power state.
      cast_int!((CASE c.value WHEN 4294967295 THEN 0 ELSE c.value + 1 END)) AS power_state
    FROM counter AS c
    JOIN cpu_counter_track AS cct
      ON c.track_id = cct.id
    WHERE cct.name = 'cpuidle'
  )
  SELECT *
  FROM (
    SELECT
      ts,
      LEAD(ts) OVER (PARTITION BY cpu ORDER BY ts ASC) - ts
        AS dur,
      cpu,
      power_state,
      LAG(power_state) OVER (PARTITION BY cpu ORDER BY ts ASC)
        AS previous_power_state,
      id AS powerup_id
    FROM cpu_power_states
  )
  WHERE dur IS NOT NULL
    AND previous_power_state IS NOT NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND power_state = 0                      -- Track full-power states.
    AND power_state != previous_power_state  -- Skip missing spans.
    ORDER BY ts ASC;

-- We do not want scheduler slices with utid = 0 (the 'swapper' kernel thread).
CREATE PERFETTO VIEW _cpu_power_valid_sched_slice AS
  SELECT *
  FROM sched_slice
  WHERE utid != 0;

-- Join scheduler slices with the spans with CPU power slices.
--
-- There multiple scheduler slices could fall into one CPU power slice.
--
---  CPU Power:
--   |----------------------------|....................|---------|
--   A       <cpu active>         B     <cpu idling>   C         D

--   Scheduler slices on that CPU:
--     |-----T1-----| |....T2....|                      |---T3--|
--     E            F G          H                      I       J
--
-- Here threads T1 and T2 executed in CPU power slice [A,B].  The
-- time between F and G represents time between threads in the kernel.
CREATE VIRTUAL TABLE _cpu_power_and_sched_slice
USING
  SPAN_JOIN(chrome_cpu_power_slice PARTITIONED cpu,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(            _cpu_power_valid_sched_slice PARTITIONED cpu);

-- The Linux scheduler slices that executed immediately after a
-- CPU power up.
CREATE PERFETTO TABLE chrome_cpu_power_first_sched_slice_after_powerup(
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The cpu on which the slice executed.
  cpu LONG,
  -- Id for the sched_slice table.
  sched_id LONG,
  -- Unique id for the thread that ran within the slice.
  utid LONG,
  -- The CPU's power state before this slice.
  previous_power_state LONG,
  -- A unique ID for the CPU power-up.
  powerup_id LONG
) AS
SELECT
  ts,
  dur,
  cpu,
  id AS sched_id,
  utid,
  previous_power_state,
  powerup_id
FROM _cpu_power_and_sched_slice
WHERE power_state = 0     -- Power-ups only.
GROUP BY cpu, powerup_id
HAVING ts = MIN(ts)       -- There will only be one MIN sched slice
                          -- per CPU power up.
ORDER BY ts ASC;

-- A view joining thread tracks and top-level slices.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- This view is intended to be intersected by time with the scheduler
-- slices scheduled after a CPU power up.
--
--   utid      Thread unique id.
--   slice_id  The slice_id for the top-level slice.
--   ts        Starting timestamp for the slice.
--   dur       The duration for the slice.
CREATE PERFETTO VIEW _cpu_power_thread_and_toplevel_slice AS
  SELECT
    t.utid AS utid,
    s.id AS slice_id,
    s.ts,
    s.dur
  FROM slice AS s
  JOIN thread_track AS t
    ON s.track_id = t.id
  WHERE s.depth = 0   -- Top-level slices only.
  ORDER BY ts ASC;

CREATE VIRTUAL TABLE _chrome_cpu_power_post_powerup_slice_sj
USING
  SPAN_JOIN(chrome_cpu_power_first_sched_slice_after_powerup PARTITIONED utid,
            _cpu_power_thread_and_toplevel_slice PARTITIONED utid);

-- A table holding the slices that executed within the scheduler
-- slice that ran on a CPU immediately after power-up.
CREATE PERFETTO TABLE chrome_cpu_power_post_powerup_slice(
  -- Timestamp of the resulting slice
  ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Duration of the slice.
  dur DURATION,
  -- The CPU the sched slice ran on.
  cpu LONG,
  -- Unique thread id for the slice.
  utid LONG,
  -- 'id' field from the sched_slice table.
  sched_id LONG,
  -- Id of the top-level slice for this (sched) slice.
  slice_id LONG,
  -- Previous power state.
  previous_power_state LONG,
  -- Id of the powerup.
  powerup_id LONG
) AS
SELECT * FROM _chrome_cpu_power_post_powerup_slice_sj;

-- The first top-level slice that ran after a CPU power-up.
CREATE PERFETTO VIEW chrome_cpu_power_first_toplevel_slice_after_powerup(
  -- ID of the slice in the slice table.
  slice_id LONG,
  -- The power state of the CPU prior to power-up.
  previous_power_state LONG
) AS
  SELECT slice_id, previous_power_state
  FROM chrome_cpu_power_post_powerup_slice
  GROUP BY cpu, powerup_id
  HAVING ts = MIN(ts)
  ORDER BY ts ASC;

)_d3l1m1t3r_"
;

const char kChromeEventLatency[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Finds the start timestamp for a given slice's descendant with a given name.
-- If there are multiple descendants with a given name, the function will return
-- the first one, so it's most useful when working with a timeline broken down
-- into phases, where each subphase can happen only once.
CREATE PERFETTO FUNCTION _descendant_slice_begin(
  -- Id of the parent slice.
  parent_id LONG,
  -- Name of the child with the desired start TS.
  child_name STRING
)
-- Start timestamp of the child or NULL if it doesn't exist.
RETURNS LONG AS
SELECT s.ts
FROM descendant_slice($parent_id) s
WHERE s.name GLOB $child_name
LIMIT 1;

-- Finds the end timestamp for a given slice's descendant with a given name.
-- If there are multiple descendants with a given name, the function will return
-- the first one, so it's most useful when working with a timeline broken down
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- into phases, where each subphase can happen only once.
CREATE PERFETTO FUNCTION _descendant_slice_end(
  -- Id of the parent slice.
  parent_id LONG,
  -- Name of the child with the desired end TS.
  child_name STRING
)
-- End timestamp of the child or NULL if it doesn't exist.
RETURNS LONG AS
SELECT
  CASE WHEN s.dur
    IS NOT -1 THEN s.ts + s.dur
    ELSE NULL
  END
FROM descendant_slice($parent_id) s
WHERE s.name GLOB $child_name
LIMIT 1;

-- Checks if slice has a descendant with provided name.
CREATE PERFETTO FUNCTION _has_descendant_slice_with_name(
  -- Id of the slice to check descendants of.
  id LONG,
  -- Name of potential descendant slice.
  descendant_name STRING
)
-- Whether `descendant_name` is a name of an descendant slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM descendant_slice($id)
  WHERE name = $descendant_name
  LIMIT 1
);

-- Returns the presentation timestamp for a given EventLatency slice.
-- This is either the end of
-- SwapEndToPresentationCompositorFrame (if it exists),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the end of LatchToPresentation (if it exists),
-- the end of SwapStartToPresentation (if it exists),
-- or the end of LatchToSwapEnd (workaround in older Chrome versions).
CREATE PERFETTO FUNCTION _get_presentation_timestamp(
  -- The slice id which we need the presentation timestamp for.
  id LONG
)
RETURNS LONG AS
SELECT
  COALESCE(_descendant_slice_end(id, 'SwapEndToPresentationCompositorFrame'),
    _descendant_slice_end(id, '*ToPresentation'),
    _descendant_slice_end(id, 'LatchToSwapEnd'))
FROM slice WHERE $id = id;

-- All EventLatency slices.
CREATE PERFETTO TABLE chrome_event_latencies(
  -- Slice Id for the EventLatency scroll event.
  id LONG,
  -- Slice name.
  name STRING,
  -- The start timestamp of the scroll.
  ts TIMESTAMP,
  -- The duration of the scroll.
  dur DURATION,
  -- The id of the scroll update event.
  scroll_update_id LONG,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- EventLatency event type.
  event_type STRING,
  -- Perfetto track this slice is found on.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  track_id LONG,
  -- Vsync interval (in milliseconds).
  vsync_interval_ms DOUBLE,
  -- Whether the corresponding frame is janky.
  is_janky_scrolled_frame BOOL,
  -- Timestamp of the BufferAvailableToBufferReady substage.
  buffer_available_timestamp LONG,
  -- Timestamp of the BufferReadyToLatch substage.
  buffer_ready_timestamp LONG,
  -- Timestamp of the LatchToSwapEnd substage.
  latch_timestamp LONG,
  -- Timestamp of the SwapEndToPresentationCompositorFrame substage.
  swap_end_timestamp LONG,
  -- Frame presentation timestamp aka the timestamp of the
  -- SwapEndToPresentationCompositorFrame substage.
  -- TODO(b/341047059): temporarily use LatchToSwapEnd as a workaround if
  -- SwapEndToPresentationCompositorFrame is missing due to b/247542163.
  presentation_timestamp LONG
) AS
SELECT
  slice.id,
  slice.name,
  slice.ts,
  slice.dur,
  EXTRACT_arg(arg_set_id, 'event_latency.event_latency_id') AS scroll_update_id,
  _has_descendant_slice_with_name(
    slice.id,
    'SubmitCompositorFrameToPresentationCompositorFrame')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS is_presented,
  EXTRACT_ARG(arg_set_id, 'event_latency.event_type') AS event_type,
  slice.track_id,
  EXTRACT_ARG(arg_set_id, 'event_latency.vsync_interval_ms')
    AS vsync_interval_ms,
  COALESCE(EXTRACT_ARG(arg_set_id, 'event_latency.is_janky_scrolled_frame'), 0)
    AS is_janky_scrolled_frame,
  _descendant_slice_begin(slice.id, 'BufferAvailableToBufferReady')
    AS buffer_available_timestamp,
  _descendant_slice_begin(slice.id, 'BufferReadyToLatch')
    AS buffer_ready_timestamp,
  _descendant_slice_begin(slice.id, 'LatchToSwapEnd') AS latch_timestamp,
  _descendant_slice_begin(slice.id, 'SwapEndToPresentationCompositorFrame')
    AS swap_end_timestamp,
  _get_presentation_timestamp(slice.id) AS presentation_timestamp
FROM slice
WHERE name = 'EventLatency';

-- All EventLatency slices that are relevant to scrolling, including presented
-- pinches. Materialized to reduce how many times we query slice.
CREATE PERFETTO TABLE _gesture_scroll_events_no_scroll_id
AS
SELECT
  name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts,
  dur,
  id,
  scroll_update_id,
  is_presented,
  _get_presentation_timestamp(chrome_event_latencies.id)
  AS presentation_timestamp,
  event_type,
  track_id
FROM chrome_event_latencies
WHERE (
  event_type GLOB '*GESTURE_SCROLL*'
  -- Pinches are only relevant if the frame was presented.
  OR (event_type GLOB '*GESTURE_PINCH_UPDATE'
    AND _has_descendant_slice_with_name(
      id,
      'SubmitCompositorFrameToPresentationCompositorFrame')
  )
);

-- Extracts scroll id for the EventLatency slice at `ts`.
CREATE PERFETTO FUNCTION chrome_get_most_recent_scroll_begin_id(
  -- Timestamp of the EventLatency slice to get the scroll id for.
  ts TIMESTAMP)
-- The event_latency_id of the EventLatency slice with the type
-- GESTURE_SCROLL_BEGIN that is the closest to `ts`.
RETURNS LONG AS
SELECT scroll_update_id
FROM _gesture_scroll_events_no_scroll_id
WHERE event_type = 'GESTURE_SCROLL_BEGIN'
AND ts<=$ts
ORDER BY ts DESC
LIMIT 1;

-- All scroll-related events (frames) including gesture scroll updates, begins
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- and ends with respective scroll ids and start/end timestamps, regardless of
-- being presented. This includes pinches that were presented. See b/315761896
-- for context on pinches.
CREATE PERFETTO TABLE chrome_gesture_scroll_events(
  -- Slice Id for the EventLatency scroll event.
  id LONG,
  -- Slice name.
  name STRING,
  -- The start timestamp of the scroll.
  ts TIMESTAMP,
  -- The duration of the scroll.
  dur DURATION,
  -- The id of the scroll update event.
  scroll_update_id LONG,
  -- The id of the scroll.
  scroll_id LONG,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- Frame presentation timestamp aka the timestamp of the
  -- SwapEndToPresentationCompositorFrame substage.
  -- TODO(b/341047059): temporarily use LatchToSwapEnd as a workaround if
  -- SwapEndToPresentationCompositorFrame is missing due to b/247542163.
  presentation_timestamp LONG,
  -- EventLatency event type.
  event_type STRING,
  -- Perfetto track this slice is found on.
  track_id LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
SELECT
  id,
  name,
  ts,
  dur,
  scroll_update_id,
  chrome_get_most_recent_scroll_begin_id(ts) AS scroll_id,
  is_presented,
  presentation_timestamp,
  event_type,
  track_id
FROM _gesture_scroll_events_no_scroll_id;

)_d3l1m1t3r_"
;

const char kChromeEventLatencyDescription[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Source of truth of the descriptions of EventLatency stages.
CREATE PERFETTO TABLE chrome_event_latency_stage_descriptions (
    -- The name of the EventLatency stage.
    name STRING,
    -- A description of the EventLatency stage.
    description STRING
) AS
WITH event_latency_descriptions(
  name,
  description)
AS (
VALUES
  ('TouchRendererHandlingToBrowserMain',
    'Interval between when the website handled blocking touch move to when ' ||
    'the browser UI thread started processing the input. Blocking touch ' ||
    'move happens when a touch event has to be handled by the website ' ||
    'before being converted to a scroll.'),
  ('GenerationToBrowserMain',
    'Interval between OS-provided hardware input timestamp to when the ' ||
    'browser UI thread began processing the input.'),
  ('GenerationToRendererCompositor',
    'Interval between OS-provided hardware input timestamp to when the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'renderer compositor thread starts handling the artificial TOUCH_PRESS ' ||
    'browser injects in the kTouchScrollStarted event. See ' ||
    'PrependTouchScrollNotification for more info.'),
  ('BrowserMainToRendererCompositor',
    'Interval between when Browser UI thread starts to process the input to ' ||
    'renderer compositor thread starting to process it. This stage includes ' ||
    'browser UI thread processing, and task queueing times on the IO and ' ||
    'renderer compositor threads.'),
  ('RendererCompositorQueueingDelay',
    'Interval between when the input event is queued in the renderer ' ||
    'compositor and start of the BeginImplFrame producing a frame ' ||
    'containing this input.'),
  ('RendererCompositorToMain',
    'Interval between when the Renderer Compositor finishes processing the ' ||
    'event and when the Renderer Main (CrRendererMain) starts processing ' ||
    'the event, only seen when the compositor thread cannot handle the ' ||
    'scroll event by itself (known as "slow path"), usually caused by the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'presence of blocking JS event listeners or complex page layout.'),
  ('RendererCompositorProcessing',
    'Interval corresponding to the Renderer Compositor thread processing ' ||
    'the frame updates.'),
  ('RendererMainProcessing',
    'Interval corresponding to the Renderer Main thread processing the ' ||
    'frame updates.'),
  ('EndActivateToSubmitCompositorFrame',
    'Interval that the Renderer Compositor waits for the GPU to flush a ' ||
    'frame to submit a new one.'),
  ('SubmitCompositorFrameToPresentationCompositorFrame',
    'Interval between the first Renderer Frame received to when the system ' ||
    'presented the fully composited frame on the screen. Note that on some ' ||
    'systems/apps this is incomplete/inaccurate due to lack of feedback ' ||
    'timestamps from the platform (Mac, iOS, Android Webview, etc).'),
  ('ArrivedInRendererCompositorToTermination',
    'Interval between when Renderer Compositor received the frame to when ' ||
    'this input was decided to either be ignored or merged into another ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'frame being produced. This could be a dropped frame, or just a normal ' ||
    'coalescing.'),
  ('RendererCompositorStartedToTermination',
    'Interval between when Renderer Compositor started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererMainFinishedToTermination',
    'Interval between when Renderer Main finished processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToTermination',
    'Interval between when Renderer Compositor finished processing the ' ||
    'frame to when this input was decided to either be ignored or merged ' ||
    'into another frame being produced. This could be just a normal ' ||
    'coalescing.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('RendererMainStartedToTermination',
    'Interval between when Renderer Main started processing the frame ' ||
    'to when this input was decided to either be ignored or merged into ' ||
    'another frame being produced. This could be a dropped frame, or just a ' ||
    'normal coalescing.'),
  ('RendererCompositorFinishedToBeginImplFrame',
    'Interval when Renderer Compositor has finished processing a vsync ' ||
    '(with input), but did not end up producing a CompositorFrame due to ' ||
    'reasons such as waiting on main thread, and is now waiting for the ' ||
    'next BeginFrame from the GPU VizCompositor.'),
  ('RendererCompositorFinishedToCommit',
    'Interval between when the Renderer Compositor has finished its work ' ||
    'and the current tree state will be committed from the Renderer Main ' ||
    '(CrRendererMain) thread.'),
  ('RendererCompositorFinishedToEndCommit',
    'Interval between when the Renderer Compositor finishing processing to ' ||
    'the Renderer Main (CrRendererMain) both starting and finishing the ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'commit.'),
  ('RendererCompositorFinishedToActivation',
    'Interval of activation without a previous commit (not as a stage with ' ||
    'ToEndCommit). Activation occurs on the Renderer Compositor Thread ' ||
    'after it has been notified of a fully committed RendererMain tree.'),
  ('RendererCompositorFinishedToEndActivate',
    'Interval when the Renderer Compositor has finished processing and ' ||
    'activating the Tree.'),
  ('RendererCompositorFinishedToSubmitCompositorFrame',
    'Interval when processing does not need to wait for a commit (can do an ' ||
    'early out) for activation and can go straight to providing the frame ' ||
    'to the GPU VizCompositor. The Renderer Compositor is waiting for the ' ||
    'GPU to flush a frame so that it can then submit a new frame.'),
  ('RendererMainFinishedToBeginImplFrame',
    'Interval when the input was sent first to the RendererMain thread and ' ||
    'now requires the Renderer Compositor to react, aka it is is waiting ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'for a BeginFrame signal.'),
  ('RendererMainFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Main (CrRendererMain) thread is ' ||
    'waiting for BeginMainFrame.'),
  ('RendererMainFinishedToCommit',
    'Interval when the Renderer Main (CrRendererMain) is ready to commit ' ||
    'its work to the Renderer Compositor.'),
  ('BeginImplFrameToSendBeginMainFrame',
    'Interval during which the Renderer Compositor has received the ' ||
    'BeginFrame signal from the GPU VizCompositor, and now needs to send it ' ||
    'to the Renderer Main thread (CrRendererMain).'),
  ('RendererCompositorFinishedToSendBeginMainFrame',
    'Interval during which the Renderer Compositor is waiting for a ' ||
    'BeginFrame from the GPU VizCompositor, and it expects to have to do ' ||
    'work on the Renderer Main thread (CrRendererMain), so we are waiting ' ||
    'for a BeginMainFrame'),
  ('SendBeginMainFrameToCommit',
    'Interval when updates (such as HandleInputEvents, Animate, StyleUpdate ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'and LayoutUpdate) are updatedon the Renderer Main thread ' ||
    '(CrRendererMain).'),
  ('Commit',
    'Interval during which the Renderer Main thread (CrRendererMain) ' ||
    'commits updates back to Renderer Compositor for activation. ' ||
    'Specifically, the main thread copies its own version of layer tree ' ||
    'onto the pending tree on the compositor thread. The main thread is ' ||
    'blocked during the copying process.'),
  ('EndCommitToActivation',
    'Interval when the commit is ready and waiting for activation.'),
  ('Activation',
    'Interval when the layer trees and properties are on the pending tree ' ||
    'is pused to the active tree on the Renderer Compositor.'),
  ('SubmitToReceiveCompositorFrame',
    'Interval of the delay b/w Renderer Compositor thread sending ' ||
    'CompositorFrame and then GPU VizCompositorThread receiving the ' ||
    'CompositorFrame.'),
  ('ReceiveCompositorFrameToStartDraw',
    'Interval between the first frame received to when all frames (or ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'timeouts have occurred) and we start drawing. It can be blocked by ' ||
    'other processes (e.g to draw a toolbar it waiting for information from ' ||
    'the Browser) as it waits for timeouts or frames to be provided. This ' ||
    'is the tree of dependencies that the GPU VizCompositor is waiting for ' ||
    'things to arrive. That is creating a single frame for multiple ' ||
    'compositor frames. '),
  ('StartDrawToSwapStart',
    'Interval when all compositing sources are done, or compositing ' ||
    'deadline passes - the viz thread takes all the latest composited ' ||
    'surfaces and issues the software draw instructions to layer the ' ||
    'composited tiles, this substage ends when the swap starts on Gpu ' ||
    'CompositorGpuThread.'),
  ('SwapStartToBufferAvailable',
    'Interval that is a substage of stage "Swap" when the framebuffer ' ||
    'is prepared by the system and the fence Chrome waits on before ' ||
    'writing is signalled, and Chrome can start transferring the new frame.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('BufferAvailableToBufferReady',
    'Interval that is a Ssubstage of stage "Swap" when Chrome is ' ||
    'transferring a new frame to when it has finished completely sending a ' ||
    'frame to the framebuffer.'),
  ('BufferReadyToLatch',
    'Interval that is a substage of stage "Swap", when the system latches ' ||
    'and is ready to use the frame, and then it can get to work producing ' ||
    'the final frame.'),
  ('LatchToSwapEnd',
    'Intereval that is a substage of stage "Swap", when the latch has ' ||
    'finished until the frame is fully swapped and in the queue of frames ' ||
    'to be presented.'),
  ('SwapEndToPresentationCompositorFrame',
    'Interval that the frame is presented on the screen (and pixels became ' ||
    'visible).'))
SELECT
  name,
  description
FROM event_latency_descriptions;

)_d3l1m1t3r_"
;

const char kChromeGraphicsPipeline[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- `Graphics.Pipeline` steps corresponding to work done by a Viz client to
-- produce a frame (i.e. before surface aggregation). Covers steps:
--   * STEP_ISSUE_BEGIN_FRAME
--   * STEP_RECEIVE_BEGIN_FRAME
--   * STEP_GENERATE_RENDER_PASS
--   * STEP_GENERATE_COMPOSITOR_FRAME
--   * STEP_SUBMIT_COMPOSITOR_FRAME
--   * STEP_RECEIVE_COMPOSITOR_FRAME
--   * STEP_RECEIVE_BEGIN_FRAME_DISCARD
--   * STEP_DID_NOT_PRODUCE_FRAME
--   * STEP_DID_NOT_PRODUCE_COMPOSITOR_FRAME
CREATE PERFETTO TABLE chrome_graphics_pipeline_surface_frame_steps(
  -- Slice Id of the `Graphics.Pipeline` slice.
  id LONG,
  -- The start timestamp of the slice/step.
  ts TIMESTAMP,
  -- The duration of the slice/step.
  dur DURATION,
  -- Step name of the `Graphics.Pipeline` slice.
  step STRING,
  -- Id of the graphics pipeline, pre-surface aggregation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  surface_frame_trace_id LONG,
  -- Utid of the thread where this slice exists.
  utid LONG,
  -- Start time of the parent Chrome scheduler task (if any) of this step.
  task_start_time_ts TIMESTAMP)
AS
SELECT
  id,
  ts,
  dur,
  extract_arg(arg_set_id, 'chrome_graphics_pipeline.step') AS step,
  extract_arg(arg_set_id, 'chrome_graphics_pipeline.surface_frame_trace_id')
    AS surface_frame_trace_id,
  utid,
  ts - (EXTRACT_ARG(thread_slice.arg_set_id, 'current_task.event_offset_from_task_start_time_us') * 1000) AS task_start_time_ts
FROM thread_slice
WHERE name = 'Graphics.Pipeline' AND surface_frame_trace_id IS NOT NULL;

-- `Graphics.Pipeline` steps corresponding to work done on creating and
-- presenting one frame during/after surface aggregation. Covers steps:
--   * STEP_DRAW_AND_SWAP
--   * STEP_SURFACE_AGGREGATION
--   * STEP_SEND_BUFFER_SWAP
--   * STEP_BUFFER_SWAP_POST_SUBMIT
--   * STEP_FINISH_BUFFER_SWAP
--   * STEP_SWAP_BUFFERS_ACK
CREATE PERFETTO TABLE chrome_graphics_pipeline_display_frame_steps(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Slice Id of the `Graphics.Pipeline` slice.
  id LONG,
  -- The start timestamp of the slice/step.
  ts TIMESTAMP,
  -- The duration of the slice/step.
  dur DURATION,
  -- Step name of the `Graphics.Pipeline` slice.
  step STRING,
  -- Id of the graphics pipeline, post-surface aggregation.
  display_trace_id LONG,
  -- Utid of the thread where this slice exists.
  utid LONG,
  -- Start time of the parent Chrome scheduler task (if any) of this step.
  task_start_time_ts TIMESTAMP)
AS
SELECT
  id,
  ts,
  dur,
  extract_arg(arg_set_id, 'chrome_graphics_pipeline.step') AS step,
  extract_arg(arg_set_id, 'chrome_graphics_pipeline.display_trace_id')
    AS display_trace_id,
  utid,
  ts - (EXTRACT_ARG(thread_slice.arg_set_id, 'current_task.event_offset_from_task_start_time_us') * 1000) AS task_start_time_ts
FROM thread_slice
WHERE name = 'Graphics.Pipeline' AND display_trace_id IS NOT NULL;

-- Links surface frames (`chrome_graphics_pipeline_surface_frame_steps`) to the
-- display frame (`chrome_graphics_pipeline_display_frame_steps`) into which
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- they are merged. In other words, in general, multiple
-- `surface_frame_trace_id`s will correspond to one `display_trace_id`.
CREATE PERFETTO TABLE chrome_graphics_pipeline_aggregated_frames(
  -- Id of the graphics pipeline, pre-surface aggregation.
  surface_frame_trace_id LONG,
  -- Id of the graphics pipeline, post-surface aggregation.
  display_trace_id LONG)
AS
SELECT
  args.int_value AS surface_frame_trace_id,
  display_trace_id
FROM chrome_graphics_pipeline_display_frame_steps step
JOIN slice
  USING (id)
JOIN args
  USING (arg_set_id)
WHERE
  step.step = 'STEP_SURFACE_AGGREGATION'
  AND args.flat_key
    = 'chrome_graphics_pipeline.aggregated_surface_frame_trace_ids';

-- Links inputs (`chrome_input_pipeline_steps.latency_id`) to the surface frame
-- (`chrome_graphics_pipeline_surface_frame_steps`) to which they correspond.
-- In other words, in general, multiple `latency_id`s will correspond to one
-- `surface_frame_trace_id`.
CREATE PERFETTO TABLE chrome_graphics_pipeline_inputs_to_surface_frames(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Id corresponding to the input pipeline.
  latency_id LONG,
  -- Id of the graphics pipeline, post-surface aggregation.
  surface_frame_trace_id LONG)
AS
SELECT
  args.int_value AS latency_id,
  surface_frame_trace_id
FROM chrome_graphics_pipeline_surface_frame_steps step
JOIN slice
  USING (id)
JOIN args
  USING (arg_set_id)
WHERE
  step.step = 'STEP_SUBMIT_COMPOSITOR_FRAME'
  AND args.flat_key = 'chrome_graphics_pipeline.latency_ids';

)_d3l1m1t3r_"
;

const char kChromeHistograms[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- A helper view on top of the histogram events emitted by Chrome.
-- Requires "disabled-by-default-histogram_samples" Chrome category.
CREATE PERFETTO TABLE chrome_histograms(
  -- The name of the histogram.
  name STRING,
  -- The value of the histogram sample.
  value LONG,
  -- Alias of |slice.ts|.
  ts TIMESTAMP,
  -- Thread name.
  thread_name STRING,
  -- Utid of the thread.
  utid LONG,
  -- Tid of the thread.
  tid LONG,
  -- Process name.
  process_name STRING,
  -- Upid of the process.
  upid LONG,
  -- Pid of the process.
  pid LONG
) AS
SELECT
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.name") as name,
  extract_arg(slice.arg_set_id, "chrome_histogram_sample.sample") as value,
  ts,
  thread.name as thread_name,
  thread.utid as utid,
  thread.tid as tid,
  process.name as process_name,
  process.upid as upid,
  process.pid as pid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM slice
JOIN thread_track ON thread_track.id = slice.track_id
JOIN thread USING (utid)
JOIN process USING (upid)
WHERE
  slice.name = "HistogramSample"
  AND category = "disabled-by-default-histogram_samples";

)_d3l1m1t3r_"
;

const char kChromeInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file specifies common metrics/tables for critical user interactions. It
-- is expected to be in flux as metrics are added across different CUI types.
-- Currently we only track Chrome page loads and their associated metrics.

INCLUDE PERFETTO MODULE chrome.page_loads;
INCLUDE PERFETTO MODULE chrome.scroll_interactions;
INCLUDE PERFETTO MODULE chrome.startups;
INCLUDE PERFETTO MODULE chrome.web_content_interactions;

-- All critical user interaction events, including type and table with
-- associated metrics.
CREATE PERFETTO TABLE chrome_interactions(
  -- Identifier of the interaction; this is not guaranteed to be unique to the table -
  -- rather, it is unique within an individual interaction type. Combine with type to get
  -- a unique identifier in this table.
  scoped_id LONG,
  -- Type of this interaction, which together with scoped_id uniquely identifies this
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- interaction. Also corresponds to a SQL table name containing more details specific
  -- to this type of interaction.
  type STRING,
  -- Interaction name - e.g. 'PageLoad', 'Tap', etc. Interactions will have unique metrics
  -- stored in other tables.
  name STRING,
  -- Timestamp of the CUI event.
  ts TIMESTAMP,
  -- Duration of the CUI event.
  dur DURATION
) AS
SELECT
  id AS scoped_id,
  'chrome_page_loads' AS type,
  'PageLoad' AS name,
  navigation_start_ts AS ts,
  IFNULL(lcp, fcp) AS dur
FROM chrome_page_loads
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_startups' AS type,
  name,
  startup_begin_ts AS ts,
  CASE
    WHEN first_visible_content_ts IS NOT NULL
      THEN first_visible_content_ts - startup_begin_ts
    ELSE 0
  END AS dur
FROM chrome_startups
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_web_content_interactions' AS type,
  'InteractionToFirstPaint' AS name,
  ts,
  dur
FROM chrome_web_content_interactions
UNION ALL
SELECT
  id AS scoped_id,
  'chrome_scroll_interactions' AS type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  'Scroll' AS name,
  ts,
  dur
FROM chrome_scroll_interactions;

)_d3l1m1t3r_"
;

const char kChromeMetadata[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Returns hardware class of the device, often use to find device brand
-- and model.
CREATE PERFETTO FUNCTION chrome_hardware_class()
-- Hardware class name.
RETURNS STRING AS
SELECT
  str_value
  FROM metadata
WHERE name = "cr-hardware-class";
)_d3l1m1t3r_"
;

const char kChromeInput[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE chrome.android_input;

-- Processing steps of the Chrome input pipeline.
CREATE PERFETTO TABLE _chrome_input_pipeline_steps_no_input_type(
  -- Id of this Chrome input pipeline (LatencyInfo).
  latency_id LONG,
  -- Slice id
  slice_id LONG,
  -- The step timestamp.
  ts TIMESTAMP,
  -- Step duration.
  dur DURATION,
  -- Utid of the thread.
  utid LONG,
  -- Step name (ChromeLatencyInfo.step).
  step STRING,
  -- Input type.
  input_type STRING,
  -- Start time of the parent Chrome scheduler task (if any) of this step.
  task_start_time_ts TIMESTAMP
) AS
SELECT
  EXTRACT_ARG(thread_slice.arg_set_id, 'chrome_latency_info.trace_id') AS latency_id,
  id AS slice_id,
  ts,
  dur,
  utid,
  EXTRACT_ARG(thread_slice.arg_set_id, 'chrome_latency_info.step') AS step,
  EXTRACT_ARG(thread_slice.arg_set_id, 'chrome_latency_info.input_type') AS input_type,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts - (EXTRACT_ARG(thread_slice.arg_set_id, 'current_task.event_offset_from_task_start_time_us') * 1000) AS task_start_time_ts
FROM
  thread_slice
WHERE
  step IS NOT NULL
  AND latency_id != -1
ORDER BY slice_id, ts;

-- Each row represents one input pipeline.
CREATE PERFETTO TABLE chrome_inputs(
  -- Id of this Chrome input pipeline (LatencyInfo).
  latency_id LONG,
   -- Input type.
  input_type STRING
) AS
SELECT
  -- Id of this Chrome input pipeline (LatencyInfo).
  latency_id,
  -- MIN selects the first non-null value.
  MIN(input_type) as input_type
FROM _chrome_input_pipeline_steps_no_input_type
WHERE latency_id != -1
GROUP BY latency_id;

-- Since not all steps have associated input type (but all steps
-- for a given latency id should have the same input type),
-- populate input type for steps where it would be NULL.
CREATE PERFETTO TABLE chrome_input_pipeline_steps(
  -- Id of this Chrome input pipeline (LatencyInfo).
  latency_id LONG,
  -- Slice id
  slice_id LONG,
  -- The step timestamp.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Step duration.
  dur DURATION,
  -- Utid of the thread.
  utid LONG,
  -- Step name (ChromeLatencyInfo.step).
  step STRING,
  -- Input type.
  input_type STRING,
  -- Start time of the parent Chrome scheduler task (if any) of this step.
  task_start_time_ts TIMESTAMP
) AS
SELECT
  latency_id,
  slice_id,
  ts,
  dur,
  utid,
  step,
  chrome_inputs.input_type AS input_type,
  task_start_time_ts
FROM
  chrome_inputs
LEFT JOIN
  _chrome_input_pipeline_steps_no_input_type
  USING (latency_id)
WHERE chrome_inputs.input_type IS NOT NULL;

-- For each input, get the latency id of the input that it was coalesced into.
CREATE PERFETTO TABLE chrome_coalesced_inputs(
  -- The `latency_id` of the coalesced input.
  coalesced_latency_id LONG,
  -- The `latency_id` of the input that the current input was coalesced into.
  presented_latency_id LONG
) AS
SELECT
  args.int_value AS coalesced_latency_id,
  latency_id AS presented_latency_id
FROM chrome_input_pipeline_steps step
JOIN slice USING (slice_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(JOIN args USING (arg_set_id)
WHERE step.step = 'STEP_RESAMPLE_SCROLL_EVENTS'
  AND args.flat_key = 'chrome_latency_info.coalesced_trace_ids';

-- Slices with information about non-blocking touch move inputs
-- that were converted into gesture scroll updates.
CREATE PERFETTO TABLE chrome_touch_move_to_scroll_update(
  -- Latency id of the touch move input (LatencyInfo).
  touch_move_latency_id LONG,
  -- Latency id of the corresponding scroll update input (LatencyInfo).
  scroll_update_latency_id LONG
) AS
SELECT
  scroll_update_step.latency_id AS scroll_update_latency_id,
  touch_move_step.latency_id AS touch_move_latency_id
FROM chrome_input_pipeline_steps scroll_update_step
JOIN ancestor_slice(scroll_update_step.slice_id) AS ancestor
JOIN chrome_input_pipeline_steps touch_move_step
  ON ancestor.id = touch_move_step.slice_id
WHERE scroll_update_step.step = 'STEP_SEND_INPUT_EVENT_UI'
AND scroll_update_step.input_type = 'GESTURE_SCROLL_UPDATE_EVENT'
AND touch_move_step.step = 'STEP_TOUCH_EVENT_HANDLED';
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Matches Android input id to the corresponding touch move event.
CREATE PERFETTO TABLE chrome_dispatch_android_input_event_to_touch_move(
  -- Input id (assigned by the system, used by InputReader and InputDispatcher)
  android_input_id STRING,
  -- Latency id.
  touch_move_latency_id LONG
) AS
SELECT
  chrome_deliver_android_input_event.android_input_id,
  latency_id AS touch_move_latency_id
FROM
  chrome_deliver_android_input_event
LEFT JOIN
  chrome_input_pipeline_steps USING (utid)
WHERE
  chrome_input_pipeline_steps.input_type = 'TOUCH_MOVE_EVENT'
  AND chrome_input_pipeline_steps.step = 'STEP_SEND_INPUT_EVENT_UI'
  AND chrome_deliver_android_input_event.ts <= chrome_input_pipeline_steps.ts
  AND chrome_deliver_android_input_event.ts + chrome_deliver_android_input_event.dur >=
    chrome_input_pipeline_steps.ts + chrome_input_pipeline_steps.dur;

)_d3l1m1t3r_"
;

const char kChromePageLoads[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- TODO(b/306300843): The recorded navigation ids are not guaranteed to be
-- unique within a trace; they are only guaranteed to be unique within a single
-- chrome instance. Chrome instance id needs to be recorded, and used here in
-- combination with navigation id to uniquely identify page load metrics.

INCLUDE PERFETTO MODULE slices.with_context;

CREATE PERFETTO VIEW _fcp_metrics AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id') AS navigation_id,
  EXTRACT_ARG(arg_set_id, 'page_load.url') AS url,
  upid AS browser_upid
FROM process_slice
WHERE name = 'PageLoadMetrics.NavigationToFirstContentfulPaint';

CREATE PERFETTO FUNCTION _page_load_metrics(event_name STRING)
RETURNS TABLE(
  ts TIMESTAMP,
  dur DURATION,
  navigation_id LONG,
  browser_upid LONG
) AS
SELECT
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'page_load.navigation_id')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AS navigation_id,
  upid AS browser_upid
FROM process_slice
WHERE name = $event_name;

-- Chrome page loads, including associated high-level metrics and properties.
CREATE PERFETTO TABLE chrome_page_loads(
  -- ID of the navigation and Chrome browser process; this combination is
  -- unique to every individual navigation.
  id LONG,
  -- ID of the navigation associated with the page load (i.e. the cross-document
  -- navigation in primary main frame which created this page's main document).
  -- Also note that navigation_id is specific to a given Chrome browser process,
  -- and not globally unique.
  navigation_id LONG,
  -- Timestamp of the start of navigation.
  navigation_start_ts TIMESTAMP,
  -- Duration between the navigation start and the first contentful paint event
  -- (web.dev/fcp).
  fcp LONG,
  -- Timestamp of the first contentful paint.
  fcp_ts TIMESTAMP,
  -- Duration between the navigation start and the largest contentful paint event
  -- (web.dev/lcp).
  lcp LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Timestamp of the largest contentful paint.
  lcp_ts TIMESTAMP,
  -- Timestamp of the DomContentLoaded event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event
  dom_content_loaded_event_ts TIMESTAMP,
  -- Timestamp of the window load event:
  -- https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event
  load_event_ts TIMESTAMP,
  -- Timestamp of the page self-reporting as fully loaded through the
  -- performance.mark('mark_fully_loaded') API.
  mark_fully_loaded_ts TIMESTAMP,
  -- Timestamp of the page self-reporting as fully visible through the
  -- performance.mark('mark_fully_visible') API.
  mark_fully_visible_ts TIMESTAMP,
  -- Timestamp of the page self-reporting as fully interactive through the
  -- performance.mark('mark_interactive') API.
  mark_interactive_ts TIMESTAMP,
  -- URL at the page load event.
  url STRING,
  -- The unique process id (upid) of the browser process where the page load occurred.
  browser_upid LONG
) AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  ROW_NUMBER() OVER(ORDER BY fcp.ts) AS id,
  fcp.navigation_id,
  fcp.ts AS navigation_start_ts,
  fcp.dur AS fcp,
  fcp.ts + fcp.dur AS fcp_ts,
  lcp.dur AS lcp,
  lcp.dur + lcp.ts AS lcp_ts,
  load_fired.ts AS dom_content_loaded_event_ts,
  start_load.ts AS load_event_ts,
  timing_loaded.ts AS mark_fully_loaded_ts,
  timing_visible.ts AS mark_fully_visible_ts,
  timing_interactive.ts AS mark_interactive_ts,
  fcp.url,
  fcp.browser_upid
FROM _fcp_metrics fcp
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToLargestContentfulPaint') lcp
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToDOMContentLoadedEventFired') load_fired
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.NavigationToMainFrameOnLoad') start_load
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyLoaded') timing_loaded
    USING (navigation_id, browser_upid)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkFullyVisible') timing_visible
    USING (navigation_id, browser_upid)
LEFT JOIN
  _page_load_metrics('PageLoadMetrics.UserTimingMarkInteractive') timing_interactive
    USING (navigation_id, browser_upid);

)_d3l1m1t3r_"
;

const char kChromeScrollInteractions[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Top level scroll events, with metrics.
CREATE PERFETTO TABLE chrome_scroll_interactions(
  -- Unique id for an individual scroll.
  id LONG,
  -- Name of the scroll event.
  name STRING,
  -- Start timestamp of the scroll.
  ts TIMESTAMP,
  -- Duration of the scroll.
  dur DURATION,
  -- The total number of frames in the scroll.
  frame_count LONG,
  -- The total number of vsyncs in the scroll.
  vsync_count LONG,
  -- The maximum number of vsyncs missed during any and all janks.
  missed_vsync_max LONG,
  -- The total number of vsyncs missed during any and all janks.
  missed_vsync_sum LONG,
  -- The number of delayed frames.
  delayed_frame_count LONG,
  -- The number of frames that are deemed janky to the human eye after Chrome
  -- has applied its scroll prediction algorithm.
  predictor_janky_frame_count LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The process id this event occurred on.
  renderer_upid LONG
) AS
WITH scroll_metrics AS (
  SELECT
    id,
    ts,
    dur,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.frame_count')
      AS frame_count,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.vsync_count')
      AS vsync_count,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.missed_vsync_max')
      AS missed_vsync_max,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.missed_vsync_sum')
      AS missed_vsync_sum,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.delayed_frame_count')
      AS delayed_frame_count,
    EXTRACT_ARG(arg_set_id, 'scroll_metrics.predictor_janky_frame_count')
      AS predictor_janky_frame_count,
    upid AS renderer_upid
  FROM process_slice
  WHERE name = 'Scroll'
)
SELECT
  id,
  'Scroll' AS name,
  ts,
  dur,
  frame_count,
  vsync_count,
  missed_vsync_max,
  missed_vsync_sum,
  delayed_frame_count,
  predictor_janky_frame_count,
  renderer_upid
FROM scroll_metrics;

)_d3l1m1t3r_"
;

const char kChromeSpeedometer[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.speedometer_2_1;
INCLUDE PERFETTO MODULE chrome.speedometer_3;

CREATE PERFETTO FUNCTION _chrome_speedometer_version()
RETURNS STRING
AS
WITH
  num_measures AS (
    SELECT '2.1' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, COUNT(*) AS num_measures
    FROM chrome_speedometer_3_measure
  )
SELECT version
FROM num_measures
ORDER BY num_measures DESC
LIMIT 1;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async
CREATE PERFETTO TABLE chrome_speedometer_measure(
  -- Start timestamp of the measure slice
  ts TIMESTAMP,
  -- Duration of the measure slice
  dur DURATION,
  -- Full measure name
  name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Speedometer iteration the slice belongs to.
  iteration LONG,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_measure
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_measure
  )
SELECT ts, dur, name, iteration, suite_name, test_name, measure_type
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Slice that covers one Speedometer iteration.
-- Depending on the Speedometer version these slices might need to be estimated
-- as older versions of Speedometer to not emit marks for this interval. The
-- metrics associated are the same ones Speedometer would output, but note we
-- use ns precision (Speedometer uses ~100us) so the actual values might differ
-- a bit.
CREATE PERFETTO TABLE chrome_speedometer_iteration(
  -- Start timestamp of the iteration
  ts TIMESTAMP,
  -- Duration of the iteration
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration LONG,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  all_versions AS (
    SELECT '2.1' AS version, * FROM chrome_speedometer_2_1_iteration
    UNION ALL
    SELECT '3' AS version, * FROM chrome_speedometer_3_iteration
  )
SELECT ts, dur, name, iteration, geomean, score
FROM all_versions
WHERE version = _chrome_speedometer_version();

-- Returns the Speedometer score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_score()
-- Speedometer score
RETURNS DOUBLE
AS
SELECT
  IIF(
    _chrome_speedometer_version() = '3',
    chrome_speedometer_3_score(),
    chrome_speedometer_2_1_score());

-- Returns the utid for the main thread that ran Speedometer 3
CREATE PERFETTO FUNCTION chrome_speedometer_renderer_main_utid()
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Renderer main utid
RETURNS LONG
AS
SELECT
  IIF(
    _chrome_speedometer_version() = '3',
    chrome_speedometer_3_renderer_main_utid(),
    chrome_speedometer_2_1_renderer_main_utid());

)_d3l1m1t3r_"
;

const char kChromeSpeedometer21[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 2.1 test marks. Used to find relevant slices.
CREATE PERFETTO VIEW _chrome_speedometer_2_1_mark_name(
  -- Expected slice name
  name STRING,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Mark type
  mark_type STRING)
AS
WITH
  data(suite_name, test_name)
  AS (
    VALUES('Angular2-TypeScript-TodoMVC', 'Adding100Items'),
    ('Angular2-TypeScript-TodoMVC', 'CompletingAllItems'),
    ('Angular2-TypeScript-TodoMVC', 'DeletingItems'),
    ('AngularJS-TodoMVC', 'Adding100Items'),
    ('AngularJS-TodoMVC', 'CompletingAllItems'),
    ('AngularJS-TodoMVC', 'DeletingAllItems'),
    ('BackboneJS-TodoMVC', 'Adding100Items'),
    ('BackboneJS-TodoMVC', 'CompletingAllItems'),
    ('BackboneJS-TodoMVC', 'DeletingAllItems'),
    ('Elm-TodoMVC', 'Adding100Items'),
    ('Elm-TodoMVC', 'CompletingAllItems'),
    ('Elm-TodoMVC', 'DeletingItems'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('EmberJS-Debug-TodoMVC', 'Adding100Items'),
    ('EmberJS-Debug-TodoMVC', 'CompletingAllItems'),
    ('EmberJS-Debug-TodoMVC', 'DeletingItems'),
    ('EmberJS-TodoMVC', 'Adding100Items'),
    ('EmberJS-TodoMVC', 'CompletingAllItems'),
    ('EmberJS-TodoMVC', 'DeletingItems'),
    ('Flight-TodoMVC', 'Adding100Items'),
    ('Flight-TodoMVC', 'CompletingAllItems'),
    ('Flight-TodoMVC', 'DeletingItems'),
    ('Inferno-TodoMVC', 'Adding100Items'),
    ('Inferno-TodoMVC', 'CompletingAllItems'),
    ('Inferno-TodoMVC', 'DeletingItems'),
    ('Preact-TodoMVC', 'Adding100Items'),
    ('Preact-TodoMVC', 'CompletingAllItems'),
    ('Preact-TodoMVC', 'DeletingItems'),
    ('React-Redux-TodoMVC', 'Adding100Items'),
    ('React-Redux-TodoMVC', 'CompletingAllItems'),
    ('React-Redux-TodoMVC', 'DeletingItems'),
    ('React-TodoMVC', 'Adding100Items'),
    ('React-TodoMVC', 'CompletingAllItems'),
    ('React-TodoMVC', 'DeletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'Adding100Items'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-Babel-Webpack-TodoMVC', 'DeletingItems'),
    ('Vanilla-ES2015-TodoMVC', 'Adding100Items'),
    ('Vanilla-ES2015-TodoMVC', 'CompletingAllItems'),
    ('Vanilla-ES2015-TodoMVC', 'DeletingItems'),
    ('VanillaJS-TodoMVC', 'Adding100Items'),
    ('VanillaJS-TodoMVC', 'CompletingAllItems'),
    ('VanillaJS-TodoMVC', 'DeletingAllItems'),
    ('VueJS-TodoMVC', 'Adding100Items'),
    ('VueJS-TodoMVC', 'CompletingAllItems'),
    ('VueJS-TodoMVC', 'DeletingAllItems'),
    ('jQuery-TodoMVC', 'Adding100Items'),
    ('jQuery-TodoMVC', 'CompletingAllItems'),
    ('jQuery-TodoMVC', 'DeletingAllItems')
  ),
  mark_type(mark_type) AS (VALUES('start'), ('sync-end'), ('async-end'))
SELECT
  suite_name || '.' || test_name || '-' || mark_type AS name,
  suite_name,
  test_name,
  mark_type
FROM data, mark_type;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- There are two intervals that are measured for every test: sync and async
-- sync is the time between the start and sync-end marks, async is the time
-- between the sync-end and async-end marks.
CREATE PERFETTO TABLE chrome_speedometer_2_1_measure(
  -- Start timestamp of the measure slice
  ts TIMESTAMP,
  -- Duration of the measure slice
  dur DURATION,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration LONG,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  mark AS (
    SELECT
      s.id AS slice_id,
      RANK() OVER (PARTITION BY name ORDER BY ts ASC) AS iteration,
      m.suite_name,
      m.test_name,
      m.mark_type
    FROM slice AS s
    -- Make sure we only look at slices with names we expect.
    JOIN _chrome_speedometer_2_1_mark_name AS m
      USING (name)
    WHERE category = 'blink.user_timing'
  ),
  -- Get the 3 test timestamps (start, sync-end, async-end) in one row. Using a
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the LAG window function and partitioning by test. 2 out of the 3 rows
  -- generated per test will have some NULL ts values.
  augmented AS (
    SELECT
      iteration,
      suite_name,
      test_name,
      ts AS async_end_ts,
      LAG(ts, 1)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS sync_end_ts,
      LAG(ts, 2)
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS start_ts,
      COUNT()
        OVER (PARTITION BY iteration, suite_name, test_name ORDER BY ts ASC)
        AS mark_count
    FROM mark
    JOIN slice
      USING (slice_id)
  ),
  filtered AS (
    SELECT *
    FROM augmented
    -- This server 2 purposes: make sure we have all the marks (think truncated
    -- trace), and remove the NULL ts values due to the LAG window function.
    WHERE mark_count = 3
  ),
  base AS (
    SELECT
      sync_end_ts AS ts,
      async_end_ts - sync_end_ts AS dur,
      iteration,
      suite_name,
      test_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      'async' AS measure_type
    FROM filtered
    UNION ALL
    SELECT
      start_ts AS ts,
      sync_end_ts - start_ts AS dur,
      iteration,
      suite_name,
      test_name,
      'sync' AS measure_type
    FROM filtered
  )
SELECT
  ts,
  dur,
  suite_name || '.' || test_name || '-' || measure_type AS name,
  iteration,
  suite_name,
  test_name,
  measure_type
FROM base;

-- Slice that covers one Speedometer iteration.
-- This slice is actually estimated as a default Speedometer run will not emit
-- marks to cover this interval. The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit. Also note Speedometer
-- returns the values in ms these here and in ns.
CREATE PERFETTO TABLE chrome_speedometer_2_1_iteration(
  -- Start timestamp of the iteration
  ts TIMESTAMP,
  -- Duration of the iteration
  dur DURATION,
  -- Iteration name
  name STRING,
  -- Iteration number
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  iteration LONG,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
SELECT
  MIN(start) AS ts,
  MAX(END) - MIN(start) AS dur,
  'iteration-' || iteration AS name,
  iteration,
  -- Compute geometric mean using LN instead of multiplication to prevent
  -- overflows
  EXP(AVG(LN(suite_total))) AS geomean,
  1000 / EXP(AVG(LN(suite_total))) * 60 / 3 AS score
FROM
  (
    SELECT
      iteration,
      SUM(dur / (1000.0 * 1000.0)) AS suite_total,
      MIN(ts) AS start,
      MAX(ts + dur) AS END
    FROM chrome_speedometer_2_1_measure
    GROUP BY suite_name, iteration
  )
GROUP BY iteration;

-- Returns the Speedometer 2.1 score for all iterations in the trace
CREATE PERFETTO FUNCTION chrome_speedometer_2_1_score()
-- Speedometer 2.1 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_2_1_iteration;

-- Returns the utid for the main thread that ran Speedometer 2.1
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION chrome_speedometer_2_1_renderer_main_utid()
-- Renderer main utid
RETURNS LONG
AS
SELECT utid
FROM thread_track
WHERE
  id IN (
    SELECT track_id
    FROM slice, _chrome_speedometer_2_1_mark_name
    USING (name)
    WHERE category = 'blink.user_timing'
  );

)_d3l1m1t3r_"
;

const char kChromeSpeedometer3[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- List Speedometer 3 measures. Used to find relevant slices.
CREATE PERFETTO VIEW _chrome_speedometer_3_measure_name(
  -- Expected slice name
  name STRING,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Measure type
  measure_type STRING)
AS
WITH
  data(suite_name, test_name)
  AS (
    VALUES('TodoMVC-JavaScript-ES5', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES5', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES5', 'DeletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-JavaScript-ES6-Webpack-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-WebComponents', 'Adding100Items'),
    ('TodoMVC-WebComponents', 'CompletingAllItems'),
    ('TodoMVC-WebComponents', 'DeletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'Adding100Items'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-React-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-React-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-React-Redux', 'Adding100Items'),
    ('TodoMVC-React-Redux', 'CompletingAllItems'),
    ('TodoMVC-React-Redux', 'DeletingAllItems'),
    ('TodoMVC-Backbone', 'Adding100Items'),
    ('TodoMVC-Backbone', 'CompletingAllItems'),
    ('TodoMVC-Backbone', 'DeletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Angular-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Angular-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Vue', 'Adding100Items'),
    ('TodoMVC-Vue', 'CompletingAllItems'),
    ('TodoMVC-Vue', 'DeletingAllItems'),
    ('TodoMVC-jQuery', 'Adding100Items'),
    ('TodoMVC-jQuery', 'CompletingAllItems'),
    ('TodoMVC-jQuery', 'DeletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Preact-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Preact-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'Adding100Items'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('TodoMVC-Svelte-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Svelte-Complex-DOM', 'DeletingAllItems'),
    ('TodoMVC-Lit-Complex-DOM', 'Adding100Items'),
    ('TodoMVC-Lit-Complex-DOM', 'CompletingAllItems'),
    ('TodoMVC-Lit-Complex-DOM', 'DeletingAllItems'),
    ('NewsSite-Next', 'NavigateToUS'),
    ('NewsSite-Next', 'NavigateToWorld'),
    ('NewsSite-Next', 'NavigateToPolitics'),
    ('NewsSite-Nuxt', 'NavigateToUS'),
    ('NewsSite-Nuxt', 'NavigateToWorld'),
    ('NewsSite-Nuxt', 'NavigateToPolitics'),
    ('Editor-CodeMirror', 'Long'),
    ('Editor-CodeMirror', 'Highlight'),
    ('Editor-TipTap', 'Long'),
    ('Editor-TipTap', 'Highlight'),
    ('Charts-observable-plot', 'Stacked by 6'),
    ('Charts-observable-plot', 'Stacked by 20'),
    ('Charts-observable-plot', 'Dotted'),
    ('Charts-chartjs', 'Draw scatter'),
    ('Charts-chartjs', 'Show tooltip'),
    ('Charts-chartjs', 'Draw opaque scatter'),
    ('React-Stockcharts-SVG', 'Render'),
    ('React-Stockcharts-SVG', 'PanTheChart'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ('React-Stockcharts-SVG', 'ZoomTheChart'),
    ('Perf-Dashboard', 'Render'),
    ('Perf-Dashboard', 'SelectingPoints'),
    ('Perf-Dashboard', 'SelectingRange')
  ),
  measure_type(measure_type) AS (VALUES('sync'), ('async'))
SELECT
  suite_name || '.' || test_name || '-' || measure_type AS name,
  suite_name,
  test_name,
  measure_type
FROM data, measure_type;

CREATE PERFETTO VIEW _chrome_speedometer_3_iteration_slice
AS
WITH
  data AS (
    SELECT *, substr(name, 1 + length('iteration-')) AS iteration_str
    FROM slice
    WHERE category = 'blink.user_timing' AND name GLOB 'iteration-*'
  )
SELECT *, cast_int!(iteration_str) AS iteration
FROM data
WHERE iteration_str = iteration;

-- Augmented slices for Speedometer measurements.
-- These are the intervals of time Speedometer uses to compute the final score.
-- There are two intervals that are measured for every test: sync and async.
CREATE PERFETTO TABLE chrome_speedometer_3_measure(
  -- Start timestamp of the measure slice
  ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Duration of the measure slice
  dur DURATION,
  -- Full measure name
  name STRING,
  -- Speedometer iteration the slice belongs to.
  iteration LONG,
  -- Suite name
  suite_name STRING,
  -- Test name
  test_name STRING,
  -- Type of the measure (sync or async)
  measure_type STRING)
AS
WITH
  measure_slice AS (
    SELECT s.ts, s.dur, s.name, m.suite_name, m.test_name, m.measure_type
    FROM slice s, _chrome_speedometer_3_measure_name AS m
    USING (name)
    WHERE s.category = 'blink.user_timing'
  )
SELECT
  s.ts, s.dur, s.name, i.iteration, s.suite_name, s.test_name, s.measure_type
FROM measure_slice AS s, _chrome_speedometer_3_iteration_slice i
ON (s.ts >= i.ts AND s.ts < i.ts + i.dur)
ORDER BY s.ts ASC;

-- Slice that covers one Speedometer iteration.
-- The metrics associated are the same ones
-- Speedometer would output, but note we use ns precision (Speedometer uses
-- ~100us) so the actual values might differ a bit.
CREATE PERFETTO TABLE chrome_speedometer_3_iteration(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Start timestamp of the iteration
  ts TIMESTAMP,
  -- Duration of the iteration
  dur DURATION,
  -- Iteration name
  name STRING,
  -- Iteration number
  iteration LONG,
  -- Geometric mean of the suite durations for this iteration.
  geomean DOUBLE,
  -- Speedometer score for this iteration (The total score for a run in the
  -- average of all iteration scores).
  score DOUBLE)
AS
WITH
  suite AS (
    SELECT iteration, suite_name, SUM(dur / (1000.0 * 1000.0)) AS suite_total
    FROM chrome_speedometer_3_measure
    GROUP BY iteration, suite_name
  ),
  iteration AS (
    SELECT
      iteration,
      -- Compute geometric mean using LN instead of multiplication to prevent
      -- overflows
      EXP(AVG(LN(suite_total))) AS geomean
    FROM suite
    GROUP BY iteration
  )
SELECT s.ts, s.dur, s.name, i.iteration, i.geomean, 1000.0 / i.geomean AS score
FROM iteration AS i, _chrome_speedometer_3_iteration_slice AS s
USING (iteration);

-- Returns the Speedometer 3 score for all iterations in the trace
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION chrome_speedometer_3_score()
-- Speedometer 3 score
RETURNS DOUBLE
AS
SELECT AVG(score) FROM chrome_speedometer_3_iteration;

-- Returns the utid for the main thread that ran Speedometer 3
CREATE PERFETTO FUNCTION chrome_speedometer_3_renderer_main_utid()
-- Renderer main utid
RETURNS LONG
AS
WITH
  start_event AS (
    SELECT name || '-start' AS name FROM _chrome_speedometer_3_measure_name
  )
SELECT utid
FROM thread_track
WHERE
  id IN (
    SELECT track_id
    FROM slice, start_event
    USING (name)
    WHERE category = 'blink.user_timing'
  )

)_d3l1m1t3r_"
;

const char kChromeStartups[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Access all startups, including those that don't lead to any visible content.
-- If TimeToFirstVisibleContent is available, then this event will be the
-- main event of the startup. Otherwise, the event for the start timestamp will
-- be used.
CREATE PERFETTO VIEW _startup_start_events AS
WITH
starts AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM thread_slice
  WHERE name = 'Startup.ActivityStart'
),
times_to_first_visible_content AS (
  SELECT
    name,
    EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
    ts,
    dur,
    upid AS browser_upid
  FROM process_slice
  WHERE name = 'Startup.TimeToFirstVisibleContent2'
),
all_activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM starts
  UNION ALL
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM times_to_first_visible_content
),
activity_ids AS (
  SELECT
    DISTINCT activity_id,
    browser_upid
  FROM all_activity_ids
)
SELECT
  activity_ids.activity_id,
  'Startup' AS name,
  IFNULL(times_to_first_visible_content.ts, starts.ts) AS startup_begin_ts,
  times_to_first_visible_content.ts +
    times_to_first_visible_content.dur AS first_visible_content_ts,
  activity_ids.browser_upid
FROM activity_ids
  LEFT JOIN times_to_first_visible_content using(activity_id, browser_upid)
  LEFT JOIN starts using(activity_id, browser_upid);

-- Chrome launch causes, not recorded at start time; use the activity id to
-- join with the actual startup events.
CREATE PERFETTO VIEW _launch_causes AS
SELECT
  EXTRACT_ARG(arg_set_id, 'startup.activity_id') AS activity_id,
  EXTRACT_ARG(arg_set_id, 'startup.launch_cause') AS launch_cause,
  upid AS browser_upid
FROM thread_slice
WHERE name = 'Startup.LaunchCause';

)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Chrome startups, including launch cause.
CREATE PERFETTO TABLE chrome_startups(
  -- Unique ID
  id LONG,
  -- Chrome Activity event id of the launch.
  activity_id LONG,
  -- Name of the launch start event.
  name STRING,
  -- Timestamp that the startup occurred.
  startup_begin_ts TIMESTAMP,
  -- Timestamp to the first visible content.
  first_visible_content_ts TIMESTAMP,
  -- Launch cause. See Startup.LaunchCauseType in chrome_track_event.proto.
  launch_cause STRING,
  -- Process ID of the Browser where the startup occurred.
  browser_upid LONG
) AS
SELECT
  ROW_NUMBER() OVER (ORDER BY start_events.startup_begin_ts) AS id,
  start_events.activity_id,
  start_events.name,
  start_events.startup_begin_ts,
  start_events.first_visible_content_ts,
  launches.launch_cause,
  start_events.browser_upid
FROM _startup_start_events start_events
  LEFT JOIN _launch_causes launches
  USING(activity_id, browser_upid);

)_d3l1m1t3r_"
;

const char kChromeTasks[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Checks if slice has an ancestor with provided name.
CREATE PERFETTO FUNCTION _has_parent_slice_with_name(
  -- Id of the slice to check parents of.
  id LONG,
  -- Name of potential ancestor slice.
  parent_name STRING)
-- Whether `parent_name` is a name of an ancestor slice.
RETURNS BOOL AS
SELECT EXISTS(
  SELECT 1
  FROM ancestor_slice($id)
  WHERE name = $parent_name
  LIMIT 1
);

-- Returns the mojo ipc hash for a given task, looking it up from the
-- argument of descendant ScopedSetIpcHash slice.
-- This is relevant only for the older Chrome traces, where mojo IPC
-- hash was reported in a separate ScopedSetIpcHash slice.
CREATE PERFETTO FUNCTION _extract_mojo_ipc_hash(slice_id LONG)
RETURNS LONG AS
SELECT EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash")
FROM descendant_slice($slice_id)
WHERE name="ScopedSetIpcHash"
ORDER BY id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LIMIT 1;

-- Returns the frame type (main frame vs subframe) for key navigation tasks
-- which capture the associated RenderFrameHost in an argument.
CREATE PERFETTO FUNCTION _extract_frame_type(slice_id LONG)
RETURNS LONG AS
SELECT EXTRACT_ARG(arg_set_id, "render_frame_host.frame_type")
FROM descendant_slice($slice_id)
WHERE name IN (
  "RenderFrameHostImpl::BeginNavigation",
  "RenderFrameHostImpl::DidCommitProvisionalLoad",
  "RenderFrameHostImpl::DidCommitSameDocumentNavigation",
  "RenderFrameHostImpl::DidStopLoading"
)
LIMIT 1;

-- Human-readable aliases for a few key navigation tasks.
CREATE PERFETTO FUNCTION _human_readable_navigation_task_name(
  task_name STRING)
RETURNS STRING AS
SELECT
  CASE
    WHEN $task_name = "content.mojom.FrameHost message (hash=2168461044)"
      THEN "FrameHost::BeginNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=3561497419)"
      THEN "FrameHost::DidCommitProvisionalLoad"
    WHEN $task_name = "content.mojom.FrameHost message (hash=1421450774)"
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      THEN "FrameHost::DidCommitSameDocumentNavigation"
    WHEN $task_name = "content.mojom.FrameHost message (hash=368650583)"
      THEN "FrameHost::DidStopLoading"
  END;

-- Takes a task name and formats it correctly for scheduler tasks.
CREATE PERFETTO FUNCTION _format_scheduler_task_name(task_name STRING)
RETURNS STRING AS
SELECT printf("RunTask(posted_from=%s)", $task_name);

-- Takes the category and determines whether it is "Java" only, as opposed to
-- "toplevel,Java".
CREATE PERFETTO FUNCTION _java_not_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category GLOB "*Java*" AND $category not GLOB "*toplevel*";

-- Takes the category and determines whether is any valid
-- toplevel category or combination of categories.
CREATE PERFETTO FUNCTION _any_top_level_category(category STRING)
RETURNS BOOL AS
SELECT $category IN ("toplevel", "toplevel,viz", "toplevel,Java");

-- TODO(altimin): the situations with kinds in this file is a bit of a mess.
-- The idea is that it should work as `type` in the `slice` table, pointing to
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- a "child" table with more information about the task (e.g. posted_from for
-- scheduler tasks). Currently this is not the case and needs a cleanup.
-- Also we should align this with how table inheritance should work for
-- `CREATE PERFETTO TABLE`.

-- Get task type for a given task kind.
CREATE PERFETTO FUNCTION _get_java_views_task_type(kind STRING)
RETURNS STRING AS
SELECT
  CASE $kind
    WHEN "Choreographer" THEN "choreographer"
    WHEN "SingleThreadProxy::BeginMainFrame" THEN "ui_thread_begin_main_frame"
  END;

-- All slices corresponding to receiving mojo messages.
-- On the newer Chrome versions, it's just "Receive mojo message" and
-- "Receive mojo reply" slices (or "Receive {mojo_message_name}" if
-- built with `extended_tracing_enabled`. On legacy Chrome versions,
-- other appropriate messages (like "Connector::DispatchMessage") are used.
--
-- @column STRING interface_name    Name of the IPC interface.
-- @column INT ipc_hash             Hash of a message name.
-- @column STRING message_type      Either 'message' or 'reply'.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column INT id                   Slice id.
--
-- Note: this might include messages received within a sync mojo call.
-- TODO(altimin): This should use EXTEND_TABLE when it becomes available.
CREATE PERFETTO TABLE _chrome_mojo_slices AS
WITH
-- Select all new-style (post crrev.com/c/3270337) mojo slices and
-- generate |task_name| for them.
-- If extended tracing is enabled, the slice name will have the full method
-- name (i.e. "Receive content::mojom::FrameHost::DidStopLoading") and we
-- should use it as a full name.
-- If extended tracing is not enabled, we should include the interface name
-- and method hash into the full name.
new_mojo_slices AS (
  SELECT
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
    EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
    CASE name
      WHEN "Receive mojo message" THEN "message"
      WHEN "Receive mojo reply" THEN "reply"
    END AS message_type,
    id
  FROM slice
  WHERE
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    category GLOB '*toplevel*'
    AND name GLOB 'Receive *'
),
-- Select old-style slices for channel-associated mojo events.
old_associated_mojo_slices AS (
  SELECT
    name AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*mojom*"
    AND name GLOB '*.mojom.*'
),
-- Select old-style slices for non-(channel-associated) mojo events.
old_non_associated_mojo_slices AS (
  SELECT
    COALESCE(
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.watcher_notify_interface_tag"),
      EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.mojo_interface_tag")
    ) AS interface_name,
    _extract_mojo_ipc_hash(id) AS ipc_hash,
    "message" AS message_type,
    id
  FROM slice
  WHERE
    category GLOB "*toplevel*" AND name = "Connector::DispatchMessage"
),
merged AS (
-- Merge all mojo slices.
SELECT * FROM new_mojo_slices
UNION ALL
SELECT * FROM old_associated_mojo_slices
UNION ALL
SELECT * FROM old_non_associated_mojo_slices
)_d3l1m1t3r_"
R"_d3l1m1t3r_()
SELECT * FROM merged ORDER BY id;

-- This table contains a list of slices corresponding to the _representative_
-- Chrome Java view operations.
-- These are the outermost Java view slices after filtering out generic framework views
-- (like FitWindowsLinearLayout) and selecting the outermost slices from the remaining ones.
--
-- @column id INT                       Slice id.
-- @column ts INT                       Timestamp.
-- @column dur INT                      Duration.
-- @column name STRING                  Name of the view.
-- @column is_software_screenshot BOOL  Whether this slice is a part of non-accelerated
--                                      capture toolbar screenshot.
-- @column is_hardware_screenshot BOOL  Whether this slice is a part of accelerated
--                                      capture toolbar screenshot.
CREATE PERFETTO TABLE _chrome_java_views AS
WITH
-- .draw, .onLayout and .onMeasure parts of the java view names don't add much, strip them.
java_slices_with_trimmed_names AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    id,
    REPLACE(
      REPLACE(
        REPLACE(
          REPLACE(
            REPLACE(
              s1.name,
              ".draw", ""),
            ".onLayout", ""),
          ".onMeasure", ""),
        ".Layout", ""),
      ".Measure", "") AS name,
      ts,
      dur
    FROM
      slice s1
    -- Ensure that toplevel Java slices are not included, as they may be logged
    -- with either category = "toplevel" or category = "toplevel,Java".
    -- Also filter out the zero duration slices as an attempt to reduce noise as
    -- "Java" category contains misc events (as it's hard to add new categories).
    WHERE _java_not_top_level_category(category) AND dur > 0
  ),
  -- We filter out generic slices from various UI frameworks which don't tell us much about
  -- what exactly this view is doing.
  interesting_java_slices AS (
    SELECT
      id, name, ts, dur
    FROM java_slices_with_trimmed_names
    WHERE NOT name IN (
      -- AndroidX.
      "FitWindowsFrameLayout",
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      "FitWindowsLinearLayout",
      "ContentFrameLayout",
      "CoordinatorLayout",
      -- Other non-Chrome UI libraries.
      "ComponentHost",
      -- Generic Chrome frameworks.
      "CompositorView:finalizeLayers",
      "CompositorViewHolder",
      "CompositorViewHolder:layout",
      "CompositorViewHolder:updateContentViewChildrenDimension",
      "CoordinatorLayoutForPointer",
      "OptimizedFrameLayout",
      "ViewResourceAdapter:getBitmap",
      "ViewResourceFrameLayout",
      -- Non-specific Chrome slices.
      "AppCompatImageButton",
      "ScrollingBottomViewResourceFrameLayout",
      -- Screenshots get their custom annotations below.
      "ViewResourceAdapter:captureWithHardwareDraw",
      "ViewResourceAdapter:captureWithSoftwareDraw",
      -- Non-bytecode generated slices.
      "LayoutDriver:onUpdate"
    )
)
SELECT
  s1.*,
  -- While the parent slices are too generic to be used by themselves,
  -- they can provide some useful metadata.
  _has_parent_slice_with_name(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    s1.id,
    "ViewResourceAdapter:captureWithSoftwareDraw"
  ) AS is_software_screenshot,
  _has_parent_slice_with_name(
    s1.id,
    "ViewResourceAdapter:captureWithHardwareDraw"
  ) AS is_hardware_screenshot
FROM interesting_java_slices s1
-- We select "outermost" interesting slices: interesting slices which
-- do not another interesting slice in their parent chain.
WHERE (SELECT count()
  FROM ancestor_slice(s1.id) s2
  JOIN interesting_java_slices s3 ON s2.id = s3.id) = 0;

-- A list of slices corresponding to operations on interesting (non-generic)
-- Chrome Java views. The view is considered interested if it's not a system
-- (ContentFrameLayout) or generic library (CompositorViewHolder) views.
--
-- TODO(altimin): Add "columns_from slice" annotation.
-- TODO(altimin): convert this to EXTEND_TABLE when it becomes available.
CREATE PERFETTO VIEW chrome_java_views(
  -- Name of the view.
  filtered_name STRING,
  -- Whether this slice is a part of non-accelerated capture toolbar screenshot.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  is_software_screenshot BOOL,
  -- Whether this slice is a part of accelerated capture toolbar screenshot.
  is_hardware_screenshot BOOL,
  -- Slice id.
  slice_id LONG
) AS
SELECT
  java_view.name AS filtered_name,
  java_view.is_software_screenshot,
  java_view.is_hardware_screenshot,
  slice.id as slice_id
FROM _chrome_java_views java_view
JOIN slice USING (id);

-- A list of Choreographer tasks (Android frame generation) in Chrome.
CREATE PERFETTO VIEW _chrome_choreographer_tasks
AS
SELECT
  id,
  "Choreographer" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE name GLOB "Looper.dispatch: android.view.Choreographer$FrameHandler*";

-- Extract task's posted_from information from task's arguments.
CREATE PERFETTO FUNCTION _get_posted_from(arg_set_id LONG)
RETURNS STRING AS
WITH posted_from as (
  SELECT
    EXTRACT_ARG($arg_set_id, "task.posted_from.file_name") AS file_name,
    EXTRACT_ARG($arg_set_id, "task.posted_from.function_name") AS function_name
)
SELECT file_name || ":" || function_name as posted_from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM posted_from;

-- Selects the BeginMainFrame slices (which as posted from ScheduledActionSendBeginMainFrame),
-- used for root-level processing. In top-level/Java based slices, these will correspond to the
-- ancestor of descendant slices; in long-task tracking, these tasks will be
-- on a custom track and will need to be associated with children by timestamp
-- and duration. Corresponds with the Choreographer root slices in
-- chrome_choreographer_tasks below.
--
-- Schema:
-- @column is            The slice id.
-- @column kind          The type of Java slice.
-- @column ts            The timestamp of the slice.
-- @column name          The name of the slice.
CREATE PERFETTO FUNCTION _select_begin_main_frame_java_slices(
  name STRING)
RETURNS TABLE(id LONG, kind STRING, ts TIMESTAMP, dur DURATION, name STRING) AS
SELECT
  id,
  "SingleThreadProxy::BeginMainFrame" AS kind,
  ts,
  dur,
  name
FROM slice
WHERE
  (name = $name
    AND _get_posted_from(arg_set_id) =
        "cc/trees/single_thread_proxy.cc:ScheduledActionSendBeginMainFrame");
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- A list of Chrome tasks which were performing operations with Java views,
-- together with the names of these views.
-- @column id INT            Slice id.
-- @column kind STRING       Type of the task.
-- @column java_views STRING Concatenated names of Java views used by the task.
CREATE PERFETTO VIEW _chrome_slices_with_java_views AS
WITH
  -- Select UI thread BeginMainFrames (which are Chrome scheduler tasks) and
  -- Choreographer frames (which are looper tasks).
  root_slices AS (
    SELECT id, kind
    FROM _SELECT_BEGIN_MAIN_FRAME_JAVA_SLICES('ThreadControllerImpl::RunTask')
    UNION ALL
    SELECT id, kind FROM _chrome_choreographer_tasks
  ),
  -- Intermediate step to allow us to sort java view names.
  root_slice_and_java_view_not_grouped AS (
    SELECT
      root.id, root.kind, java_view.name AS java_view_name
    FROM root_slices root
    JOIN descendant_slice(root.id) child
    JOIN _chrome_java_views java_view ON java_view.id = child.id
  )
SELECT
  root.id,
  root.kind,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  GROUP_CONCAT(DISTINCT java_view.java_view_name) AS java_views
FROM root_slices root
LEFT JOIN root_slice_and_java_view_not_grouped java_view USING (id)
GROUP BY root.id;

-- A list of tasks executed by Chrome scheduler.
CREATE PERFETTO TABLE _chrome_scheduler_tasks AS
SELECT
  id
FROM slice
WHERE
  category GLOB "*toplevel*"
  AND (name = "ThreadControllerImpl::RunTask" OR name = "ThreadPool_RunTask")
ORDER BY id;

-- A list of tasks executed by Chrome scheduler.
CREATE PERFETTO VIEW chrome_scheduler_tasks(
  -- Slice id.
  id LONG,
  -- Type.
  type STRING,
  -- Name of the task.
  name STRING,
  -- Timestamp.
  ts TIMESTAMP,
  -- Duration.
  dur DURATION,
  -- Utid of the thread this task run on.
  utid LONG,
  -- Name of the thread this task run on.
  thread_name STRING,
  -- Upid of the process of this task.
  upid LONG,
  -- Name of the process of this task.
  process_name STRING,
  -- Same as slice.track_id.
  track_id LONG,
  -- Same as slice.category.
  category STRING,
  -- Same as slice.depth.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  depth LONG,
  -- Same as slice.parent_id.
  parent_id LONG,
  -- Same as slice.arg_set_id.
  arg_set_id LONG,
  -- Same as slice.thread_ts.
  thread_ts TIMESTAMP,
  -- Same as slice.thread_dur.
  thread_dur DURATION,
  -- Source location where the PostTask was called.
  posted_from STRING
) AS
SELECT
  task.id,
  "chrome_scheduler_tasks" as type,
  _format_scheduler_task_name(
    _get_posted_from(slice.arg_set_id)) as name,
  slice.ts,
  slice.dur,
  thread.utid,
  thread.name as thread_name,
  process.upid,
  process.name as process_name,
  slice.track_id,
  slice.category,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur,
  _get_posted_from(slice.arg_set_id) as posted_from
FROM _chrome_scheduler_tasks task
JOIN slice using (id)
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread using (utid)
JOIN process using (upid)
ORDER BY task.id;

-- Select the slice that might be the descendant mojo slice for the given task
-- slice if it exists.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION _get_descendant_mojo_slice_candidate(
  slice_id LONG
)
RETURNS LONG AS
SELECT
  id
FROM descendant_slice($slice_id)
WHERE
  -- The tricky case here is dealing with sync mojo IPCs: we do not want to
  -- pick up sync IPCs when we are in a non-IPC task.
  -- So we look at all toplevel events and pick up the first one:
  -- for sync mojo messages, it will be "Send mojo message", which then
  -- will fail.
  -- Some events are excluded as they can legimately appear under "RunTask"
  -- before "Receive mojo message".
  category GLOB "*toplevel*" AND
  name NOT IN (
    "SimpleWatcher::OnHandleReady",
    "MessagePipe peer closed")
ORDER by depth, ts
LIMIT 1;

CREATE PERFETTO FUNCTION _descendant_mojo_slice(slice_id LONG)
RETURNS TABLE(task_name STRING) AS
SELECT
  printf("%s %s (hash=%d)",
    mojo.interface_name, mojo.message_type, mojo.ipc_hash) AS task_name
FROM slice task
JOIN _chrome_mojo_slices mojo
  ON mojo.id = _get_descendant_mojo_slice_candidate($slice_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE task.id = $slice_id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the tasks
-- will not intersect.
--
-- @column task_name STRING  Name for the given task.
-- @column task_type STRING  Type of the task (e.g. "scheduler").
-- @column scheduling_delay LONG
CREATE PERFETTO TABLE _chrome_tasks AS
WITH
-- Select slices from "toplevel" category which do not have another
-- "toplevel" slice as ancestor. The possible cases include sync mojo messages
-- and tasks in nested runloops. Toplevel events may also be logged as with
-- the Java category.
non_embedded_toplevel_slices AS (
  SELECT * FROM slice
  WHERE
    _any_top_level_category(category)
    AND (SELECT count() FROM ancestor_slice(slice.id) anc
      WHERE anc.category GLOB "*toplevel*" or anc.category GLOB "*toplevel.viz*") = 0
),
-- Select slices from "Java" category which do not have another "Java" or
-- "toplevel" slice as parent. In the longer term they should probably belong
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- to "toplevel" category as well, but for now this will have to do. Ensure
-- that "Java" slices do not include "toplevel" slices as those would be
-- handled elsewhere.
non_embedded_java_slices AS (
  SELECT
    id,
    name AS task_name,
    "java" as task_type
  FROM slice s
  WHERE
    _java_not_top_level_category(category)
    AND (SELECT count()
      FROM ancestor_slice(s.id) s2
      WHERE s2.category GLOB "*toplevel*" OR s2.category GLOB "*Java*") = 0
),
-- Generate full names for tasks with java views.
java_views_tasks AS (
  SELECT
    id,
    printf('%s(java_views=%s)', kind, java_views) AS task_name,
    _get_java_views_task_type(kind) AS task_type
  FROM _chrome_slices_with_java_views
),
scheduler_tasks AS (
  SELECT
    id,
    name as task_name,
    "scheduler" as task_type
  FROM chrome_scheduler_tasks
),
-- Select scheduler tasks which are used to run mojo messages and use the mojo names
-- as full names for these slices.
-- We restrict this to specific scheduler tasks which are expected to run mojo
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- tasks due to sync mojo events, which also emit similar events.
scheduler_tasks_with_mojo AS (
  SELECT
    -- We use the "RunTask" as the task, and pick up the name from its child
    -- "Receive mojo message" event.
    task.id,
    receive_message.task_name,
    "mojo" AS task_type
  FROM
    chrome_scheduler_tasks task
  JOIN _DESCENDANT_MOJO_SLICE(task.id) receive_message
  WHERE
    task.posted_from IN (
      "mojo/public/cpp/system/simple_watcher.cc:Notify",
      "mojo/public/cpp/system/simple_watcher.cc:ArmOrNotify",
      "mojo/public/cpp/bindings/lib/connector.cc:PostDispatchNextMessageFromPipe",
      "ipc/ipc_mojo_bootstrap.cc:Accept")
),
navigation_tasks AS (
  WITH tasks_with_readable_names AS (
    SELECT
      id,
      _human_readable_navigation_task_name(task_name) as readable_name,
      IFNULL(_extract_frame_type(id), 'unknown frame type') as frame_type
    FROM
      scheduler_tasks_with_mojo
  )
  SELECT
    id,
    printf("%s (%s)", readable_name, frame_type) as task_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'navigation_task' AS task_type
  FROM tasks_with_readable_names
  WHERE readable_name IS NOT NULL
),
-- Add scheduler and mojo full names to non-embedded slices from
-- the "toplevel" category, with mojo ones taking precedence.
non_embedded_toplevel_slices_with_task_name AS (
  SELECT
    task.id AS id,
    COALESCE(
        navigation.task_name,
        java_views.task_name,
        mojo.task_name,
        scheduler.task_name,
        task.name
    ) AS name,
    COALESCE(
        navigation.task_type,
        java_views.task_type,
        mojo.task_type,
        scheduler.task_type,
        "other"
    ) AS task_type
  FROM non_embedded_toplevel_slices task
  LEFT JOIN scheduler_tasks_with_mojo mojo ON mojo.id = task.id
  LEFT JOIN scheduler_tasks scheduler ON scheduler.id = task.id
  LEFT JOIN java_views_tasks java_views ON java_views.id = task.id
  LEFT JOIN navigation_tasks navigation ON navigation.id = task.id
)
-- Merge slices from toplevel and Java categories.
SELECT * FROM non_embedded_toplevel_slices_with_task_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(UNION ALL
SELECT * FROM non_embedded_java_slices
ORDER BY id;

-- A list of "Chrome tasks": top-level execution units (e.g. scheduler tasks /
-- IPCs / system callbacks) run by Chrome. For a given thread, the slices
-- corresponding to these tasks will not intersect.
CREATE PERFETTO VIEW chrome_tasks(
  -- Id for the given task, also the id of the slice this task corresponds to.
  id LONG,
  -- Name for the given task.
  name STRING,
  -- Type of the task (e.g. "scheduler").
  task_type STRING,
  -- Thread name.
  thread_name STRING,
  -- Utid.
  utid LONG,
  -- Process name.
  process_name STRING,
  -- Upid.
  upid LONG,
  -- Alias of |slice.ts|.
  ts TIMESTAMP,
  -- Alias of |slice.dur|.
  dur DURATION,
  -- Alias of |slice.track_id|.
  track_id LONG,
  -- Alias of |slice.category|.
  category STRING,
  -- Alias of |slice.arg_set_id|.
  arg_set_id LONG,
  -- Alias of |slice.thread_ts|.
  thread_ts TIMESTAMP,
  -- Alias of |slice.thread_dur|.
  thread_dur DURATION,
  -- STRING    Legacy alias for |name|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  full_name STRING
) AS
SELECT
  cti.id,
  cti.name,
  task_type,
  thread.name AS thread_name,
  thread.utid,
  process.name AS process_name,
  thread.upid,
  s.ts,
  s.dur,
  s.track_id,
  s.category,
  s.arg_set_id,
  s.thread_ts,
  s.thread_dur,
  cti.name as full_name
FROM _chrome_tasks cti
JOIN slice s ON cti.id = s.id
JOIN thread_track tt ON s.track_id = tt.id
JOIN thread USING (utid)
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kChromeVsyncIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- A simple table that checks the time between VSync (this can be used to
-- determine if we're refreshing at 90 FPS or 60 FPS).
--
-- Note: In traces without the "Java" category there will be no VSync
--       TraceEvents and this table will be empty.
CREATE PERFETTO TABLE chrome_vsync_intervals(
  -- Slice id of the vsync slice.
  slice_id LONG,
  -- Timestamp of the vsync slice.
  ts TIMESTAMP,
  -- Duration of the vsync slice.
  dur DURATION,
  -- Track id of the vsync slice.
  track_id LONG,
  -- Duration until next vsync arrives.
  time_to_next_vsync LONG
) AS
SELECT
  slice_id,
  ts,
  dur,
  track_id,
  LEAD(ts) OVER(PARTITION BY track_id ORDER BY ts) - ts AS time_to_next_vsync
FROM slice
WHERE name = "VSync"
ORDER BY track_id, ts;

-- Function: compute the average Vysnc interval of the
-- gesture (hopefully this would be either 60 FPS for the whole gesture or 90
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- FPS but that isnt always the case) on the given time segment.
-- If the trace doesnt contain the VSync TraceEvent we just fall back on
-- assuming its 60 FPS (this is the 1.6e+7 in the COALESCE which
-- corresponds to 16 ms or 60 FPS).
CREATE PERFETTO FUNCTION chrome_calculate_avg_vsync_interval(
  -- Interval start time.
  begin_ts TIMESTAMP,
  -- Interval end time.
  end_ts TIMESTAMP
)
-- The average vsync interval on this time segment
-- or 1.6e+7, if trace doesn't contain the VSync TraceEvent.
RETURNS DOUBLE AS
SELECT
  COALESCE((
    SELECT
      cast_double!(AVG(time_to_next_vsync))
    FROM chrome_vsync_intervals in_query
    WHERE
      time_to_next_vsync IS NOT NULL AND
      in_query.ts > $begin_ts AND
      in_query.ts < $end_ts
  ), 1e+9 / 60);

)_d3l1m1t3r_"
;

const char kChromeWebContentInteractions[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Chrome web content interactions (InteractionToFirstPaint), including
-- associated high-level metrics and properties.
--
-- Multiple events may occur for the same interaction; each row in this table
-- represents the primary (longest) event for the interaction.
--
-- Web content interactions are discrete, as opposed to sustained (e.g.
-- scrolling); and only occur with the web content itself, as opposed to other
-- parts of Chrome (e.g. omnibox). Interaction events include taps, clicks,
-- keyboard input (typing), and drags.
CREATE PERFETTO TABLE chrome_web_content_interactions(
  -- Unique id for this interaction.
  id LONG,
  -- Start timestamp of the event. Because multiple events may occur for the
  -- same interaction, this is the start timestamp of the longest event.
  ts TIMESTAMP,
  -- Duration of the event. Because multiple events may occur for the same
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- interaction, this is the duration of the longest event.
  dur DURATION,
  -- The interaction type.
  interaction_type STRING,
  -- The total duration of all events that occurred for the same interaction.
  total_duration_ms LONG,
  -- The process id this event occurred on.
  renderer_upid LONG
) AS
SELECT
  id,
  ts,
  dur,
  EXTRACT_ARG(arg_set_id, 'web_content_interaction.type') AS interaction_type,
  EXTRACT_ARG(
    arg_set_id,
    'web_content_interaction.total_duration_ms'
  ) AS total_duration_ms,
  upid AS renderer_upid
FROM process_slice
WHERE name = 'Web Interaction';

)_d3l1m1t3r_"
;

const char kChromeScrollJankPredictorError[] = R"_d3l1m1t3r_(-- Copyright 2024 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file implements the scrolling predictor jank metric, as is
-- implemented in cc/metrics/predictor_jank_tracker.cc. See comments in that
-- file to get additional context on how the metric is implemented.
--
-- "Delta" here refers to how much (in pixels) the page offset changed for a
-- given frame due to a scroll.
--
-- For more details please check the following document:
-- http://doc/1Y0u0Tq5eUZff75nYUzQVw6JxmbZAW9m64pJidmnGWsY.

INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_offsets;

-- The maximum delta value between three consecutive frames, used to determine
-- whether the sequence in the scroll is fast or slow; the sequence speed is
-- used to determine whether the sequence includes any predictor jank.
CREATE PERFETTO FUNCTION _get_slow_scroll_delta_threshold()
RETURNS DOUBLE AS
SELECT 7.0;

-- The threshold for the ratio of the delta of middle frame to tbe deltas of its
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- neighbors in a sequence of three frames, if the sequence is considered
-- "slow".
CREATE PERFETTO FUNCTION _get_slow_scroll_janky_threshold()
RETURNS DOUBLE AS
SELECT 1.4;

-- The threshold for the ratio of the delta of middle frame to tbe deltas of its
-- neighbors in a sequence of three frames, if the sequence is considered
-- "fast".
CREATE PERFETTO FUNCTION _get_fast_scroll_janky_threshold()
RETURNS DOUBLE AS
SELECT 1.2;

-- Determine the acceptable threshold (see _get_slow_scroll_janky_threshold()
-- and _get_fast_scroll_janky_threshold()) based on the maximum delta value
-- between three consecutive frames.
CREATE PERFETTO FUNCTION _get_scroll_jank_threshold(
  d1 DOUBLE,
  d2 DOUBLE,
  d3 DOUBLE
)
RETURNS DOUBLE AS
SELECT
  CASE
    WHEN MAX(MAX($d1, $d2), $d3) <= _get_slow_scroll_delta_threshold()
      THEN _get_slow_scroll_janky_threshold()
    ELSE _get_fast_scroll_janky_threshold()
  END;

-- Calculate the predictor jank of three consecutive frames, if it is above the
-- threshold. Anything below the threshold is not considered jank.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION _get_predictor_jank(
  d1 DOUBLE,
  d2 DOUBLE,
  d3 DOUBLE,
  threshold DOUBLE
)
RETURNS DOUBLE AS
SELECT
  CASE
    WHEN $d2/MAX($d1, $d3) >= $threshold
      THEN $d2/MAX($d1, $d3) - $threshold
    WHEN MIN($d1, $d3)/$d2 >= $threshold
      THEN MIN($d1, $d3)/$d2 - $threshold
    ELSE 0
  END;

CREATE PERFETTO TABLE _deltas_and_neighbors AS
SELECT
  scroll_id,
  event_latency_slice_id,
  scroll_update_id,
  ts,
  delta_y,
  relative_offset_y,
  LAG(IFNULL(delta_y, 0.0))
    OVER (PARTITION BY scroll_id ORDER BY ts ASC) AS prev_delta,
  LEAD(IFNULL(delta_y, 0.0))
    OVER (PARTITION BY scroll_id ORDER BY ts ASC) AS next_delta
FROM chrome_presented_scroll_offsets;

CREATE PERFETTO TABLE _deltas_and_neighbors_with_threshold AS
SELECT
  scroll_id,
  event_latency_slice_id,
  scroll_update_id,
  ts,
  delta_y,
  relative_offset_y,
  prev_delta,
  next_delta,
  _get_scroll_jank_threshold(ABS(prev_delta), ABS(delta_y), ABS(next_delta))
    AS delta_threshold
FROM _deltas_and_neighbors
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE delta_y IS NOT NULL
  AND prev_delta IS NOT NULL
  AND next_delta IS NOT NULL;

-- The scrolling offsets and predictor jank values for the actual (applied)
-- scroll events.
CREATE PERFETTO TABLE chrome_predictor_error(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id LONG,
  -- An ID for this particular EventLatency regardless of it being presented or
  -- not.
  event_latency_slice_id LONG,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
  -- event_latency_id) that it was presented with.
  scroll_update_id LONG,
  -- Presentation timestamp.
  present_ts TIMESTAMP,
  -- The delta in raw coordinates between this presented EventLatency and the
  -- previous presented frame.
  delta_y DOUBLE,
  -- The pixel offset of this presented EventLatency compared to the initial
  -- one.
  relative_offset_y DOUBLE,
  -- The delta in raw coordinates of the previous scroll update event.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  prev_delta DOUBLE,
  -- The delta in raw coordinates of the subsequent scroll update event.
  next_delta DOUBLE,
  -- The jank value based on the discrepancy between scroll predictor
  -- coordinates and the actual deltas between scroll update events.
  predictor_jank DOUBLE,
  -- The threshold used to determine if jank occurred.
  delta_threshold DOUBLE
)
AS
SELECT
  scroll_id,
  event_latency_slice_id,
  scroll_update_id,
  ts AS present_ts,
  delta_y,
  relative_offset_y,
  prev_delta,
  next_delta,
  _get_predictor_jank(
    ABS(prev_delta), ABS(delta_y), ABS(next_delta), delta_threshold)
      AS predictor_jank,
  delta_threshold
FROM _deltas_and_neighbors_with_threshold;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankCauseMap[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.event_latency_description;

-- Source of truth of the descriptions of EventLatency-based scroll jank causes.
CREATE PERFETTO TABLE chrome_scroll_jank_cause_descriptions (
  -- The name of the EventLatency stage.
  event_latency_stage STRING,
  -- The process where the cause of scroll jank occurred.
  cause_process STRING,
  -- The thread where the cause of scroll jank occurred.
  cause_thread STRING,
  -- A description of the cause of scroll jank.
  cause_description STRING
) AS
WITH cause_descriptions(
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description)
AS (
VALUES
  ('GenerationToBrowserMain', 'Browser', 'CrBrowserMain',
    'This also corresponds to a matching InputLatency::TouchMove. Key ' ||
    'things to look for: Browser Main thread (CrBrowserMain) is busy, often ' ||
    'running tasks. The true cause can be confirmed by checking which tasks ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'are being run on CrBrowserMain, or checking any ScopedBlockingCall ' ||
    'slices during this stage from a ThreadPoolForegroundWorker, or ' ||
    'checking if the NetworkService is busy. Common causes may include page' ||
    'navigations (same document and new pages), slow BeginMainFrames, and ' ||
    'Java Choreographer slowdowns.'),
  ('RendererCompositorQueueingDelay', 'Renderer', 'Compositor',
    'The renderer needs to decide to produce a frame in response to a ' ||
    'BeginFrame signal. Sometimes it can not because it is waiting on the ' ||
    'RendererMain thread to do touch targeting or javascript handling or ' ||
    'other such things causing a long queuing delay after it has already ' ||
    'started the scroll (so the TouchStart has been processed).'),
  ('RendererCompositorQueueingDelay', 'GPU', 'VizCompositorThread',
    'Waiting for a BeginFrame to be sent. Key things to look for: check if ' ||
    'a fling occurred before or during the scroll; flings produce a single ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'input and result in multiple inputs coalescing into a single frame.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'VizCompositorThread',
    'A delay when the VizCompositor is waiting for the frame, but may be ' ||
    'connected to other processes and threads. Key things to look for: ' ||
    'check the BeginFrame task that finished during this EventLatency. The ' ||
    'VizCompositor holds onto the frame/does not send it on. Alternately ' ||
    'the system may be holding on to the buffer.'),
  ('ReceiveCompositorFrameToStartDraw', 'GPU', 'CrGpuMain',
    'Key things to look for: if the GPU Main thread is busy, and does not ' ||
    'release the buffer; specific causes will be on the GPU Main thread. If ' ||
    'this thread is not busy, the buffer may be held by the system instead.'),
  ('ReceiveCompositorFrameToStartDraw', 'Browser', 'CrBrowserMain',
    'Key things to look for: the toolbar on the Browser may be blocked by ' ||
    'other tasks.'),
  ('BufferReadyToLatch', 'GPU', 'VizCompositorThread',
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'Often a scheduling issue. The frame was submitted, but missed the ' ||
    'latch in the system that was received from the previous frame. The ' ||
    'system only latches a buffer once per frame; when the latch deadline ' ||
    'is missed, the system is forced to wait for another vsync interval to ' ||
    'latch again. Key things to look for: whether the event duration before ' ||
    'BufferReadyToLatch stage of the previous EventLatency is longer or ' ||
    'shorter than the event duration before BufferReadyToLatch in the ' ||
    'current EventLatency. If this duration is longer, then this is a ' ||
    'System problem. If this duration is shorter, then it is a Chrome ' ||
    'problem. The previous frame may have been drawn too quickly, or the ' ||
    'GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'VizCompositorThread',
    'May be attributed to a scheduling issue as with BufferReadyToLatch. ' ||
    'The frame was submitted, but missed the latch in the system that was ' ||
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'received from the previous frame. The system only latches a buffer ' ||
    'once per frame; when the latch deadline is missed, the system is ' ||
    'forced to wait for another vsync interval to latch again. Key things ' ||
    'to look for: whether the event duration before BufferReadyToLatch ' ||
    'stage of the previous EventLatency is longer or shorter than the event ' ||
    'duration before BufferReadyToLatch in the current EventLatency. If ' ||
    'this duration is longer, then this is a System problem. If this ' ||
    'duration is shorter, then it is a Chrome problem. The previous frame ' ||
    'may have been drawn too quickly, or the GPU may be delayed.'),
  ('SwapEndToPresentationCompositorFrame', 'GPU', 'CrGpuMain',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the GPU main thread may ' ||
    'be descheduled or busy. If surfaceflinger is available, check there as ' ||
    'well.'),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('SwapEndToPresentationCompositorFrame', 'GPU', 'surfaceflinger',
    'Key things to look for: whether StartDrawToBufferAvailable is also ' ||
    'present during this EventLatency. If so, then the VizCompositor has ' ||
    'not received a signal from surfaceflinger to start writing into the ' ||
    'buffer.'))
SELECT
  event_latency_stage,
  cause_process,
  cause_thread,
  cause_description
FROM cause_descriptions;

-- Combined description of scroll jank cause and associated event latency stage.
CREATE PERFETTO VIEW chrome_scroll_jank_causes_with_event_latencies(
  -- The name of the EventLatency stage.
  name STRING,
  -- Description of the EventLatency stage.
  description STRING,
  -- The process name that may cause scroll jank.
  cause_process STRING,
  -- The thread name that may cause scroll jank. The thread will be on the
  -- cause_process.
  cause_thread STRING,
  -- Description of the cause of scroll jank on this process and thread.
  cause_description STRING
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  stages.name,
  stages.description,
  causes.cause_process,
  causes.cause_thread,
  causes.cause_description
FROM chrome_event_latency_stage_descriptions stages
LEFT JOIN chrome_scroll_jank_cause_descriptions causes
    ON causes.event_latency_stage = stages.name;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankCauseUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE slices.with_context;

-- Function to retrieve the upid for a surfaceflinger, as these are attributed
-- to the GPU but are recorded on a different data source (and track group).
CREATE PERFETTO FUNCTION _get_process_id_for_surfaceflinger()
-- The process id for surfaceflinger.
RETURNS LONG AS
SELECT
 upid
FROM process
WHERE name GLOB '*surfaceflinger*'
LIMIT 1;

-- Map a generic process type to a specific name or substring of a name that
-- can be found in the trace process table.
CREATE PERFETTO TABLE _process_type_to_name (
  -- The process type: one of 'Browser' or 'GPU'.
  process_type STRING,
  -- The process name for Chrome traces.
  process_name STRING,
  -- Substring identifying the process for system traces.
  process_glob STRING
) AS
WITH process_names (
  process_type,
  process_name,
  process_glob
  )
AS (
VALUES
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ('Browser', 'Browser', '*.chrome'),
  ('GPU', 'Gpu', '*.chrome*:privileged_process*'))
SELECT
  process_type,
  process_name,
  process_glob
FROM process_names;

CREATE PERFETTO FUNCTION _get_process_name(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- The process name
RETURNS STRING AS
SELECT
    process_name
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

CREATE PERFETTO FUNCTION _get_process_glob(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
-- A substring of the process name that can be used in GLOB calculations.
RETURNS STRING AS
SELECT
    process_glob
FROM _process_type_to_name
WHERE process_type = $type
LIMIT 1;

-- TODO(b/309937901): Add chrome instance id for multiple chromes/webviews in a
-- trace, as this may result in  multiple browser and GPU processes.
-- Function to retrieve the chrome process ID for a specific process type. Does
-- not retrieve the Renderer process, as this is determined when the
-- EventLatency is known. See function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- _get_renderer_upid_for_event_latency below.
CREATE PERFETTO FUNCTION _get_process_id_by_type(
  -- The process type: one of 'Browser' or 'GPU'.
  type STRING
)
RETURNS TABLE (
    -- The process id for the process type.
    upid JOINID(process.id)
) AS
SELECT
  upid
FROM process
WHERE name = _get_process_name($type)
  OR name GLOB _get_process_glob($type);

-- Function to retrieve the chrome process ID that a given EventLatency slice
-- occurred on. This is the Renderer process.
CREATE PERFETTO FUNCTION _get_renderer_upid_for_event_latency(
  -- The slice id for an EventLatency slice.
  id LONG
)
-- The process id for an EventLatency slice. This is the Renderer process.
RETURNS LONG AS
SELECT
  upid
FROM process_slice
WHERE id = $id;

-- Helper function to retrieve all of the upids for a given process, thread,
-- or EventLatency.
CREATE PERFETTO FUNCTION _processes_by_type_for_event_latency(
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  type STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The name of the thread.
  thread STRING,
  -- The slice id of an EventLatency slice.
  event_latency_id LONG)
RETURNS TABLE (
    upid JOINID(process.id)
) AS
WITH all_upids AS (
  -- Renderer process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_renderer_upid_for_event_latency($event_latency_id) AS upid
  WHERE $type = 'Renderer'
  UNION ALL
  -- surfaceflinger upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    _get_process_id_for_surfaceflinger() AS upid
  WHERE $type = 'GPU' AND $thread = 'surfaceflinger'
  UNION ALL
  -- Generic Browser and GPU process upids
  SELECT
    $type AS process,
    $thread AS thread,
    $event_latency_id AS event_latency_id,
    upid
  FROM _get_process_id_by_type($type)
  WHERE $type = 'Browser'
    OR ($type = 'GPU' AND $thread != 'surfaceflinger')
)
SELECT
  upid
FROM all_upids;

-- Function to retrieve the thread id of the thread on a particular process if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- there are any slices during a particular EventLatency slice duration; this
-- upid/thread combination refers to a cause of Scroll Jank.
CREATE PERFETTO FUNCTION chrome_select_scroll_jank_cause_thread(
  -- The slice id of an EventLatency slice.
  event_latency_id LONG,
  -- The process type that the thread is on: one of 'Browser', 'Renderer' or
  -- 'GPU'.
  process_type STRING,
  -- The name of the thread.
  thread_name STRING)
RETURNS TABLE (
  -- The utid associated with |thread| on the process with |upid|.
  utid JOINID(thread.id)
) AS
WITH threads AS (
  SELECT
    utid
  FROM thread
  WHERE upid IN
    (
      SELECT DISTINCT
        upid
      FROM _processes_by_type_for_event_latency(
        $process_type,
        $thread_name,
        $event_latency_id)
    )
    AND name = $thread_name
)
SELECT
 DISTINCT utid
FROM thread_slice
WHERE utid IN
  (
    SELECT
      utid
    FROM threads
  )
  AND ts >= (SELECT ts FROM slice WHERE id = $event_latency_id LIMIT 1)
  AND ts <= (SELECT ts + dur FROM slice WHERE id = $event_latency_id LIMIT 1);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankIntervals[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- Selects EventLatency slices that correspond with janks in a scroll. This is
-- based on the V3 version of scroll jank metrics.
CREATE PERFETTO TABLE chrome_janky_event_latencies_v3(
  -- The slice id.
  id LONG,
  -- The start timestamp of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The track_id for the slice.
  track_id LONG,
  -- The name of the slice (EventLatency).
  name STRING,
  -- The stage of EventLatency that the caused the jank.
  cause_of_jank STRING,
  -- The stage of cause_of_jank that caused the jank.
  sub_cause_of_jank STRING,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count LONG,
  -- The start timestamp where frame presentation was delayed.
  frame_jank_ts TIMESTAMP,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The duration in ms of the delay in frame presentation.
  frame_jank_dur LONG
) AS
SELECT
  s.id,
  s.ts,
  s.dur,
  s.track_id,
  s.name,
  e.cause_of_jank,
  e.sub_cause_of_jank,
  cast_int!((e.delay_since_last_frame/e.vsync_interval) - 1)
    AS delayed_frame_count,
  cast_int!(s.ts + s.dur - ((e.delay_since_last_frame - e.vsync_interval) * 1e6))
    AS frame_jank_ts,
  cast_int!((e.delay_since_last_frame - e.vsync_interval) * 1e6)
    AS frame_jank_dur
FROM chrome_gesture_scroll_events s
JOIN chrome_janky_frames e
  ON s.id = e. event_latency_id;

-- Frame presentation interval is the delta between when the frame was supposed
-- to be presented and when it was actually presented.
CREATE PERFETTO VIEW chrome_janky_frame_presentation_intervals(
  -- Unique id.
  id LONG,
  -- The start timestamp of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- How many vsyncs this frame missed its deadline by.
  delayed_frame_count LONG,
  -- The stage of EventLatency that the caused the jank.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cause_of_jank STRING,
  -- The stage of cause_of_jank that caused the jank.
  sub_cause_of_jank STRING,
  -- The id of the associated event latency in the slice table.
  event_latency_id LONG
) AS
SELECT
  ROW_NUMBER() OVER(ORDER BY frame_jank_ts) AS id,
  frame_jank_ts AS ts,
  frame_jank_dur AS dur,
  delayed_frame_count,
  cause_of_jank,
  sub_cause_of_jank,
  id AS event_latency_id
FROM chrome_janky_event_latencies_v3;

-- Scroll jank frame presentation stats for individual scrolls.
CREATE PERFETTO TABLE chrome_scroll_stats(
  -- Id of the individual scroll.
  scroll_id LONG,
  -- The number of frames in the scroll.
  frame_count LONG,
  -- The number of missed vsyncs in the scroll.
  missed_vsyncs LONG,
  -- The number presented frames in the scroll.
  presented_frame_count LONG,
  -- The number of janky frames in the scroll.
  janky_frame_count LONG,
  -- The % of frames that janked in the scroll.
  janky_frame_percent DOUBLE
) AS
WITH vsyncs AS (
  SELECT
    COUNT() AS presented_vsync_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    scroll.id AS scroll_id
  FROM chrome_unique_frame_presentation_ts frame
  JOIN chrome_scrolls scroll
    ON frame.presentation_timestamp >= scroll.ts
    AND frame.presentation_timestamp <= scroll.ts + scroll.dur
  GROUP BY scroll_id),
missed_vsyncs AS (
  SELECT
    cast_int!(SUM((delay_since_last_frame / vsync_interval) - 1))
      AS total_missed_vsyncs,
    scroll_id
  FROM chrome_janky_frames
  GROUP BY scroll_id),
frame_stats AS (
  SELECT
    scroll_id,
    num_frames AS presented_frame_count,
    IFNULL(num_janky_frames, 0) AS janky_frame_count,
    ROUND(IFNULL(scroll_jank_percentage, 0), 2) AS janky_frame_percent
  FROM chrome_frames_per_scroll
)
SELECT
  vsyncs.scroll_id,
  presented_vsync_count + IFNULL(total_missed_vsyncs, 0) AS frame_count,
  total_missed_vsyncs AS missed_vsyncs,
  presented_frame_count,
  janky_frame_count,
  janky_frame_percent
FROM vsyncs
LEFT JOIN missed_vsyncs
  USING (scroll_id)
LEFT JOIN frame_stats
  USING (scroll_id);

-- Defines slices for all of janky scrolling intervals in a trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE chrome_scroll_jank_intervals_v3(
  -- The unique identifier of the janky interval.
  id LONG,
  -- The start timestamp of the janky interval.
  ts TIMESTAMP,
  -- The duration of the janky interval.
  dur DURATION
) AS
-- Sub-table to retrieve all janky slice timestamps. Ordering calculations are
-- based on timestamps rather than durations.
WITH janky_latencies AS (
  SELECT
    s.frame_jank_ts AS start_ts,
    s.frame_jank_ts + s.frame_jank_dur AS end_ts
  FROM chrome_janky_event_latencies_v3 s),
-- Determine the local maximum timestamp for janks thus far; this will allow
-- us to coalesce all earlier events up to the maximum.
ordered_jank_end_ts AS (
  SELECT
    *,
    MAX(end_ts) OVER (
      ORDER BY start_ts ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
      AS max_end_ts_so_far
  FROM janky_latencies),
-- Determine the local minimum timestamp for janks thus far; this will allow
-- us to coalesce all later events up to the nearest local maximum.
range_starts AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    *,
    CASE
      -- This is a two-pass calculation to calculate the first event in the
      -- group. An event is considered the first event in a group if all events
      -- which started before it also finished the current one started.
      WHEN start_ts <= 1 + LAG(max_end_ts_so_far) OVER (ORDER BY start_ts)
        THEN 0
      ELSE 1
    END AS range_start
  FROM ordered_jank_end_ts),
-- Assign an id to allow coalescing of individual slices.
range_groups AS (
  SELECT
    *,
    SUM(range_start) OVER (ORDER BY start_ts) AS range_group
  FROM range_starts)
-- Coalesce all slices within an interval.
SELECT
  range_group AS id,
  MIN(start_ts) AS ts,
  MAX(end_ts) - MIN(start_ts) AS dur
FROM range_groups
GROUP BY range_group;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankV3Cause[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Finds all slices with a direct parent with the given parent_id.
CREATE PERFETTO FUNCTION _direct_children_slice(
  -- Id of the parent slice.
  parent_id LONG)
RETURNS TABLE(
  -- Alias for `slice.id`.
  id LONG,
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts TIMESTAMP,
  -- Alias for `slice.dur`.
  dur DURATION,
  -- Alias for `slice.category`.
  category LONG,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id LONG,
  -- Alias for `slice.arg_set_id`.
  arg_set_id LONG,
  -- Alias for `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
WHERE parent_id = $parent_id;

-- Given two slice Ids A and B, find the maximum difference
-- between the durations of it's direct children with matching names
-- for example if slice A has children named (X, Y, Z) with durations of (10, 10, 5)
-- and slice B has children named (X, Y) with durations of (9, 9), the function will return
-- the slice id of the slice named Z that is A's child, as no matching slice named Z was found
-- under B, making 5 - 0 = 5 the maximum delta between both slice's direct children
CREATE PERFETTO FUNCTION chrome_get_v3_jank_cause_id(
  -- The slice id of the parent slice that we want to cause among it's children.
  janky_slice_id LONG,
  -- The slice id of the parent slice that's the reference in comparison to
  -- |janky_slice_id|.
  prev_slice_id LONG
)
-- The slice id of the breakdown that has the maximum duration delta.
RETURNS LONG AS
WITH
  current_breakdowns AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      *
    FROM _direct_children_slice($janky_slice_id)
  ),
  prev_breakdowns AS (
    SELECT
      *
    FROM _direct_children_slice($prev_slice_id)
  ),
  joint_breakdowns AS (
    SELECT
      cur.id AS breakdown_id,
      (cur.dur - COALESCE(prev.dur, 0)) AS breakdown_delta
    FROM current_breakdowns cur
    LEFT JOIN prev_breakdowns prev ON
      cur.name = prev.name
  ),
  max_breakdown AS (
    SELECT
      MAX(breakdown_delta) AS breakdown_delta,
      breakdown_id
    FROM joint_breakdowns
  )
  SELECT
    breakdown_id
  FROM max_breakdown;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollJankV3[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- Hardware info is useful when using sql metrics for analysis
-- in BTP.
INCLUDE PERFETTO MODULE chrome.metadata;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3_cause;
INCLUDE PERFETTO MODULE chrome.scroll_jank.utils;

-- Given a slice id, returns the name of the slice.
CREATE PERFETTO FUNCTION _slice_name_from_id(
  -- The slice id which we need the name for.
  id LONG
)
-- The name of slice with the given id.
RETURNS STRING AS
SELECT
  name
FROM slice
WHERE $id = id;

-- Grabs all gesture updates with respective scroll ids and start/end
-- timestamps, regardless of being presented.
CREATE PERFETTO TABLE chrome_gesture_scroll_updates(
  -- The start timestamp of the scroll.
  ts TIMESTAMP,
  -- The duration of the scroll.
  dur DURATION,
  -- Slice id for the scroll.
  id LONG,
  -- The id of the scroll update event.
  scroll_update_id LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The id of the scroll.
  scroll_id LONG,
  -- Whether this input event was presented.
  is_presented BOOL,
  -- Frame presentation timestamp aka the timestamp of the
  -- SwapEndToPresentationCompositorFrame substage.
  presentation_timestamp LONG,
  -- EventLatency event type.
  event_type STRING
) AS
SELECT
  ts,
  dur,
  id,
  scroll_update_id,
  scroll_id,
  is_presented,
  presentation_timestamp,
  event_type
FROM chrome_gesture_scroll_events
WHERE event_type IN (
  'GESTURE_SCROLL_UPDATE',
  'FIRST_GESTURE_SCROLL_UPDATE',
  'INERTIAL_GESTURE_SCROLL_UPDATE',
  'GESTURE_PINCH_UPDATE'
);

CREATE PERFETTO TABLE _presented_gesture_scrolls AS
SELECT
  id,
  ts,
  dur,
  scroll_update_id,
  scroll_id,
  presentation_timestamp,
  event_type
FROM chrome_gesture_scroll_updates
WHERE is_presented = true
ORDER BY ts ASC;

-- Scroll updates, corresponding to all input events that were converted to a
-- presented scroll update.
CREATE PERFETTO TABLE chrome_presented_gesture_scrolls(
  -- Minimum slice id for input presented in this frame, the non-presented input.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  id LONG,
  -- The start timestamp for producing the frame.
  ts TIMESTAMP,
  -- The duration between producing and presenting the frame.
  dur DURATION,
  -- The timestamp of the last input that arrived and got presented in the frame.
  last_presented_input_ts TIMESTAMP,
  -- The id of the scroll update event, a unique identifier to the gesture.
  scroll_update_id LONG,
  -- The id of the ongoing scroll.
  scroll_id LONG,
  -- Frame presentation timestamp.
  presentation_timestamp LONG,
  -- EventLatency event type.
  event_type STRING
) AS
WITH
scroll_updates_with_presentation_info as MATERIALIZED (
  SELECT
    id,
    ts,
    -- For each scroll update, find the latest presented update which
    -- started before it.
    (
      SELECT id
      FROM _presented_gesture_scrolls _presented
      WHERE _presented.ts <= scroll_update.ts
      ORDER BY ts DESC
      LIMIT 1
     ) as presented_to_scroll_update_slice_id
  FROM chrome_gesture_scroll_updates scroll_update
  ORDER BY presented_to_scroll_update_slice_id, ts
)_d3l1m1t3r_"
R"_d3l1m1t3r_()
SELECT
  id,
  ts,
  dur,
  -- Find the latest input that was presented in this scroll update.
  (
    SELECT presentation_info.ts
    FROM scroll_updates_with_presentation_info presentation_info
    WHERE
      presentation_info.presented_to_scroll_update_slice_id =
        _presented_gesture_scrolls.id
    ORDER BY ts DESC
    LIMIT 1
  ) as last_presented_input_ts,
  scroll_update_id,
  scroll_id,
  presentation_timestamp,
  event_type
FROM _presented_gesture_scrolls;

-- Associate every trace_id with it's perceived delta_y on the screen after
-- prediction.
CREATE PERFETTO TABLE chrome_scroll_updates_with_deltas(
  -- The id of the scroll update event.
  scroll_update_id LONG,
  -- The perceived delta_y on the screen post prediction.
  delta_y DOUBLE
) AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.provided_to_compositor_delta_y') AS delta_y
FROM slice
WHERE name = "InputHandlerProxy::HandleGestureScrollUpdate_Result";
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Obtain the subset of input events that were fully presented.
CREATE PERFETTO TABLE chrome_full_frame_view(
  -- ID of the frame.
  id LONG,
  -- Start timestamp of the frame.
  ts TIMESTAMP,
  -- The timestamp of the last presented input.
  last_presented_input_ts TIMESTAMP,
  -- ID of the associated scroll.
  scroll_id LONG,
  -- ID of the associated scroll update.
  scroll_update_id LONG,
  -- ID of the associated EventLatency.
  event_latency_id LONG,
  -- Duration of the associated EventLatency.
  dur DURATION,
  -- Frame presentation timestamp.
  presentation_timestamp LONG
) AS
SELECT
  frames.id,
  frames.ts,
  frames.last_presented_input_ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.id AS event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_presented_gesture_scrolls frames
WHERE frames.event_type in (
          'GESTURE_SCROLL_UPDATE',
          'FIRST_GESTURE_SCROLL_UPDATE',
          'INERTIAL_GESTURE_SCROLL_UPDATE',
          'GESTURE_PINCH_UPDATE')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AND frames.presentation_timestamp IS NOT NULL;

-- Join deltas with EventLatency data.
CREATE PERFETTO TABLE chrome_full_frame_delta_view(
  -- ID of the frame.
  id LONG,
  -- Start timestamp of the frame.
  ts TIMESTAMP,
  -- ID of the associated scroll.
  scroll_id LONG,
  -- ID of the associated scroll update.
  scroll_update_id LONG,
  -- The timestamp of the last presented input.
  last_presented_input_ts TIMESTAMP,
  -- The perceived delta_y on the screen post prediction.
  delta_y DOUBLE,
  -- ID of the associated EventLatency.
  event_latency_id LONG,
  -- Duration of the associated EventLatency.
  dur DURATION,
  -- Frame presentation timestamp.
  presentation_timestamp LONG
) AS
SELECT
  frames.id,
  frames.ts,
  frames.scroll_id,
  frames.scroll_update_id,
  frames.last_presented_input_ts,
  deltas.delta_y,
  frames.event_latency_id,
  frames.dur,
  frames.presentation_timestamp
FROM chrome_full_frame_view frames
LEFT JOIN chrome_scroll_updates_with_deltas deltas
  ON deltas.scroll_update_id = frames.scroll_update_id;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Group all gestures presented at the same timestamp together in
-- a single row.
CREATE PERFETTO TABLE chrome_merged_frame_view(
  -- ID of the frame.
  id LONG,
  -- The timestamp of the last presented input.
  max_start_ts TIMESTAMP,
  -- The earliest frame start timestamp.
  min_start_ts TIMESTAMP,
  -- ID of the associated scroll.
  scroll_id LONG,
  -- ID of the associated scroll update.
  scroll_update_id LONG,
  -- All scroll updates associated with the frame presentation timestamp.
  encapsulated_scroll_ids STRING,
  -- Sum of all perceived delta_y values at the frame presentation timestamp.
  total_delta DOUBLE,
  -- Lists all of the perceived delta_y values at the frame presentation timestamp.
  segregated_delta_y STRING,
  -- ID of the associated EventLatency.
  event_latency_id LONG,
  -- Maximum duration of the associated EventLatency.
  dur DURATION,
  -- Frame presentation timestamp.
  presentation_timestamp LONG
) AS
SELECT
  id,
  MAX(last_presented_input_ts) AS max_start_ts,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  MIN(ts) AS min_start_ts,
  scroll_id,
  scroll_update_id,
  GROUP_CONCAT(scroll_update_id,',') AS encapsulated_scroll_ids,
  SUM(delta_y) AS total_delta,
  GROUP_CONCAT(delta_y, ',') AS segregated_delta_y,
  event_latency_id,
  MAX(dur) AS dur,
  presentation_timestamp
FROM chrome_full_frame_delta_view
GROUP BY presentation_timestamp
ORDER BY presentation_timestamp;

-- View contains all chrome presented frames during gesture updates
-- while calculating delay since last presented which usually should
-- equal to |VSYNC_INTERVAL| if no jank is present.
CREATE PERFETTO TABLE chrome_frame_info_with_delay(
  -- gesture scroll slice id.
  id LONG,
  -- OS timestamp of the last touch move arrival within a frame.
  max_start_ts TIMESTAMP,
  -- OS timestamp of the first touch move arrival within a frame.
  min_start_ts TIMESTAMP,
  -- The scroll which the touch belongs to.
  scroll_id LONG,
  -- ID of the associated scroll update.
  scroll_update_id LONG,
  -- Trace ids of all frames presented in at this vsync.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  encapsulated_scroll_ids STRING,
  -- Summation of all delta_y of all gesture scrolls in this frame.
  total_delta DOUBLE,
  -- All delta y of all gesture scrolls comma separated, summing those gives |total_delta|.
  segregated_delta_y STRING,
  -- Event latency id of the presented frame.
  event_latency_id LONG,
  -- Duration of the EventLatency.
  dur DURATION,
  -- Timestamp at which the frame was shown on the screen.
  presentation_timestamp LONG,
  -- Time elapsed since the previous frame was presented, usually equals |VSYNC|
  -- if no frame drops happened.
  delay_since_last_frame DOUBLE,
  -- Difference in OS timestamps of inputs in the current and the previous frame.
  delay_since_last_input DOUBLE,
  -- The event latency id that will be used as a reference to determine the
  -- jank cause.
  prev_event_latency_id LONG
) AS
SELECT
  *,
  (presentation_timestamp -
  LAG(presentation_timestamp, 1, presentation_timestamp)
  OVER (PARTITION BY scroll_id ORDER BY presentation_timestamp)) / 1e6 AS delay_since_last_frame,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  (min_start_ts -
  LAG(max_start_ts, 1, min_start_ts)
  OVER (PARTITION BY scroll_id ORDER BY min_start_ts)) / 1e6 AS delay_since_last_input,
  LAG(event_latency_id, 1, -1) OVER (PARTITION BY scroll_id ORDER BY min_start_ts) AS prev_event_latency_id
FROM chrome_merged_frame_view;

-- Calculate |VSYNC_INTERVAL| as the lowest vsync seen in the trace or the
-- minimum delay between frames larger than zero.
--
-- TODO(~M130): Remove the lowest vsync since we should always have vsync_interval_ms.
CREATE PERFETTO TABLE chrome_vsyncs(
  -- The lowest delay between frames larger than zero.
  vsync_interval DOUBLE
) AS
WITH
  trace_vsyncs AS (
    SELECT EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') AS vsync_interval_ms
    FROM
      slice JOIN chrome_frame_info_with_delay
        ON chrome_frame_info_with_delay.event_latency_id = slice.id
    WHERE EXTRACT_ARG(slice.arg_set_id, 'event_latency.vsync_interval_ms') > 0
  )
SELECT
  COALESCE(
    (SELECT MIN(vsync_interval_ms) FROM trace_vsyncs),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    MIN(delay_since_last_frame)) AS vsync_interval
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > 0;

-- Filter the frame view only to frames that had missed vsyncs.
CREATE PERFETTO TABLE chrome_janky_frames_no_cause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame DOUBLE,
  -- Event latency id of the presented frame.
  event_latency_id LONG,
  -- Vsync interval at the time of recording the trace.
  vsync_interval DOUBLE,
  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id LONG,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id LONG
) AS
SELECT
  delay_since_last_frame,
  event_latency_id,
  (SELECT vsync_interval FROM chrome_vsyncs) AS vsync_interval,
  chrome_hardware_class() AS hardware_class,
  scroll_id,
  prev_event_latency_id
FROM chrome_frame_info_with_delay
WHERE delay_since_last_frame > (select vsync_interval + vsync_interval / 2 from chrome_vsyncs)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      AND delay_since_last_input < (select vsync_interval + vsync_interval / 2 from chrome_vsyncs);

-- Janky frame information including the jank cause.
CREATE PERFETTO TABLE chrome_janky_frames_no_subcause(
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame DOUBLE,
  -- Event latency id of the presented frame.
  event_latency_id LONG,
  -- Vsync interval at the time of recording the trace.
  vsync_interval DOUBLE,
  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id LONG,
  -- The event latency id that will be used as a reference to determine the jank cause.
  prev_event_latency_id LONG,
  -- Id of the slice corresponding to the offending stage.
  cause_id LONG
) AS
SELECT
  *,
  chrome_get_v3_jank_cause_id(event_latency_id, prev_event_latency_id) AS cause_id
FROM chrome_janky_frames_no_cause;

-- Finds all causes of jank for all janky frames, and a cause of sub jank
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- if the cause of jank was GPU related.
CREATE PERFETTO TABLE chrome_janky_frames(
  -- The reason the Vsync was missed.
  cause_of_jank STRING,
  -- Further breakdown if the root cause was GPU related.
  sub_cause_of_jank STRING,
  -- Time elapsed since the previous frame was presented, will be more than |VSYNC| in this view.
  delay_since_last_frame DOUBLE,
  -- Event latency id of the presented frame.
  event_latency_id LONG,
  -- Vsync interval at the time of recording the trace.
  vsync_interval DOUBLE,
  -- Device brand and model.
  hardware_class STRING,
  -- The scroll corresponding to this frame.
  scroll_id LONG
) AS
SELECT
  _slice_name_from_id(cause_id) AS cause_of_jank,
  _slice_name_from_id(
    -- Getting sub-cause
    chrome_get_v3_jank_cause_id(
      -- Here the cause itself is the parent.
      cause_id,
      -- Get the previous cause id as a child to the previous |EventLatency|.
     (SELECT
      id
      FROM slice
      WHERE name = _slice_name_from_id(cause_id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        AND parent_id = prev_event_latency_id)
    )) AS sub_cause_of_jank,
  delay_since_last_frame,
  event_latency_id,
  vsync_interval,
  hardware_class,
  scroll_id
FROM chrome_janky_frames_no_subcause;

-- Counting all unique frame presentation timestamps.
CREATE PERFETTO TABLE chrome_unique_frame_presentation_ts(
  -- The unique frame presentation timestamp.
  presentation_timestamp LONG
) AS
SELECT DISTINCT
presentation_timestamp
FROM chrome_presented_gesture_scrolls;

-- Dividing missed frames over total frames to get janky frame percentage.
-- This represents the v3 scroll jank metrics.
-- Reflects Event.Jank.DelayedFramesPercentage UMA metric.
CREATE PERFETTO TABLE chrome_janky_frames_percentage(
  -- The percent of missed frames relative to total frames - aka the percent of janky frames.
  delayed_frame_percentage DOUBLE
) AS
SELECT
(SELECT
  COUNT()
 FROM chrome_janky_frames) * 1.0
/ (SELECT
    COUNT()
  FROM chrome_unique_frame_presentation_ts) * 100 AS delayed_frame_percentage;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Number of frames and janky frames per scroll.
CREATE PERFETTO TABLE chrome_frames_per_scroll(
  -- The ID of the scroll.
  scroll_id LONG,
  -- The number of frames in the scroll.
  num_frames LONG,
  -- The number of delayed/janky frames.
  num_janky_frames LONG,
  -- The percentage of janky frames relative to total frames.
  scroll_jank_percentage DOUBLE
) AS
WITH
  frames AS (
    SELECT scroll_id, COUNT(*) AS num_frames
    FROM
      chrome_frame_info_with_delay
    GROUP BY scroll_id
  ),
  janky_frames AS (
    SELECT scroll_id, COUNT(*) AS num_janky_frames
    FROM
      chrome_janky_frames
    GROUP BY scroll_id
  )
SELECT
  frames.scroll_id AS scroll_id,
  frames.num_frames AS num_frames,
  janky_frames.num_janky_frames AS num_janky_frames,
  100.0 * janky_frames.num_janky_frames / frames.num_frames
    AS scroll_jank_percentage
FROM frames
LEFT JOIN janky_frames
  ON frames.scroll_id = janky_frames.scroll_id;

-- Scroll jank causes per scroll.
CREATE PERFETTO VIEW chrome_causes_per_scroll(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The ID of the scroll.
  scroll_id LONG,
  -- The maximum time a frame was delayed after the presentation of the previous
  -- frame.
  max_delay_since_last_frame DOUBLE,
  -- The expected vsync interval.
  vsync_interval DOUBLE,
  -- A proto amalgamation of each scroll jank cause including cause name, sub
  -- cause and the duration of the delay since the previous frame was presented.
  scroll_jank_causes BYTES
) AS
SELECT
  scroll_id,
  MAX(1.0 * delay_since_last_frame / vsync_interval)
    AS max_delay_since_last_frame,
  -- MAX does not matter, since `vsync_interval` is the computed as the
  -- same value for a single trace.
  MAX(vsync_interval) AS vsync_interval,
  RepeatedField(
    ChromeScrollJankV3_Scroll_ScrollJankCause(
      'cause',
      cause_of_jank,
      'sub_cause',
      sub_cause_of_jank,
      'delay_since_last_frame',
      1.0 * delay_since_last_frame / vsync_interval))
    AS scroll_jank_causes
FROM
  chrome_janky_frames
GROUP BY scroll_id;

)_d3l1m1t3r_"
;

const char kChromeScrollJankScrollOffsets[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.

-- This file creates two public views:
--     - chrome_scroll_input_offsets and
--     - chrome_presented_scroll_offsets
--
-- These views store the pixel deltas and offsets for (respectively) all chrome
-- scroll inputs (coalesced and not coalesced), and for chrome presented frames
-- (not coalesced), along with the associated timestamp, and id.
--
-- Raw deltas are recorded as changes in pixel positions along the y-axis of a
-- screen, and are scaled to the viewport size. The corresponding trace event
-- for this is TranslateAndScaleWebInputEvent. These are the deltas for all
-- chrome scroll inputs.
--
-- For presented frames, the delta is calculated from the visual offset,
-- recorded once the input has been processed, in the
-- InputHandlerProxy::HandleGestureScrollUpdate_Result event. These values are
-- also scaled to the screen size.
--
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Offsets are calculated by summing all of the deltas, ordered by timestamp.
-- For a given input/frame, the offset is the sum of its corresponding delta and
-- all previous deltas.
--
--
-- All values required for calculating deltas and offsets are recorded at
-- various stages of input processing, and are unified by a single
-- scroll_update_id value, recorded as scroll_deltas.trace_id in each event.

INCLUDE PERFETTO MODULE chrome.chrome_scrolls;
INCLUDE PERFETTO MODULE chrome.scroll_jank.scroll_jank_v3;

-- All (coalesced and non-coalesced) vertical scrolling deltas and their
-- associated scroll ids. Delta values are recorded after being scaled to the
-- device's screen size in the TranslateAndScaleWebInputEvent trace event. In
-- this trace event, the deltas recorded represent the true (read "original")
-- values that the Browser receives from Android, and the only processing is
-- scaling and translation.
CREATE PERFETTO TABLE _translate_and_scale_scroll_deltas AS
SELECT
  EXTRACT_ARG(arg_set_id, 'scroll_deltas.trace_id') AS scroll_update_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  EXTRACT_ARG(arg_set_id, 'scroll_deltas.original_delta_y') AS delta_y
FROM slice
WHERE slice.name = 'TranslateAndScaleWebInputEvent';

-- Associate the gesture scroll update OS timestamp with the delta.
CREATE PERFETTO TABLE _scroll_deltas_with_timestamp AS
SELECT
  slice.id AS event_latency_slice_id,
  slice.ts AS input_ts,
  data.scroll_update_id,
  data.delta_y
FROM _translate_and_scale_scroll_deltas data
  JOIN slice ON slice.name = 'EventLatency'
    AND data.scroll_update_id = EXTRACT_ARG(arg_set_id,
        'event_latency.event_latency_id');

-- Associate the scroll update/delta with the correct scroll.
CREATE PERFETTO TABLE _scroll_deltas_with_scroll_id AS
SELECT
  scrolls.id AS scroll_id,
  deltas.event_latency_slice_id,
  deltas.input_ts,
  deltas.scroll_update_id,
  deltas.delta_y
FROM _scroll_deltas_with_timestamp deltas
  LEFT JOIN chrome_scrolls scrolls
    ON deltas.input_ts >= scrolls.ts
      AND deltas.input_ts <= scrolls.ts + scrolls.dur;

-- Associate the presentation timestamp/deltas with the user deltas.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _scroll_deltas_with_delays AS
SELECT
  deltas.scroll_id,
  delay.total_delta,
  deltas.scroll_update_id,
  deltas.event_latency_slice_id,
  delay.presentation_timestamp AS presentation_timestamp,
  deltas.input_ts,
  deltas.delta_y
FROM _scroll_deltas_with_scroll_id AS deltas
  LEFT JOIN chrome_frame_info_with_delay AS delay USING(scroll_update_id);

-- The raw coordinates and pixel offsets for all input events which were part of
-- a scroll.
CREATE PERFETTO TABLE chrome_scroll_input_offsets(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id LONG,
  -- An ID for this particular EventLatency regardless of it being presented or
  -- not.
  event_latency_slice_id LONG,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
  -- event_latency_id) that it was presented with.
  scroll_update_id LONG,
  -- Timestamp the of the scroll input event.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- The delta in raw coordinates between this scroll update event and the
  -- previous.
  delta_y DOUBLE,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y DOUBLE
) AS
SELECT
  scroll_id,
  event_latency_slice_id,
  scroll_update_id,
  input_ts AS ts,
  delta_y,
  SUM(IFNULL(delta_y, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, input_ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
FROM _scroll_deltas_with_delays;

-- The scrolling offsets for the actual (applied) scroll events. These are not
-- necessarily inclusive of all user scroll events, rather those scroll events
-- that are actually processed.
CREATE PERFETTO TABLE chrome_presented_scroll_offsets(
  -- An ID that ties all EventLatencies in a particular scroll. (implementation
  -- note: This is the EventLatency TraceId of the GestureScrollbegin).
  scroll_id LONG,
  -- An ID for this particular EventLatency regardless of it being presented or
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- not.
  event_latency_slice_id LONG,
  -- An ID that ties this |event_latency_id| with the Trace Id (another
  -- event_latency_id) that it was presented with.
  scroll_update_id LONG,
  -- Presentation timestamp.
  ts TIMESTAMP,
  -- The delta in raw coordinates between this scroll update event and the
  -- previous.
  delta_y DOUBLE,
  -- The pixel offset of this scroll update event compared to the initial one.
  relative_offset_y DOUBLE
) AS
SELECT
  scroll_id,
  event_latency_slice_id,
  scroll_update_id,
  presentation_timestamp AS ts,
  total_delta AS delta_y,
  SUM(IFNULL(total_delta, 0)) OVER ( PARTITION BY scroll_id
    ORDER BY scroll_update_id, presentation_timestamp
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS relative_offset_y
FROM _scroll_deltas_with_delays
WHERE presentation_timestamp IS NOT NULL
;

)_d3l1m1t3r_"
;

const char kChromeScrollJankUtils[] = R"_d3l1m1t3r_(-- Copyright 2023 The Chromium Authors
-- Use of this source code is governed by a BSD-style license that can be
-- found in the LICENSE file.
--
-- These are helper functions/tables used in computing jank metrics

INCLUDE PERFETTO MODULE chrome.event_latency;

-- This function takes timestamps of two consecutive frames and determines if
-- its janky by a delay of more than 0.5 of a frame  in order to make sure that
-- the comparison does not filter out ratios that are precisely 0.5, which can
-- fall a little above or below exact value due to inherent inaccuracy of operations with
-- floating-point numbers. Value 1e-9 have been chosen as follows: the ratio has
-- nanoseconds in numerator and VSync interval in denominator. Assuming refresh
-- rate more than 1 FPS (and therefore VSync interval less than a second), this
-- ratio should increase with increments more than minimal value in numerator
-- (1ns) divided by maximum value in denominator, giving 1e-9.

-- Function : function takes scroll ids of frames to verify it's from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the same scroll, and makes sure the frame ts occurred within the scroll
-- timestamp of the neighbour and computes whether the frame was janky or not.
CREATE PERFETTO FUNCTION _is_janky_frame(cur_gesture_id LONG,
                                      neighbour_gesture_id LONG,
                                      neighbour_ts TIMESTAMP,
                                      cur_gesture_begin_ts TIMESTAMP,
                                      cur_gesture_end_ts TIMESTAMP,
                                      cur_frame_exact DOUBLE,
                                      neighbour_frame_exact DOUBLE)
-- Returns true if the frame was janky, false otherwise
RETURNS BOOL AS
SELECT
    CASE WHEN
      $cur_gesture_id != $neighbour_gesture_id OR
      $neighbour_ts IS NULL OR
      $neighbour_ts < $cur_gesture_begin_ts OR
      $neighbour_ts > $cur_gesture_end_ts THEN
        FALSE ELSE
        $cur_frame_exact > $neighbour_frame_exact + 0.5 + 1e-9
    END;

-- Function : function takes the cur_frame_exact, prev_frame_exact and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- next_frame_exact and returns the value of the jank budget of the current
-- frame.
--
-- jank_budget is the minimum amount of frames/time we need to reduce the frame
-- duration by for it to be no longer considered janky.
--
-- Returns the jank budget in percentage (i.e. 0.75) of vsync interval
-- percentage.
CREATE PERFETTO FUNCTION _jank_budget(
  cur_frame_exact DOUBLE,
  prev_frame_exact DOUBLE,
  next_frame_exact DOUBLE
)
RETURNS DOUBLE AS
-- We determine the difference between the frame count of the current frame
-- and its consecutive frames by subtracting with the frame_exact values. We
-- null check for cases when the neighbor frame count can be null for the
-- first and last frames.
--
-- Since a frame is considered janky, if the difference in the frame count
-- with its adjacent frame is greater than 0.5 (half a vsync) which means we
-- need to reduce the frame count by a value less than 0.5 of maximum
-- difference in frame count for it to be no longer janky. We subtract 1e-9 as
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- we want to output minimum amount required.
SELECT
  COALESCE(
    -- Could be null if next or previous is null.
    MAX(
      ($cur_frame_exact - $prev_frame_exact),
      ($cur_frame_exact - $next_frame_exact)
    ),
    -- If one of them is null output the first non-null.
    ($cur_frame_exact - $prev_frame_exact),
    ($cur_frame_exact - $next_frame_exact)
    -- Otherwise return null
  ) - 0.5 - 1e-9;

-- Extract mojo information for the long-task-tracking scenario for specific
-- names. For example, LongTaskTracker slices may have associated IPC
-- metadata, or InterestingTask slices for input may have associated IPC to
-- determine whether the task is fling/etc.
CREATE PERFETTO FUNCTION chrome_select_long_task_slices(
  -- The name of slice.
  name STRING)
RETURNS TABLE(
  -- Name of the interface of the IPC call.
  interface_name STRING,
  -- Hash of the IPC call.
  ipc_hash LONG,
  -- Message type (e.g. reply).
  message_type STRING,
  -- The slice id.
  id LONG
) AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  EXTRACT_ARG(s.arg_set_id, "chrome_mojo_event_info.mojo_interface_tag") AS interface_name,
  EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.ipc_hash") AS ipc_hash,
  CASE
    WHEN EXTRACT_ARG(arg_set_id, "chrome_mojo_event_info.is_reply") THEN "reply"
    ELSE "message"
  END AS message_type,
  s.id
FROM slice s
WHERE
  category GLOB "*scheduler.long_tasks*"
  AND name = $name;

)_d3l1m1t3r_"
;

const char kCountersGlobalTracks[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

CREATE PERFETTO FUNCTION _counter_track_is_only_name_dimension(track_id LONG)
RETURNS BOOL AS
SELECT NOT EXISTS (
  SELECT 1
  FROM counter_track
  JOIN args ON counter_track.dimension_arg_set_id = args.arg_set_id
  WHERE counter_track.id = $track_id AND args.key != 'name'
  LIMIT 1
);

)_d3l1m1t3r_"
;

const char kCountersIntervals[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- For a given counter timeline (e.g. a single counter track), returns
-- intervals of time where the counter has the same value.
--
-- Intervals are computed in a "forward-looking" way. That is, if a counter
-- changes value at some timestamp, it's assumed it *just* reached that
-- value and it should continue to have that value until the next
-- value change. The final value is assumed to hold until the very end of
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the trace.
--
-- For example, suppose we have the following data:
-- ```
-- ts=0, value=10, track_id=1
-- ts=0, value=10, track_id=2
-- ts=10, value=10, track_id=1
-- ts=10, value=20, track_id=2
-- ts=20, value=30, track_id=1
-- [end of trace at ts = 40]
-- ```
--
-- Then this macro will generate the following intervals:
-- ```
-- ts=0, dur=20, value=10, track_id=1
-- ts=20, dur=10, value=30, track_id=1
-- ts=0, dur=10, value=10, track_id=2
-- ts=10, dur=30, value=20, track_id=2
-- ```
CREATE PERFETTO MACRO counter_leading_intervals(
  -- A table/view/subquery corresponding to a "counter-like" table.
  -- This table must have the columns "id" and "ts" and "track_id" and "value" corresponding
  -- to an id, timestamp, counter track_id and associated counter value.
  counter_table TableOrSubquery)
-- Table with the schema (id LONG, ts TIMESTAMP, dur DURATION, track_id JOINID(track.id),
-- value DOUBLE, next_value DOUBLE, delta_value DOUBLE).
RETURNS TableOrSubquery AS
(
  SELECT
    c0 AS id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    c1 AS ts,
    c2 AS dur,
    c3 AS track_id,
    c4 AS value,
    c5 AS next_value,
    c6 AS delta_value
  FROM __intrinsic_table_ptr(
    __intrinsic_counter_intervals(
      "leading", TRACE_END(),
      (SELECT __intrinsic_counter_per_track_agg(
        input.id,
        input.ts,
        input.track_id,
        input.value
      )
      FROM (SELECT * FROM $counter_table ORDER BY ts) input)
    )
  )

  WHERE __intrinsic_table_ptr_bind(c0, 'id')
    AND __intrinsic_table_ptr_bind(c1, 'ts')
    AND __intrinsic_table_ptr_bind(c2, 'dur')
    AND __intrinsic_table_ptr_bind(c3, 'track_id')
    AND __intrinsic_table_ptr_bind(c4, 'value')
    AND __intrinsic_table_ptr_bind(c5, 'next_value')
    AND __intrinsic_table_ptr_bind(c6, 'delta_value')
);

)_d3l1m1t3r_"
;

const char kExportToFirefoxProfile[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- Returns an instance of `RawMarkerTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
CREATE PERFETTO FUNCTION _export_firefox_thread_markers()
RETURNS STRING
AS
SELECT json_object(
      'data', json_array(),
      'name', json_array(),
      'startTime', json_array(),
      'endTime', json_array(),
      'phase', json_array(),
      'category', json_array(),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      -- threadId?: Tid[]
      'length', 0);

-- Returns an empty instance of `NativeSymbolTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
CREATE PERFETTO FUNCTION _export_firefox_native_symbol_table()
RETURNS STRING
AS
SELECT
  json_object(
    'libIndex', json_array(),
    'address', json_array(),
    'name', json_array(),
    'functionSize', json_array(),
    'length', 0);


-- Returns an empty instance of `ResourceTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
CREATE PERFETTO FUNCTION _export_firefox_resource_table()
RETURNS STRING
AS
SELECT
  json_object(
    'length', 0,
    'lib', json_array(),
    'name', json_array(),
    'host', json_array(),
    'type', json_array());

-- Materialize this intermediate table and sort by `callsite_id` to speedup the
-- generation of the stack_table further down.
CREATE PERFETTO TABLE _export_to_firefox_table
AS
WITH
  symbol AS (
    SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      symbol_set_id,
      RANK()
        OVER (
          PARTITION BY symbol_set_id
          ORDER BY id DESC
          RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        )
        - 1 AS inline_depth,
      COUNT() OVER (PARTITION BY symbol_set_id) - 1 AS max_inline_depth,
      name
    FROM stack_profile_symbol
  ),
  callsite_base AS (
    SELECT
      id,
      parent_id,
      name,
      symbol_set_id,
      IIF(inline_count = 0, 0, inline_count - 1) AS max_inline_depth
    FROM
      (
        SELECT
          spc.id,
          spc.parent_id,
          COALESCE(s.name, spf.name, '') AS name,
          sfp.symbol_set_id,
          (
            SELECT COUNT(*)
            FROM stack_profile_symbol s
            WHERE s.symbol_set_id = sfp.symbol_set_id
          ) AS inline_count
        FROM stack_profile_callsite sfc, stack_profile_frame AS spf
        ON (c.frame_id = spf.id)
      )
  ),
  callsite_recursive AS (
    SELECT
      s.utid,
      spc.id,
      spc.parent_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      spc.frame_id
    FROM
      (SELECT DISTINCT callsite_id, utid FROM perf_sample) s,
      stack_profile_callsite spc
    ON (spc.id = s.callsite_id)
    UNION ALL
    SELECT
      child.utid,
      parent.id,
      parent.parent_id,
      parent.frame_id
    FROM callsite_recursive AS child, stack_profile_callsite AS parent
    ON (child.parent_id = parent.id)
  ),
  unique_callsite AS (
    SELECT DISTINCT * FROM callsite_recursive
  ),
  expanded_callsite AS (
    SELECT
      c.utid,
      c.id,
      c.parent_id,
      c.frame_id,
      COALESCE(s.name, spf.name, '') AS name,
      COALESCE(s.inline_depth, 0) AS inline_depth,
      COALESCE(s.max_inline_depth, 0) AS max_inline_depth
    FROM unique_callsite c, stack_profile_frame AS spf
    ON (c.frame_id = spf.id)
    LEFT JOIN symbol s
      USING (symbol_set_id)
  )
SELECT
  utid,
  id AS callsite_id,
  parent_id AS parent_callsite_id,
  name,
  inline_depth,
  inline_depth = max_inline_depth AS is_most_inlined,
  DENSE_RANK()
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    OVER (PARTITION BY utid ORDER BY id, inline_depth) - 1 AS stack_table_index,
  DENSE_RANK()
    OVER (PARTITION BY utid ORDER BY frame_id, inline_depth) - 1
    AS frame_table_index,
  DENSE_RANK() OVER (PARTITION BY utid ORDER BY name) - 1 AS func_table_index,
  DENSE_RANK() OVER (PARTITION BY utid ORDER BY name) - 1 AS string_table_index
FROM expanded_callsite
ORDER BY utid, id;

-- Returns an instance of `SamplesTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_samples_table(utid JOINID(thread.id))
RETURNS STRING
AS
WITH
  samples_table AS (
    SELECT
      ROW_NUMBER() OVER (ORDER BY s.id) - 1 AS idx,
      s.ts AS time,
      t.stack_table_index AS stack
    FROM
      perf_sample AS s,
      _export_to_firefox_table AS t
    USING (utid, callsite_id)
    WHERE utid = $utid AND t.is_most_inlined
  )
SELECT
  json_object(
    -- responsiveness?: Array<?Milliseconds>
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- eventDelay?: Array<?Milliseconds>
    'stack', json_group_array(stack ORDER BY idx),
    'time',  json_group_array(time ORDER BY idx),
    'weight', NULL,
    'weightType', 'samples',
    -- threadCPUDelta?: Array<number | null>
    -- threadId?: Tid[]
    'length', COUNT(*))
FROM samples_table;

-- Returns an instance of `StackTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_stack_table(utid JOINID(thread.id))
RETURNS STRING
AS
WITH
  parent AS (
    SELECT *
    FROM _export_to_firefox_table
    WHERE utid = $utid
  ),
  stack_table AS (
    SELECT
      stack_table_index AS idx,
      frame_table_index AS frame,
      0 AS category,
      0 AS subcategory,
      -- It is key that this lookup is fast. That is why we have materialized
      -- the `_export_to_firefox_table` table and sorted it by `utid` and
      -- `callsite_id`.
      IIF(
        child.inline_depth = 0,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        (
          SELECT stack_table_index
          FROM parent
          WHERE
            child.parent_callsite_id = parent.callsite_id
            AND parent.is_most_inlined
        ),
        (
          SELECT stack_table_index
          FROM parent
          WHERE
            child.callsite_id = parent.callsite_id
            AND child.inline_depth - 1 = parent.inline_depth
        )) AS prefix
    FROM _export_to_firefox_table AS child
    WHERE child.utid = $utid
  )
SELECT
  json_object(
    'frame', json_group_array(frame ORDER BY idx),
    'category', json_group_array(category ORDER BY idx),
    'subcategory', json_group_array(subcategory ORDER BY idx),
    'prefix', json_group_array(prefix ORDER BY idx),
    'length', COUNT(*))
FROM stack_table;


-- Returns an instance of `FrameTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_frame_table(utid JOINID(thread.id))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS STRING
AS
WITH
  frame_table AS (
    SELECT DISTINCT
      frame_table_index AS idx,
      -1 AS address,
      inline_depth,
      0 AS category,
      0 AS subcategory,
      func_table_index AS func,
      NULL AS native_symbol,
      NULL AS inner_window_id,
      NULL AS implementation,
      NULL AS line,
      NULL AS column
    FROM _export_to_firefox_table
    WHERE utid = $utid
  )
SELECT
  json_object(
    'address', json_group_array(address ORDER BY idx),
    'inlineDepth', json_group_array(inline_depth ORDER BY idx),
    'category', json_group_array(category ORDER BY idx),
    'subcategory', json_group_array(subcategory ORDER BY idx),
    'func', json_group_array(func ORDER BY idx),
    'nativeSymbol', json_group_array(native_symbol ORDER BY idx),
    'innerWindowID', json_group_array(inner_window_id ORDER BY idx),
    'implementation', json_group_array(implementation ORDER BY idx),
    'line', json_group_array(line ORDER BY idx),
    'column', json_group_array(column ORDER BY idx),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'length', COUNT(*))
FROM frame_table;

-- Returns an array of strings for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_string_array(utid JOINID(thread.id))
RETURNS STRING
AS
WITH
  string_table AS (
    SELECT DISTINCT
      string_table_index AS idx,
      name AS str
    FROM
      _export_to_firefox_table
    WHERE utid = $utid
  )
SELECT json_group_array(str ORDER BY idx)
FROM string_table;

-- Returns an instance of `FuncTable` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_func_table(utid JOINID(thread.id))
RETURNS STRING
AS
WITH
  func_table AS (
    SELECT DISTINCT
      func_table_index AS idx,
      string_table_index AS name,
      FALSE AS is_js,
      FALSE AS relevant_for_js,
      -1 AS resource,
      NULL AS file_name,
      NULL AS line_number,
      NULL AS column_number
    FROM _export_to_firefox_table
    WHERE utid = $utid
  )
SELECT
  json_object(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'name', json_group_array(name ORDER BY idx),
    'isJS', json_group_array(is_js ORDER BY idx),
    'relevantForJS', json_group_array(relevant_for_js ORDER BY idx),
    'resource', json_group_array(resource ORDER BY idx),
    'fileName', json_group_array(file_name ORDER BY idx),
    'lineNumber', json_group_array(line_number ORDER BY idx),
    'columnNumber', json_group_array(column_number ORDER BY idx),
    'length', COUNT(*))
FROM func_table;


-- Returns an instance of `Thread` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- for the given `utid`.
CREATE PERFETTO FUNCTION _export_firefox_thread(utid JOINID(thread.id))
RETURNS STRING
AS
SELECT
  json_object(
    'processType', 'default',
    -- processStartupTime: Milliseconds
    -- processShutdownTime: Milliseconds | null
    -- registerTime: Milliseconds
    -- unregisterTime: Milliseconds | null
    -- pausedRanges: PausedRange[]
    -- showMarkersInTimeline?: boolean
    'name', COALESCE(thread.name, ''),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'isMainThread', FALSE,
    -- 'eTLD+1'?: string
    -- processName?: string
    -- isJsTracer?: boolean
    'pid', COALESCE(process.pid, 0),
    'tid', COALESCE(thread.tid, 0),
    'samples', json(_export_firefox_samples_table($utid)),
    -- jsAllocations?: JsAllocationsTable
    -- nativeAllocations?: NativeAllocationsTable
    'markers', json(_export_firefox_thread_markers()),
    'stackTable', json(_export_firefox_stack_table($utid)),
    'frameTable', json(_export_firefox_frame_table($utid)),
    'stringArray', json(_export_firefox_string_array($utid)),
    'funcTable', json(_export_firefox_func_table($utid)),
    'resourceTable', json(_export_firefox_resource_table()),
    'nativeSymbols', json(_export_firefox_native_symbol_table())
    -- jsTracer?: JsTracerTable
    -- isPrivateBrowsing?: boolean
    -- userContextId?: number
  )
FROM thread, process
USING (upid)
WHERE utid = $utid;

-- Returns an array of `Thread` instances as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for each thread present in the trace.
CREATE PERFETTO FUNCTION _export_firefox_threads()
RETURNS STRING
AS
SELECT json_group_array(json(_export_firefox_thread(utid))) FROM thread;

-- Returns an instance of `ProfileMeta` as defined in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
CREATE PERFETTO FUNCTION _export_firefox_meta()
RETURNS STRING
AS
SELECT
  json_object(
    'interval', 1,
    'startTime', 0,
    -- endTime?: Milliseconds
    -- profilingStartTime?: Milliseconds
    -- profilingEndTime?: Milliseconds
    'processType', 0,  -- default
    -- extensions?: ExtensionTable
    'categories', json_array(json_object(
        'name', 'Other',
        'color', 'grey',
        'subcategories', json_array('Other'))),
    'product', 'Perfetto',
    'stackwalk', 1,
    -- debug?: boolean
    'version', 29,  -- Taken from a generated profile
    'preprocessedProfileVersion', 48,  -- Taken from a generated profile
    -- abi?: string
    -- misc?: string
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- oscpu?: string
    -- mainMemory?: Bytes
    -- platform?: 'Android' | 'Windows' | 'Macintosh' | 'X11' | string
    -- toolkit?: 'gtk' | 'gtk3' | 'windows' | 'cocoa' | 'android' | string
    -- appBuildID?: string
    -- arguments?: string
    -- sourceURL?: string
    -- physicalCPUs?: number
    -- logicalCPUs?: number
    -- CPUName?: string
    -- symbolicated?: boolean
    -- symbolicationNotSupported?: boolean
    -- updateChannel?: 'default' | 'nightly' | 'nightly-try' | 'aurora' | 'beta' | 'release' | 'esr' | string
    -- visualMetrics?: VisualMetrics
    -- configuration?: ProfilerConfiguration
    'markerSchema', json_array(),
    'sampleUnits', json_object('time', 'ms', 'eventDelay', 'ms', 'threadCPUDelta', 's')
    -- device?: string
    -- importedFrom?: string
    -- usesOnlyOneStackType?: boolean
    -- doesNotUseFrameImplementation?: boolean
    -- sourceCodeIsNotOnSearchfox?: boolean
    -- extra?: ExtraProfileInfoSection[]
    -- initialVisibleThreads?: ThreadIndex[]
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- initialSelectedThreads?: ThreadIndex[]
    -- keepProfileThreadOrder?: boolean
    -- gramsOfCO2ePerKWh?: number
  );

-- Dumps all trace data as a Firefox profile json string
-- See `Profile` in
-- https://github.com/firefox-devtools/profiler/blob/main/src/types/profile.js
-- Also
-- https://firefox-source-docs.mozilla.org/tools/profiler/code-overview.html
--
-- You would probably want to download the generated json and then open at
-- https://https://profiler.firefox.com
-- You can easily do this from the UI via the following SQL
-- `SELECT CAST(export_to_firefox_profile() AS BLOB) AS profile;`
-- The result will have a link for you to download this json as a file.
CREATE PERFETTO FUNCTION export_to_firefox_profile()
-- Json profile
RETURNS STRING
AS
SELECT
  json_object(
    'meta', json(_export_firefox_meta()),
    'libs', json_array(),
    'pages', NULL,
    'counters', NULL,
    'profilerOverhead', NULL,
    'threads', json(_export_firefox_threads()),
    'profilingLog', NULL,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    'profileGatheringLog', NULL);

)_d3l1m1t3r_"
;

const char kGraphsCriticalPath[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE graphs.search;

-- Computes critical paths, the dependency graph of a task.
-- The critical path is a set of edges reachable from a root node with the sum of the edge
-- weights just exceeding the root node capacity. This ensures that the tasks in the critical path
-- completely 'covers' the root capacity.
-- Typically, every node represents a point in time on some task where it transitioned from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- idle to active state.
--
-- Example usage on traces with Linux sched information:
-- ```
-- -- Compute the userspace critical path from every task sleep.
-- SELECT * FROM
--   critical_path_intervals!(
--   _wakeup_userspace_edges,
--   (SELECT id AS root_node_id, prev_id - id FROM _wakeup_graph WHERE prev_id IS NOT NULL));
-- ```
CREATE PERFETTO MACRO _critical_path(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id", "dest_node_id" and "edge_weight" corresponding to the two nodes on
  -- either end of the edges in the graph and the edge weight.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- An edge weight is the absolute difference between the node ids forming the edge.
  graph_table TableOrSubQuery,
  -- A table/view/subquery corresponding to start nodes to |graph_table| which will be the
  -- roots of the reachability trees. This table must have the columns
  -- "root_node_id" and "capacity" corresponding to the starting node id and the capacity
  -- of the root node to contain edge weights.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  root_table TableOrSubQuery)
  -- The returned table has the schema (root_id LONG, id LONG, parent_id LONG).
  -- |root_id| is the id of the root where the critical path computation started.
  -- |id| is the id of a node in the critical path and |parent_id| is the predecessor of |id|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS TableOrSubQuery
AS (
  WITH
    _edges AS (
      SELECT source_node_id, dest_node_id, edge_weight FROM $graph_table
    ),
    _roots AS (
      SELECT
        root_node_id,
        capacity AS root_target_weight
      FROM $root_table
    ),
    _search_bounds AS (
      SELECT MIN(root_node_id - root_target_weight) AS min_wakeup,
             MAX(root_node_id + root_target_weight) AS max_wakeup
      FROM _roots
    ),
    _graph AS (
      SELECT
        source_node_id,
        COALESCE(dest_node_id, source_node_id) AS dest_node_id,
        edge_weight
      FROM _edges
      JOIN _search_bounds
      WHERE source_node_id BETWEEN min_wakeup AND max_wakeup AND source_node_id IS NOT NULL
    )
  SELECT DISTINCT
    root_node_id AS root_id,
    parent_node_id AS parent_id,
    node_id AS id
  FROM graph_reachable_weight_bounded_dfs !(_graph, _roots, 1) cr
);

-- Flattens overlapping tasks within a critical path and flattens overlapping critical paths.
CREATE PERFETTO MACRO _critical_path_to_intervals(critical_path_table TableOrSubquery,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(                                                  node_table TableOrSubquery)
RETURNS TableOrSubquery
AS (
  WITH flat_tasks AS (
    SELECT
      node.ts,
      cr.root_id,
      cr.id,
      LEAD(node.ts) OVER (PARTITION BY cr.root_id ORDER BY cr.id) - node.ts AS dur
    FROM $critical_path_table cr
    JOIN $node_table node USING(id)
  ), span_starts AS (
    SELECT
      MAX(cr.ts, idle.ts - idle_dur) AS ts,
      idle.ts AS idle_end_ts,
      cr.ts + cr.dur AS cr_end_ts,
      cr.id,
      cr.root_id
    FROM flat_tasks cr
    JOIN $node_table idle ON cr.root_id = idle.id
  )
  SELECT
    ts,
    MIN(cr_end_ts, idle_end_ts) - ts AS dur,
    id,
    root_id
  FROM span_starts
  WHERE MIN(idle_end_ts, cr_end_ts) - ts > 0
);

-- Computes critical paths, the dependency graph of a task and returns a flattened view suitable
-- for displaying in a UI track without any overlapping intervals.
-- See the _critical_path MACRO above.
--
-- Example usage on traces with Linux sched information:
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- ```
-- -- Compute the userspace critical path from every task sleep.
-- SELECT * FROM
--   critical_path_intervals!(
--   _wakeup_userspace_edges,
--   (SELECT id AS root_node_id, prev_id - id FROM _wakeup_graph WHERE prev_id IS NOT NULL),
--  _wakeup_intervals);
-- ```
CREATE PERFETTO MACRO _critical_path_intervals(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id", "dest_node_id" and "edge_weight" corresponding to the two nodes on
  -- either end of the edges in the graph and the edge weight.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  -- An edge weight is the absolute difference between the node ids forming the edge.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  graph_table TableOrSubQuery,
  -- A table/view/subquery corresponding to start nodes to |graph_table| which will be the
  -- roots of the reachability trees. This table must have the columns
  -- "root_node_id" and "capacity" corresponding to the starting node id and the capacity
  -- of the root node to contain edge weights.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  root_table TableOrSubQuery,
  -- A table/view/subquery corresponding to the idle to active transition points on a task.
  -- This table must have the columns, "id", "ts", "dur" and "idle_dur". ts and dur is the
  -- timestamp when the task became active and how long it was active for respectively. idle_dur
  -- is the duration it was idle for before it became active at "ts".
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  -- There should be one row for every node id encountered in the |graph_table|.
  interval_table TableOrSubQuery)
-- The returned table has the schema (id LONG, ts TIMESTAMP, dur DURATION, idle_dur LONG).
-- |root_node_id| is the id of the starting node under which this edge was encountered.
-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubQuery
AS (
  WITH _critical_path_nodes AS (
    SELECT root_id, id FROM _critical_path!($graph_table, $root_table)
  ) SELECT root_id, id, ts, dur
    FROM _critical_path_to_intervals !(_critical_path_nodes, $interval_table)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    UNION ALL
    SELECT node.id AS root_id, node.id, node.ts, node.dur
    FROM $interval_table node
    JOIN $root_table ON root_node_id = id
);

)_d3l1m1t3r_"
;

const char kGraphsDominatorTree[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Given a table containing a directed flow-graph and an entry node, computes
-- the "dominator tree" for the graph. See [1] for an explanation of what a
-- dominator tree is.
--
-- [1] https://en.wikipedia.org/wiki/Dominator_(graph_theory)
--
-- Example usage on traces containing heap graphs:
-- ```
-- CREATE PERFETTO VIEW dominator_compatible_heap_graph AS
-- -- Extract the edges from the heap graph which correspond to references
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- -- between objects.
-- SELECT
--   owner_id AS source_node_id,
--   owned_id as dest_node_id
-- FROM heap_graph_reference
-- JOIN heap_graph_object owner on heap_graph_reference.owner_id = owner.id
-- WHERE owned_id IS NOT NULL AND owner.reachable
-- UNION ALL
-- -- Since a Java heap graph is a "forest" structure, we need to add a dummy
-- -- "root" node which connects all the roots of the forest into a single
-- -- connected component.
-- SELECT
--   (SELECT max(id) + 1 FROM heap_graph_object) as source_node_id,
--   id
-- FROM heap_graph_object
-- WHERE root_type IS NOT NULL;
--
-- SELECT *
-- FROM graph_dominator_tree!(
--   dominator_compatible_heap_graph,
--   (SELECT max(id) + 1 FROM heap_graph_object)
-- );
-- ```
CREATE PERFETTO MACRO graph_dominator_tree(
  -- A table/view/subquery corresponding to a directed flow-graph on which the
  -- dominator tree should be computed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  --
  -- Note: this means that the graph *must* be a single fully connected
  -- component with |root_node_id| (see below) being the "entry node" for this
  -- component. Specifically, all nodes *must* be reachable by following paths
  -- from the root node. Failing to adhere to this property will result in
  -- undefined behaviour.
  --
  -- If working with a "forest"-like structure, a dummy node should be added which
  -- links all the roots of the forest together into a single component; an example
  -- of this can be found in the heap graph example query above.
  graph_table TableOrSubquery,
  -- The entry node to |graph_table| which will be the root of the dominator
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- tree.
  root_node_id Expr
)
-- The returned table has the schema (node_id LONG, dominator_node_id LONG).
-- |node_id| is the id of the node from the input graph and |dominator_node_id|
-- is the id of the node in the input flow-graph which is the "dominator" of
-- |node_id|.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS dominator_node_id
  FROM __intrinsic_table_ptr((
    -- Aggregate function to perform a DFS on the nodes on the input graph.
    SELECT __intrinsic_dominator_tree(g.source_node_id, g.dest_node_id, $root_node_id)
    FROM $graph_table g
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the dominator tree table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'dominator_node_id')
);

)_d3l1m1t3r_"
;

const char kGraphsHierarchy[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.search;

-- Given a table containing the edges in a tree and a table of start_nodes,
-- returns the ids of all the nodes reachable by walking up the tree from each
-- of the start nodes.
CREATE PERFETTO MACRO _tree_reachable_ancestors_or_self(
  tree TableOrSubquery,
  start_nodes TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  SELECT node_id AS id
  FROM graph_reachable_dfs!(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    (SELECT id AS source_node_id, parent_id AS dest_node_id FROM $tree),
    (SELECT id AS node_id FROM $start_nodes)
  )
);

)_d3l1m1t3r_"
;

const char kGraphsPartition[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Partitions a tree into a forest of trees based on a given grouping key
-- in a structure-preserving way.
--
-- Specifically, for each tree in the output forest, all the nodes in that tree
-- have the same ancestors and descendants as in the original tree *iff* that
-- ancestor/descendent belonged to the same group.
--
-- Example:
-- Input
--
--   id | parent_id | group_key
--   ---|-----------|----------
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--   1  | NULL      | 1
--   2  | 1         | 1
--   3  | NULL      | 2
--   4  | NULL      | 2
--   5  | 2         | 1
--   6  | NULL      | 3
--   7  | 4         | 2
--   8  | 4         | 1
--
-- Or as a graph:
-- ```
--         1 (1)
--        /
--       2 (1)
--      /  \
--     3 (2) 4 (2)
--           /   \
--         5 (1) 8 (1)
--        /  \
--     6 (3) 7 (2)
-- ```
-- Possible output (order of rows is implementation-defined)
--
--   id | parent_id | group_key
--   ---|-----------|-------
--   1  | NULL      | 1
--   2  | 1         | 1
--   3  | NULL      | 2
--   4  | NULL      | 2
--   5  | 2         | 1
--   6  | NULL      | 3
--   7  | 4         | 2
--   8  | 2         | 1
--
-- Or as a forest:
-- ```
--     1 (1)       3 (2)      4 (2)        6 (3)
--      |                      |
--     2 (1)                  7 (2)
--     /   \
--   5 (1) 8 (1)
-- ```
CREATE PERFETTO MACRO tree_structural_partition_by_group(
  -- A table/view/subquery corresponding to a tree which should be partitioned.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- This table must have the columns "id", "parent_id" and "group_key".
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  tree_table TableOrSubquery
)
-- The returned table has the schema
-- (id LONG, parent_id LONG, group_key LONG).
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS id, c1 AS parent_id, c2 AS group_key
  FROM __intrinsic_table_ptr((
    -- Aggregate function to perform the partitioning algorithm.
    SELECT __intrinsic_structural_tree_partition(g.id, g.parent_id, g.group_key)
    FROM $tree_table g
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the partitioning table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
    AND __intrinsic_table_ptr_bind(c2, 'group_key')
);

)_d3l1m1t3r_"
;

const char kGraphsScan[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO MACRO _graph_scan_df_agg(x Expr, y Expr)
RETURNS Expr AS __intrinsic_stringify!($x), init_table.$y;

CREATE PERFETTO MACRO _graph_scan_bind(x Expr, y Expr)
RETURNS Expr AS __intrinsic_table_ptr_bind(result.$x, __intrinsic_stringify!($y));

CREATE PERFETTO MACRO _graph_scan_select(x Expr, y Expr)
RETURNS Expr AS result.$x as $y;

-- Performs a "scan" over the graph starting at `init_table` and using `graph_table`
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for edges to follow.
--
-- See https://en.wikipedia.org/wiki/Prefix_sum#Scan_higher_order_function for
-- details of what a scan means.
CREATE PERFETTO MACRO _graph_scan(
  -- The table containing the edges of the graph. Needs to have the columns
  -- `source_node_id` and `dest_node_id`.
  graph_table TableOrSubquery,
  -- The table of nodes to start the scan from. Needs to have the column `id`
  -- and all columns specified by `scan_columns`.
  init_table TableOrSubquery,
  -- A parenthesised and comma separated list of columns which will be returned
  -- by the scan. Should match exactly both the names and order of the columns
  -- in both `init_table` and `step_query`.
  --
  -- Example: (cumulative_sum, cumulative_count).
  scan_columns _ColumnNameList,
  -- A subquery which is reads all the data (from a variable table called $table)
  -- for a single step of the scan and performs some computation for each node in
  -- the step.
  --
  -- Should return a column `id` and all columns specified by `scan_columns`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  step_query TableOrSubquery
)
RETURNS TableOrSubquery AS
(
  select
    c0 as id,
    __intrinsic_token_apply!(
      _graph_scan_select,
      (c1, c2, c3, c4, c5, c6, c7),
      $scan_columns
    )
  from  __intrinsic_table_ptr(__intrinsic_graph_scan(
    (
      select __intrinsic_graph_agg(g.source_node_id, g.dest_node_id)
      from $graph_table g
    ),
    (
      select __intrinsic_row_dataframe_agg(
        'id', init_table.id,
        __intrinsic_token_apply!(
          _graph_scan_df_agg,
          $scan_columns,
          $scan_columns
        )
      )
      from $init_table AS init_table
    ),
    __intrinsic_stringify_ignore_table!($step_query),
    __intrinsic_stringify!($scan_columns)
  )) result
  where __intrinsic_table_ptr_bind(result.c0, 'id')
    and __intrinsic_token_apply_and!(
          _graph_scan_bind,
          (c1, c2, c3, c4, c5, c6, c7),
          $scan_columns
        )
);

-- Performs a "scan" over the graph starting at `init_table` and using `graph_table`
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- for edges to follow, aggregating on each node wherever possible using `agg_query`.
--
-- See https://en.wikipedia.org/wiki/Prefix_sum#Scan_higher_order_function for
-- details of what a scan means.
CREATE PERFETTO MACRO _graph_aggregating_scan(
  -- The table containing the edges of the graph. Needs to have the columns
  -- `source_node_id` and `dest_node_id`.
  graph_table TableOrSubquery,
  -- The table of nodes to start the scan from. Needs to have the column `id`
  -- and all columns specified by `agg_columns`.
  init_table TableOrSubquery,
  -- A parenthesised and comma separated list of columns which will be returned
  -- by the scan. Should match exactly both the names and order of the columns
  -- in both `init_table` and `agg_query`.
  --
  -- Example: (cumulative_sum, cumulative_count).
  agg_columns _ColumnNameList,
  -- A subquery which aggregates the data for one step of the scan. Should contain
  -- the column `id` and all columns specified by `agg_columns`. Should read from
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- a variable table labelled `$table`.
  agg_query TableOrSubquery
)
RETURNS TableOrSubquery AS
(
  select
    c0 as id,
    __intrinsic_token_apply!(
      _graph_scan_select,
      (c1, c2, c3, c4, c5, c6, c7),
      $agg_columns
    )
  from  __intrinsic_table_ptr(__intrinsic_graph_aggregating_scan(
    (
      select __intrinsic_graph_agg(g.source_node_id, g.dest_node_id)
      from $graph_table g
    ),
    (
      select __intrinsic_row_dataframe_agg(
        'id', init_table.id,
        __intrinsic_token_apply!(
          _graph_scan_df_agg,
          $agg_columns,
          $agg_columns
        )
      )
      from $init_table AS init_table
    ),
    __intrinsic_stringify_ignore_table!($agg_query),
    __intrinsic_stringify!($agg_columns)
  )) result
  where __intrinsic_table_ptr_bind(result.c0, 'id')
    and __intrinsic_token_apply_and!(
          _graph_scan_bind,
          (c1, c2, c3, c4, c5, c6, c7),
          $agg_columns
        )
);

)_d3l1m1t3r_"
;

const char kGraphsSearch[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Computes the "reachable" set of nodes in a directed graph from a given set
-- of starting nodes by performing a depth-first search on the graph. The
-- returned nodes are structured as a tree with parent-child relationships
-- corresponding to the order in which nodes were encountered by the DFS.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- level functions/macros in the standard library can be built.
--
-- Example usage on traces containing heap graphs:
-- ```
-- -- Compute the reachable nodes from the first heap root.
-- SELECT *
-- FROM graph_reachable_dfs!(
--   (
--     SELECT
--       owner_id AS source_node_id,
--       owned_id as dest_node_id
--     FROM heap_graph_reference
--     WHERE owned_id IS NOT NULL
--   ),
--   (SELECT id FROM heap_graph_object WHERE root_type IS NOT NULL)
-- );
-- ```
CREATE PERFETTO MACRO graph_reachable_dfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to the list of start nodes for
  -- the BFS. This table must have a single column "node_id".
  start_nodes TableOrSubquery
)
-- The returned table has the schema (node_id LONG, parent_node_id LONG).
-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS parent_node_id
  FROM __intrinsic_table_ptr(__intrinsic_dfs(
    (SELECT __intrinsic_graph_agg(g.source_node_id, g.dest_node_id) FROM $graph_table g),
    (SELECT __intrinsic_array_agg(t.node_id) arr FROM $start_nodes t)
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the DFS table.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
);

-- Computes the "reachable" set of nodes in a directed graph from a given
-- starting node by performing a breadth-first search on the graph. The returned
-- nodes are structured as a tree with parent-child relationships corresponding
-- to the order in which nodes were encountered by the BFS.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
-- level functions/macros in the standard library can be built.
--
-- Example usage on traces containing heap graphs:
-- ```
-- -- Compute the reachable nodes from all heap roots.
-- SELECT *
-- FROM graph_reachable_bfs!(
--   (
--     SELECT
--       owner_id AS source_node_id,
--       owned_id as dest_node_id
--     FROM heap_graph_reference
--     WHERE owned_id IS NOT NULL
--   ),
--   (SELECT id FROM heap_graph_object WHERE root_type IS NOT NULL)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- );
-- ```
CREATE PERFETTO MACRO graph_reachable_bfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to the list of start nodes for
  -- the BFS. This table must have a single column "node_id".
  start_nodes TableOrSubquery
)
-- The returned table has the schema (node_id LONG, parent_node_id LONG).
-- |node_id| is the id of the node from the input graph and |parent_node_id|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- is the id of the node which was the first encountered predecessor in a BFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  -- Rename the generic columns of __intrinsic_table_ptr to the actual columns.
  SELECT c0 AS node_id, c1 AS parent_node_id
  FROM __intrinsic_table_ptr(__intrinsic_bfs(
    (SELECT __intrinsic_graph_agg(g.source_node_id, g.dest_node_id) FROM $graph_table g),
    (SELECT __intrinsic_array_agg(t.node_id) arr FROM $start_nodes t)
  ))
  -- Bind the dynamic columns in the |__intrinsic_table_ptr| to the columns of
  -- the DFS table.
  WHERE __intrinsic_table_ptr_bind(c0, 'node_id')
    AND __intrinsic_table_ptr_bind(c1, 'parent_node_id')
);

-- Computes the next sibling node in a directed graph. The next node under a parent node
-- is determined by on the |sort_key|, which should be unique for every node under a parent.
-- The order of the next sibling is undefined if the |sort_key| is not unique.
--
-- Example usage:
-- ```
-- -- Compute the next sibling:
-- SELECT *
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- FROM graph_next_sibling!(
--   (
--     SELECT
--       id AS node_id,
--       parent_id AS node_parent_id,
--       ts AS sort_key
--     FROM slice
--   )
-- );
-- ```
CREATE PERFETTO MACRO graph_next_sibling(
  -- A table/view/subquery corresponding to a directed graph for which to find the next sibling.
  -- This table must have the columns "node_id", "node_parent_id" and "sort_key".
  graph_table TableOrSubquery
)
-- The returned table has the schema (node_id LONG, next_node_id LONG).
-- |node_id| is the id of the node from the input graph and |next_node_id|
-- is the id of the node which is its next sibling.
RETURNS TableOrSubquery AS
(
  SELECT node_id, lead(node_id) OVER (PARTITION BY node_parent_id ORDER BY sort_key) AS next_node_id
    FROM $graph_table
);

-- Computes the "reachable" set of nodes in a directed graph from a set of
-- starting (root) nodes by performing a depth-first search from each root node on the graph.
-- The search is bounded by the sum of edge weights on the path and the root node specifies the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- max weight (inclusive) allowed before stopping the search.
-- The returned nodes are structured as a tree with parent-child relationships corresponding
-- to the order in which nodes were encountered by the DFS. Each row also has the root node from
-- which where the edge was encountered.
--
-- While this macro can be used directly by end users (hence being public),
-- it is primarily intended as a lower-level building block upon which higher
-- level functions/macros in the standard library can be built.
--
-- Example usage on traces with sched info:
-- ```
-- -- Compute the reachable nodes from a sched wakeup chain
-- INCLUDE PERFETTO MODULE sched.thread_executing_spans;
--
-- SELECT *
-- FROM
--   graph_reachable_dfs_bounded
--    !(
--      (
--        SELECT
--          id AS source_node_id,
--          COALESCE(parent_id, id) AS dest_node_id,
--          id - COALESCE(parent_id, id) AS edge_weight
--        FROM _wakeup_chain
--      ),
--      (
--        SELECT
--          id AS root_node_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--          id - COALESCE(prev_id, id) AS root_target_weight
--        FROM _wakeup_chain
--      ));
-- ```
CREATE PERFETTO MACRO graph_reachable_weight_bounded_dfs(
  -- A table/view/subquery corresponding to a directed graph on which the
  -- reachability search should be performed. This table must have the columns
  -- "source_node_id" and "dest_node_id" corresponding to the two nodes on
  -- either end of the edges in the graph and an "edge_weight" corresponding to the
  -- weight of the edge between the node.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  graph_table TableOrSubquery,
  -- A table/view/subquery corresponding to start nodes to |graph_table| which will be the
  -- roots of the reachability trees. This table must have the columns
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- "root_node_id" and "root_target_weight" corresponding to the starting node id and the max
  -- weight allowed on the tree.
  --
  -- Note: the columns must contain uint32 similar to ids in trace processor
  -- tables (i.e. the values should be relatively dense and close to zero). The
  -- implementation makes assumptions on this for performance reasons and, if
  -- this criteria is not, can lead to enormous amounts of memory being
  -- allocated.
  root_table TableOrSubquery,
  -- Whether the target_weight is a floor weight or ceiling weight.
  -- If it's floor, the search stops right after we exceed the target weight, and we
  -- include the node that pushed just passed the target. If ceiling, the search stops
  -- right before the target weight and the node that would have pushed us passed the
  -- target is not included.
  is_target_weight_floor Expr

)
-- The returned table has the schema (root_node_id, node_id LONG, parent_node_id LONG).
-- |root_node_id| is the id of the starting node under which this edge was encountered.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
  WITH __temp_graph_table AS (SELECT * FROM $graph_table),
  __temp_root_table AS (SELECT * FROM $root_table)
  SELECT dt.root_node_id, dt.node_id, dt.parent_node_id
  FROM __intrinsic_dfs_weight_bounded(
    (SELECT RepeatedField(source_node_id) FROM __temp_graph_table),
    (SELECT RepeatedField(dest_node_id) FROM __temp_graph_table),
    (SELECT RepeatedField(edge_weight) FROM __temp_graph_table),
    (SELECT RepeatedField(root_node_id) FROM __temp_root_table),
    (SELECT RepeatedField(root_target_weight) FROM __temp_root_table),
    $is_target_weight_floor
  ) dt
);

)_d3l1m1t3r_"
;

const char kIntervalsIntersect[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO MACRO _ii_df_agg(x Expr, y Expr)
RETURNS Expr AS __intrinsic_stringify!($x), input.$y;

CREATE PERFETTO MACRO _ii_df_bind(x Expr, y Expr)
RETURNS Expr AS __intrinsic_table_ptr_bind($x, __intrinsic_stringify!($y));

CREATE PERFETTO MACRO _ii_df_select(x Expr, y Expr)
RETURNS Expr AS $x AS $y;

CREATE PERFETTO MACRO __first_arg(x Expr, y Expr)
RETURNS Expr AS $x;

CREATE PERFETTO MACRO _interval_agg(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  tab TableOrSubquery,
  agg_columns _ColumnNameList
)
RETURNS TableOrSubquery AS
(
  SELECT __intrinsic_interval_tree_intervals_agg(
    input.id,
    input.ts,
    input.dur
    __intrinsic_token_apply_prefix!(
      _ii_df_agg,
      $agg_columns,
      $agg_columns
    )
  )
  FROM (SELECT * FROM $tab ORDER BY ts) input
);

CREATE PERFETTO MACRO _interval_intersect(
  tabs _TableNameList,
  agg_columns _ColumnNameList
)
RETURNS TableOrSubquery AS
(
  SELECT
    c0 AS ts,
    c1 AS dur,
    -- Columns for tables ids, in the order of provided tables.
    __intrinsic_token_apply!(
      __first_arg,
      (c2 AS id_0, c3 AS id_1, c4 AS id_2, c5 AS id_3, c6 AS id_4),
      $tabs
    )
    -- Columns for partitions, one for each column with partition.
    __intrinsic_token_apply_prefix!(
      _ii_df_select,
      (c7, c8, c9, c10),
      $agg_columns
    )
  -- Interval intersect result table.
  FROM __intrinsic_table_ptr(
    __intrinsic_interval_intersect(
      __intrinsic_token_apply!(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        _interval_agg,
        $tabs,
        ($agg_columns, $agg_columns, $agg_columns, $agg_columns, $agg_columns)
      ),
      __intrinsic_stringify!($agg_columns)
    )
  )

  -- Bind the resulting columns
  WHERE __intrinsic_table_ptr_bind(c0, 'ts')
    AND __intrinsic_table_ptr_bind(c1, 'dur')
    -- Id columns
    AND __intrinsic_table_ptr_bind(c2, 'id_0')
    AND __intrinsic_table_ptr_bind(c3, 'id_1')
    AND __intrinsic_table_ptr_bind(c4, 'id_2')
    AND __intrinsic_table_ptr_bind(c5, 'id_3')
    AND __intrinsic_table_ptr_bind(c6, 'id_4')

    -- Partition columns.
    __intrinsic_token_apply_and_prefix!(
      _ii_df_bind,
      (c7, c8, c9, c10),
      $agg_columns
    )
);

CREATE PERFETTO MACRO _interval_intersect_single(
  ts Expr,
  dur Expr,
  t TableOrSubquery
)
RETURNS TableOrSubquery AS
(
  SELECT
  id_0 AS id,
  ts,
  dur
  FROM _interval_intersect!(
    ($t, (SELECT 0 AS id, $ts AS ts, $dur AS dur)),
    ()
  )
);

)_d3l1m1t3r_"
;

const char kIntervalsOverlap[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;

-- Compute the distribution of the overlap of the given intervals over time.
--
-- Each interval is a (ts, dur) pair and the overlap represented as a (ts, value)
-- counter, with the value corresponding to the number of intervals that overlap
-- the given timestamp and interval until the next timestamp.
CREATE PERFETTO MACRO intervals_overlap_count(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Table or subquery containing interval data.
    segments TableOrSubquery,
    -- Column containing interval starts (usually `ts`).
    ts_column ColumnName,
    -- Column containing interval durations (usually `dur`).
    dur_column ColumnName)
-- The returned table has the schema (ts TIMESTAMP, value LONG).
-- |ts| is the timestamp when the number of open segments changed. |value| is
-- the number of open segments.
RETURNS TableOrSubquery AS
(
-- Algorithm: for each segment, emit a +1 at the start and a -1 at the end.
-- Then, merge events with the same timestamp and compute a cumulative sum.
WITH
_starts AS (
  SELECT
    1 AS delta,
    $ts_column AS ts
  FROM $segments
),
_ends AS (
  SELECT
    -1 AS delta,
    $ts_column + $dur_column AS ts
  FROM $segments
  WHERE $dur_column != -1
),
_events AS (
  SELECT * FROM _starts
  UNION ALL
  SELECT * FROM _ends
),
-- Merge events with the same timestamp to avoid artifacts in the data.
_merged_events AS (
  SELECT ts, sum(delta) as delta
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM _events
  GROUP BY ts
)
SELECT
  ts,
  sum(delta) OVER (
    ORDER BY ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as value
FROM _merged_events
ORDER BY ts
);

-- Compute the distribution of the overlap of the given intervals over time from
-- slices in a same group.
--
-- Each interval is a (ts, dur, group) triple and the overlap represented as a
-- (ts, value, group) counter, with the value corresponding to the number of
-- intervals that belong to the same group and overlap the given timestamp and
-- interval until the next timestamp.
CREATE PERFETTO MACRO intervals_overlap_count_by_group(
    -- Table or subquery containing interval data.
    segments TableOrSubquery,
    -- Column containing interval starts (usually `ts`).
    ts_column ColumnName,
    -- Column containing interval durations (usually `dur`).
    dur_column ColumnName,
    -- Column containing group name for grouping.
    group_column ColumnName)
-- The returned table has the schema (ts INT64, value UINT32, group_name) where
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- the type of group_name is the same as that in |segments|.
-- |ts| is the timestamp when the number of open segments changed. |value| is
-- the number of open segments. |group_name| is the name of a group used for the
-- overlap calculation.
RETURNS TableOrSubquery AS
(
-- Algorithm: for each segment, emit a +1 at the start and a -1 at the end.
-- Then, merge events with the same timestamp and compute a cumulative sum for
-- each group.
WITH
_starts AS (
  SELECT
    1 AS delta,
    $ts_column AS ts,
    $group_column AS group_name
  FROM $segments
),
_ends AS (
  SELECT
    -1 AS delta,
    $ts_column + $dur_column AS ts,
    $group_column AS group_name
  FROM $segments
  WHERE $dur_column != -1
),
_events AS (
  SELECT * FROM _starts
  UNION ALL
  SELECT * FROM _ends
),
-- Merge events with the same timestamp to avoid artifacts in the data.
_merged_events AS (
  SELECT ts, sum(delta) as delta,
  group_name
  FROM _events
  GROUP BY ts, group_name
)
SELECT
  ts,
  sum(delta) OVER (
    PARTITION BY group_name
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ORDER BY ts
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as value,
  group_name
FROM _merged_events
ORDER BY ts
);

-- Returns whether |intervals| contains any overlapping intervals. Useful for
-- checking if provided table/subquery can be used for intervals_intersect
-- macro.
CREATE PERFETTO MACRO _intervals_overlap_in_table(
  -- Table/subquery of intervals with |ts| and |dur| columns.
  intervals TableOrSubquery)
-- Returns 1 if table contains overlapping intervals. Otherwise returns 0.
RETURNS Expr AS (
WITH ts_with_next AS (
  SELECT
    ts + dur AS ts_end,
    -- The last slice will have |next_ts == NULL|, but it's not an issue as if
    -- it's the last slice we know that it will not overlap with the next one.
    LEAD(ts) OVER (ORDER BY ts) AS next_ts
  FROM $intervals
  WHERE dur != -1
), filtered AS (
  SELECT * FROM ts_with_next
  WHERE ts_end > next_ts
  LIMIT 1
)
SELECT count() AS has_overlaps
FROM filtered
);

-- Merges a |roots_table| and |children_table| into one table. See _intervals_flatten
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- that accepts the output of this macro to flatten intervals.

-- See: _intervals_merge_root_and_children_by_intersection.
CREATE PERFETTO MACRO _intervals_merge_root_and_children(
  -- Table or subquery containing all the root intervals: (id, ts, dur).
  -- Note that parent_id is not necessary in this table as it will be NULL anyways.
  roots_table TableOrSubquery,
  -- Table or subquery containing all the child intervals:
  -- (root_id, id, parent_id, ts, dur)
  children_table TableOrSubquery)
-- The returned table has the schema (root_id LONG, root_ts TIMESTAMP, root_dur, LONG,
-- id LONG, parent_id LONG, ts TIMESTAMP, dur LONG).
RETURNS TableOrSubquery
AS (
  WITH
    _roots AS (
      SELECT id AS root_id, ts AS root_ts, dur AS root_dur FROM ($roots_table) WHERE dur > 0
    ),
    _children AS (
      SELECT * FROM ($children_table) WHERE dur > 0
    ),
    _roots_without_children AS (
      SELECT root_id FROM _roots
      EXCEPT
      SELECT DISTINCT parent_id AS root_id FROM _children
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
    SELECT
      _roots.root_id,
      _roots.root_ts,
      _roots.root_dur,
      _children.id,
      _children.parent_id,
      _children.ts,
      _children.dur
    FROM _children
    JOIN _roots USING(root_id)
    UNION ALL
    -- Handle singleton roots
    SELECT
      root_id,
      root_ts,
      root_dur,
      NULL AS id,
      NULL AS parent_id,
      NULL AS ts,
      NULL AS dur
    FROM _roots_without_children
    JOIN _roots USING(root_id)
);

-- Merges a |roots_table| and |children_table| into one table. See _intervals_flatten
-- that accepts the output of this macro to flatten intervals.

-- This is very similar to _intervals_merge_root_and_children but there is no explicit
-- root_id shared between the root and the children. Instead an _interval_intersect is
-- used to derive the root and child relationships.
CREATE PERFETTO MACRO _intervals_merge_root_and_children_by_intersection(
  -- Table or subquery containing all the root intervals: (id, ts, dur).
  -- Note that parent_id is not necessary in this table as it will be NULL anyways.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  roots_table TableOrSubquery,
  -- Table or subquery containing all the child intervals:
  -- (root_id, id, parent_id, ts, dur)
  children_table TableOrSubquery,
  -- intersection key used in deriving the root child relationships.
  key ColumnName)
RETURNS TableOrSubQuery
AS (
  WITH
    _roots AS (
      SELECT * FROM $roots_table WHERE dur > 0 ORDER BY ts
    ),
    _children AS (
      SELECT * FROM $children_table WHERE dur > 0 ORDER BY ts
    )
    SELECT
      ii.ts,
      ii.dur,
      _children.id,
      IIF(_children.parent_id IS NULL, id_1, _children.parent_id) AS parent_id,
      _roots.id AS root_id,
      _roots.ts AS root_ts,
      _roots.dur AS root_dur,
      ii.$key
    FROM _interval_intersect!((_children, _roots), ($key)) ii
    JOIN _children
      ON _children.id = id_0
    JOIN _roots
      ON _roots.id = id_1
);

-- Partition and flatten a hierarchy of intervals into non-overlapping intervals where
-- each resulting interval is the leaf in the hierarchy at any given time. The result also
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- denotes the 'self-time' of each interval.
--
-- Each interval is a (root_id, root_ts, root_dur, id, parent_id, ts, dur) and the overlap is
-- represented as a (root_id, id, parent_id, ts, dur).
-- Note that, children intervals must not be longer than any ancestor interval.
-- See _intervals_merge_root_and_children that can be used to generate input to this macro
-- from two different root and children tables.
CREATE PERFETTO MACRO _intervals_flatten(children_with_roots_table TableOrSubquery)
-- The returned table has the schema (root_id LONG, id LONG, ts TIMESTAMP, dur LONG).
RETURNS TableOrSubquery
AS (
  -- Algorithm: Sort all the start and end timestamps of the children within a root.
  -- The interval duration between one timestamp and the next is one result.
  -- If the timestamp is a start, the id is the id of the interval, if it's an end,
  -- it's the parent_id.
  -- Special case the edges of the roots and roots without children.
  WITH
    _children_with_roots AS (
      SELECT * FROM ($children_with_roots_table) WHERE root_dur > 0 AND (dur IS NULL OR dur > 0)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ),
    _ends AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        IFNULL(parent_id, root_id) AS id,
        ts + dur AS ts
      FROM _children_with_roots WHERE id IS NOT NULL
    ),
    _events AS (
      SELECT root_id, root_ts, root_dur, id, ts, 1 AS priority
      FROM _children_with_roots
      UNION ALL
      SELECT root_id, root_ts, root_dur, id, ts, 0 AS priority FROM _ends
    ),
    _events_deduped AS (
      SELECT root_id, root_ts, root_dur, id, ts
      FROM _events
      GROUP BY root_id, ts
      HAVING priority = MAX(priority)
    ),
    _intervals AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        id,
        ts,
        LEAD(ts)
          OVER (PARTITION BY root_id ORDER BY ts) - ts AS dur
      FROM _events_deduped
    ),
    _only_middle AS (
      SELECT * FROM _intervals WHERE dur > 0
    ),
    _only_start AS (
      SELECT
        root_id,
        root_id AS id,
        root_ts AS ts,
        MIN(ts) - root_ts AS dur
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM _only_middle
      GROUP BY root_id
      HAVING dur > 0
    ),
    _only_end AS (
      SELECT
        root_id,
        root_id AS id,
        MAX(ts + dur) AS ts,
        root_ts + root_dur - MAX(ts + dur) AS dur
      FROM _only_middle
      GROUP BY root_id
      HAVING dur > 0
    ),
    _only_singleton AS (
      SELECT root_id, root_id AS id, root_ts AS ts, root_dur AS dur
      FROM _children_with_roots WHERE id IS NULL
      GROUP BY root_id
    )
  SELECT root_id, id, ts, dur FROM _only_middle
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_start
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_end
  UNION ALL
  SELECT root_id, id, ts, dur FROM _only_singleton
);

)_d3l1m1t3r_"
;

const char kLinuxCpuUtilizationGeneral[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.frequency;

-- Returns the timestamp of the start of the partition that contains the |ts|.
CREATE PERFETTO FUNCTION _partition_start(ts TIMESTAMP, size LONG) RETURNS LONG AS
-- Division of two ints would result in floor(ts/size).
SELECT ($ts/$size)*$size;

-- Returns the number of partitions required to cover all of the trace
-- timestamps.
CREATE PERFETTO FUNCTION _partition_count(size LONG) RETURNS LONG AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
    (_partition_start(TRACE_END(), $size) -
    _partition_start(TRACE_START(), $size))/$size + 1;

-- Returns a table of partitions with first partition containing the
-- TRACE_START() and last one containing TRACE_END().
CREATE PERFETTO FUNCTION _partitions(size LONG)
RETURNS TABLE (ts TIMESTAMP, ts_end LONG) AS
WITH no_ends AS (
SELECT
    _partition_start(TRACE_START(), $size) + (id * $size) AS ts
-- We are using the sched table for source of ids. If the table is too small
-- for specified size, the results would be invalid none the less.
FROM sched
LIMIT _partition_count($size))
SELECT ts, ts + $size AS ts_end FROM no_ends;

-- Partitions any |intervals| table with partitions defined in the |partitions|
-- table.
CREATE PERFETTO MACRO _interval_partitions(
  -- Requires |ts| and |ts_end| columns.
  partitions TableOrSubquery,
  -- Requires |ts| and |ts_end| column.
  intervals TableOrSubquery
) RETURNS TableOrSubquery AS (
SELECT
  p.ts AS partition_ts,
  IIF(i.ts_end < p.ts_end, i.ts_end, p.ts_end) AS ts_end,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IIF(i.ts < p.ts, p.ts, i.ts) AS ts
FROM $intervals i
JOIN $partitions p
ON (p.ts <= i.ts AND i.ts < p.ts_end));

-- Returns a table of utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO MACRO _cpu_avg_utilization_per_period(
  -- Length of the period on which utilization should be averaged.
  interval Expr,
  -- Either sched table or its filtered down version.
  sched_table TableOrSubquery
)
-- The returned table has the schema (ts TIMESTAMP, utilization DOUBLE,
-- unnormalized_utilization DOUBLE).
RETURNS TableOrSubquery AS (
SELECT
  partition_ts AS ts,
  SUM(ts_end - ts)/(cast_double!($interval) * (SELECT MAX(cpu) + 1 FROM sched)) AS utilization,
  SUM(ts_end - ts)/cast_double!($interval) AS unnormalized_utilization
FROM _interval_partitions!(_partitions($interval), $sched_table)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY 1);

CREATE PERFETTO VIEW _cpu_freq_for_metrics AS
SELECT
    id,
    ts,
    dur,
    cpu,
    ucpu,
    freq
FROM cpu_frequency_counters
WHERE freq IS NOT NULL;

CREATE PERFETTO VIEW _sched_without_id AS
SELECT ts, dur, utid, ucpu
FROM sched
WHERE utid != 0 AND dur != -1;

CREATE VIRTUAL TABLE _cpu_freq_per_thread_span_join
USING SPAN_LEFT_JOIN(
    _sched_without_id PARTITIONED ucpu,
    _cpu_freq_for_metrics PARTITIONED ucpu);

CREATE PERFETTO TABLE _cpu_freq_per_thread_no_id
AS
SELECT *
FROM _cpu_freq_per_thread_span_join;

CREATE PERFETTO VIEW _cpu_freq_per_thread AS
SELECT
  _auto_id AS id,
  ts,
  dur,
  ucpu,
  cpu,
  utid,
  freq,
  id AS counter_id
FROM _cpu_freq_per_thread_no_id;


)_d3l1m1t3r_"
;

const char kLinuxCpuUtilizationProcess[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.utilization.general;

INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE intervals.intersect;

-- Returns a table of process utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION cpu_process_utilization_per_period(
    -- Length of the period on which utilization should be averaged.
    interval LONG,
    -- Upid of the process.
    upid JOINID(process.id)
)
RETURNS TABLE(
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
WITH sched_for_upid AS (
  SELECT
    ts,
    ts_end,
    utid
  FROM sched
  JOIN thread USING (utid)
  JOIN process USING (upid)
  WHERE upid = $upid AND utid != 0)
SELECT * FROM _cpu_avg_utilization_per_period!($interval, sched_for_upid);

-- Returns a table of process utilization per second.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_process_utilization_per_second(
  -- Upid of the process.
  upid JOINID(process.id)
)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT * FROM cpu_process_utilization_per_period(time_from_s(1), $upid);

-- Aggregated CPU statistics for each process.
CREATE PERFETTO TABLE cpu_cycles_per_process(
  -- Unique process id
  upid JOINID(process.id),
  -- Sum of CPU millicycles
  millicycles LONG,
  -- Sum of CPU megacycles
  megacycles LONG,
  -- Total runtime duration
  runtime LONG,
  -- Minimum CPU frequency in kHz
  min_freq LONG,
  -- Maximum CPU frequency in kHz
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  max_freq LONG,
  -- Average CPU frequency in kHz
  avg_freq LONG
) AS
SELECT
  upid,
  cast_int!(SUM(dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(dur * freq / 1000) / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq / 1000)) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
JOIN thread USING (utid)
WHERE upid IS NOT NULL
GROUP BY upid;

-- Aggregated CPU statistics for each process in a provided interval.
CREATE PERFETTO FUNCTION cpu_cycles_per_process_in_interval(
    -- Start of the interval.
    ts TIMESTAMP,
    -- Duration of the interval.
    dur LONG
)
RETURNS TABLE(
  -- Unique process id.
  upid JOINID(process.id),
  -- Sum of CPU millicycles
  millicycles LONG,
  -- Sum of CPU megacycles
  megacycles LONG,
  -- Total runtime duration
  runtime LONG,
  -- Minimum CPU frequency in kHz
  min_freq LONG,
  -- Maximum CPU frequency in kHz
  max_freq LONG,
  -- Average CPU frequency in kHz
  avg_freq LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
WITH threads_counters AS (
  SELECT c.id, c.ts, c.dur, c.freq, upid
  FROM _cpu_freq_per_thread c
  JOIN thread USING (utid)
)
SELECT
  upid,
  cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(ii.dur * freq / 1000) / 1e9) AS megacycles,
  SUM(ii.dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((ii.dur * freq / 1000)) / SUM(ii.dur / 1000)) AS avg_freq
FROM _interval_intersect_single!($ts, $dur, threads_counters) ii
JOIN threads_counters USING (id)
GROUP BY upid;

)_d3l1m1t3r_"
;

const char kLinuxCpuUtilizationSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.utilization.general;

INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE slices.with_context;

-- CPU cycles per each slice.
CREATE PERFETTO TABLE cpu_cycles_per_thread_slice(
  -- Id of a slice.
  id JOINID(slice.id),
  -- Name of the slice.
  name STRING,
  -- Id of the thread the slice is running on.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  utid JOINID(thread.id),
  -- Name of the thread.
  thread_name STRING,
  -- Id of the process the slice is running on.
  upid JOINID(process.id),
  -- Name of the process.
  process_name STRING,
  -- Sum of CPU millicycles. Null if frequency couldn't be fetched for any
  -- period during the runtime of the slice.
  millicycles LONG,
  -- Sum of CPU megacycles. Null if frequency couldn't be fetched for any
  -- period during the runtime of the slice.
  megacycles LONG
) AS
WITH intersected AS (
  SELECT
    id_0 AS slice_id,
    ii.utid,
    sum(ii.dur) AS dur,
    cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
    cast_int!(SUM(ii.dur * freq / 1000) / 1e9) AS megacycles
  FROM _interval_intersect!(
    ((SELECT * FROM thread_slice WHERE dur > 0 AND utid > 0),
    _cpu_freq_per_thread), (utid)) ii
  JOIN _cpu_freq_per_thread f ON f.id = ii.id_1
  WHERE freq IS NOT NULL
  GROUP BY slice_id
)
SELECT
  id,
  ts.name,
  ts.utid,
  ts.thread_name,
  ts.upid,
  ts.process_name,
  millicycles,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  megacycles
FROM thread_slice ts
LEFT JOIN intersected ON slice_id = ts.id AND ts.dur = intersected.dur;

-- CPU cycles per each slice in interval.
CREATE PERFETTO FUNCTION cpu_cycles_per_thread_slice_in_interval(
  -- Start of the interval.
  ts TIMESTAMP,
  -- Duration of the interval.
  dur DURATION
)
RETURNS TABLE(
  -- Thread slice.
  id JOINID(slice.id),
  -- Name of the slice.
  name STRING,
  -- Thread the slice is running on.
  utid JOINID(thread.id),
  -- Name of the thread.
  thread_name STRING,
  -- Process the slice is running on.
  upid JOINID(process.id),
  -- Name of the process.
  process_name STRING,
  -- Sum of CPU millicycles. Null if frequency couldn't be fetched for any
  -- period during the runtime of the slice.
  millicycles LONG,
  -- Sum of CPU megacycles. Null if frequency couldn't be fetched for any
  -- period during the runtime of the slice.
  megacycles LONG
) AS
WITH cut_thread_slice AS (
  SELECT id, ii.ts, ii.dur, thread_slice.*
  FROM _interval_intersect_single!(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    $ts, $dur,
    (SELECT * FROM thread_slice WHERE dur > 0 AND utid > 0)) ii
  JOIN thread_slice USING (id)
),
intersected AS (
  SELECT
    id_0 AS slice_id,
    ii.utid,
    sum(ii.dur) AS dur,
    cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
    cast_int!(SUM(ii.dur * freq / 1000) / 1e9) AS megacycles
  FROM _interval_intersect!(
    (cut_thread_slice, _cpu_freq_per_thread), (utid)) ii
  JOIN _cpu_freq_per_thread f ON f.id = ii.id_1
  WHERE freq IS NOT NULL
  GROUP BY slice_id
)
SELECT
  id,
  ts.name,
  ts.utid,
  ts.thread_name,
  ts.upid,
  ts.process_name,
  millicycles,
  megacycles
FROM cut_thread_slice ts
LEFT JOIN intersected ON slice_id = ts.id AND ts.dur = intersected.dur;
)_d3l1m1t3r_"
;

const char kLinuxCpuUtilizationSystem[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.utilization.general;
INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE intervals.intersect;

-- The purpose of this module is to provide high level aggregates of system
-- utilization, akin to /proc/stat results.

-- Returns a table of system utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
CREATE PERFETTO FUNCTION cpu_utilization_per_period(
  -- Length of the period on which utilization should be averaged.
  interval LONG)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT *
FROM _cpu_avg_utilization_per_period!(
  $interval,
  (SELECT * FROM sched WHERE utid != 0)
);

-- Table with system utilization per second.
-- Utilization is calculated by sum of average utilization of each CPU every
-- second. For this reason first and last second might have lower then real
-- utilization.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE cpu_utilization_per_second(
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT
  ts,
  utilization,
  unnormalized_utilization
FROM cpu_utilization_per_period(time_from_s(1));

-- Aggregated CPU statistics for whole trace. Results in only one row.
CREATE PERFETTO TABLE cpu_cycles(
  -- Sum of CPU millicycles.
  millicycles LONG,
  -- Sum of CPU megacycles.
  megacycles LONG,
  -- Total runtime of all threads running on all CPUs.
  runtime LONG,
  -- Minimum CPU frequency in kHz.
  min_freq LONG,
  -- Maximum CPU frequency in kHz.
  max_freq LONG,
  -- Average CPU frequency in kHz.
  avg_freq LONG
) AS
SELECT
  cast_int!(SUM(dur * freq / 1000)) AS millicycles,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cast_int!(SUM(dur * freq / 1000) / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq / 1000)) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread;

-- Aggregated CPU statistics in a provided interval. Results in one row.
CREATE PERFETTO FUNCTION cpu_cycles_in_interval(
    -- Start of the interval.
    ts TIMESTAMP,
    -- Duration of the interval.
    dur LONG
)
RETURNS TABLE(
  -- Sum of CPU millicycles.
  millicycles LONG,
  -- Sum of CPU megacycles.
  megacycles LONG,
  -- Total runtime of all threads running on all CPUs.
  runtime LONG,
  -- Minimum CPU frequency in kHz.
  min_freq LONG,
  -- Maximum CPU frequency in kHz.
  max_freq LONG,
  -- Average CPU frequency in kHz.
  avg_freq LONG
) AS
SELECT
  cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(ii.dur * freq / 1000) / 1e9) AS megacycles,
  SUM(ii.dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((ii.dur * freq / 1000)) / SUM(ii.dur / 1000)) AS avg_freq
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _interval_intersect_single!($ts, $dur, _cpu_freq_per_thread) ii
JOIN _cpu_freq_per_thread USING (id);

-- Aggregated CPU statistics for each CPU.
CREATE PERFETTO TABLE cpu_cycles_per_cpu(
  -- Unique CPU id. Joinable with `cpu.id`.
  ucpu LONG,
  -- The number of the CPU. Might not be the same as ucpu in multi machine cases.
  cpu LONG,
  -- Sum of CPU millicycles.
  millicycles LONG,
  -- Sum of CPU megacycles.
  megacycles LONG,
  -- Total runtime of all threads running on CPU.
  runtime LONG,
  -- Minimum CPU frequency in kHz.
  min_freq LONG,
  -- Maximum CPU frequency in kHz.
  max_freq LONG,
  -- Average CPU frequency in kHz.
  avg_freq LONG
) AS
SELECT
  ucpu,
  cpu,
  cast_int!(SUM(dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(dur * freq / 1000) / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq / 1000)) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
GROUP BY ucpu;

-- Aggregated CPU statistics for each CPU in a provided interval.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION cpu_cycles_per_cpu_in_interval(
    -- Start of the interval.
    ts TIMESTAMP,
    -- Duration of the interval.
    dur LONG
)
RETURNS TABLE(
  -- Unique CPU id. Joinable with `cpu.id`.
  ucpu LONG,
  -- CPU number.
  cpu LONG,
  -- Sum of CPU millicycles.
  millicycles LONG,
  -- Sum of CPU megacycles.
  megacycles LONG,
  -- Total runtime of all threads running on CPU.
  runtime LONG,
  -- Minimum CPU frequency in kHz.
  min_freq LONG,
  -- Maximum CPU frequency in kHz.
  max_freq LONG,
  -- Average CPU frequency in kHz.
  avg_freq LONG
) AS
SELECT
  ucpu,
  cpu,
  cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(ii.dur * freq / 1000) / 1e9) AS megacycles,
  SUM(ii.dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((ii.dur * freq / 1000)) / SUM(ii.dur / 1000)) AS avg_freq
FROM _interval_intersect_single!($ts, $dur, _cpu_freq_per_thread) ii
JOIN _cpu_freq_per_thread USING (id)
GROUP BY ucpu;

)_d3l1m1t3r_"
;

const char kLinuxCpuUtilizationThread[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.utilization.general;
INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE intervals.intersect;

-- Returns a table of thread utilization per given period.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION cpu_thread_utilization_per_period(
    -- Length of the period on which utilization should be averaged.
    interval LONG,
    -- Utid of the thread.
    utid JOINID(thread.id)
)
RETURNS TABLE(
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
WITH sched_for_utid AS (
  SELECT
    ts,
    ts_end,
    utid
  FROM sched
  WHERE utid = $utid
) SELECT * FROM _cpu_avg_utilization_per_period!($interval, sched_for_utid);

-- Returns a table of thread utilization per second.
-- Utilization is calculated as sum of average utilization of each CPU in each
-- period, which is defined as a multiply of |interval|. For this reason
-- first and last period might have lower then real utilization.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO FUNCTION cpu_thread_utilization_per_second(
  -- Utid of the thread.
  utid JOINID(thread.id)
)
RETURNS TABLE (
  -- Timestamp of start of a second.
  ts TIMESTAMP,
  -- Sum of average utilization over period.
  -- Note: as the data is normalized, the values will be in the
  -- [0, 1] range.
  utilization DOUBLE,
  -- Sum of average utilization over all CPUs over period.
  -- Note: as the data is unnormalized, the values will be in the
  -- [0, cpu_count] range.
  unnormalized_utilization DOUBLE
) AS
SELECT * FROM cpu_thread_utilization_per_period(time_from_s(1), $utid);

-- Aggregated CPU statistics for each thread.
CREATE PERFETTO TABLE cpu_cycles_per_thread(
  -- Thread
  utid JOINID(thread.id),
  -- Sum of CPU millicycles
  millicycles LONG,
  -- Sum of CPU megacycles
  megacycles LONG,
  -- Total runtime duration
  runtime LONG,
  -- Minimum CPU frequency in kHz
  min_freq LONG,
  -- Maximum CPU frequency in kHz
  max_freq LONG,
  -- Average CPU frequency in kHz
  avg_freq LONG
)_d3l1m1t3r_"
R"_d3l1m1t3r_() AS
SELECT
  utid,
  cast_int!(SUM(dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(dur * freq / 1000) / 1e9) AS megacycles,
  SUM(dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((dur * freq / 1000)) / SUM(dur / 1000)) AS avg_freq
FROM _cpu_freq_per_thread
GROUP BY utid;

-- Aggregated CPU statistics for each thread in a provided interval.
CREATE PERFETTO FUNCTION cpu_cycles_per_thread_in_interval(
    -- Start of the interval.
    ts TIMESTAMP,
    -- Duration of the interval.
    dur LONG
)
RETURNS TABLE(
  -- Thread with CPU cycles and frequency statistics.
  utid JOINID(thread.id),
  -- Sum of CPU millicycles
  millicycles LONG,
  -- Sum of CPU megacycles
  megacycles LONG,
  -- Total runtime duration
  runtime LONG,
  -- Minimum CPU frequency in kHz
  min_freq LONG,
  -- Maximum CPU frequency in kHz
  max_freq LONG,
  -- Average CPU frequency in kHz
  avg_freq LONG
) AS
SELECT
  utid,
  cast_int!(SUM(ii.dur * freq / 1000)) AS millicycles,
  cast_int!(SUM(ii.dur * freq / 1000 )/ 1e9) AS megacycles,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SUM(ii.dur) AS runtime,
  MIN(freq) AS min_freq,
  MAX(freq) AS max_freq,
  cast_int!(SUM((ii.dur * freq / 1000)) / SUM(ii.dur / 1000)) AS avg_freq
FROM _interval_intersect_single!($ts, $dur, _cpu_freq_per_thread) ii
JOIN _cpu_freq_per_thread c USING (id)
GROUP BY utid;

)_d3l1m1t3r_"
;

const char kLinuxCpuFrequency[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;

-- Counter information for each frequency change for each CPU. Finds each time
-- region where a CPU frequency is constant.
CREATE PERFETTO TABLE cpu_frequency_counters(
  -- Counter id.
  id LONG,
  -- Joinable with 'counter_track.id'.
  track_id JOINID(track.id),
  -- Starting timestamp of the counter
  ts TIMESTAMP,
  -- Duration in which counter is constant and frequency doesn't change.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- Frequency in kHz of the CPU that corresponds to this counter. NULL if not
  -- found or undefined.
  freq LONG,
  -- Unique CPU id.
  ucpu LONG,
  -- CPU that corresponds to this counter.
  cpu LONG
) AS
SELECT
  count_w_dur.id,
  count_w_dur.track_id,
  count_w_dur.ts,
  count_w_dur.dur,
  cast_int!(count_w_dur.value) as freq,
  cpu.ucpu,
  cct.cpu
FROM counter_leading_intervals!((
  SELECT c.*
  FROM counter c
  JOIN cpu_counter_track cct
  ON cct.id = c.track_id AND cct.name = 'cpufreq'
)) count_w_dur
JOIN cpu_counter_track cct ON track_id = cct.id
JOIN cpu ON cct.machine_id IS cpu.machine_id
  AND cct.cpu = cpu.cpu;

)_d3l1m1t3r_"
;

const char kLinuxCpuIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;

-- Counter information for each idle state change for each CPU. Finds each time
-- region where a CPU idle state is constant.
CREATE PERFETTO TABLE cpu_idle_counters(
  -- Counter id.
  id LONG,
  -- Joinable with 'counter_track.id'.
  track_id JOINID(track.id),
  -- Starting timestamp of the counter.
  ts TIMESTAMP,
  -- Duration in which the counter is contant and idle state doesn't change.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- Idle state of the CPU that corresponds to this counter. An idle state of -1
  -- is defined to be active state for the CPU, and the larger the integer, the
  -- deeper the idle state of the CPU. NULL if not found or undefined.
  idle LONG,
  -- CPU that corresponds to this counter.
  cpu LONG
) AS
SELECT
  count_w_dur.id,
  count_w_dur.track_id,
  count_w_dur.ts,
  count_w_dur.dur,
  cast_int!(IIF(count_w_dur.value = 4294967295, -1, count_w_dur.value)) AS idle,
  cct.cpu
FROM counter_leading_intervals!((
  SELECT c.*
  FROM counter c
  JOIN cpu_counter_track cct ON cct.id = c.track_id AND cct.name = 'cpuidle'
)) AS count_w_dur
JOIN cpu_counter_track AS cct ON track_id = cct.id;

)_d3l1m1t3r_"
;

const char kLinuxCpuIdleStats[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.idle;

-- Aggregates cpu idle statistics per core.
CREATE PERFETTO TABLE cpu_idle_stats(
  -- CPU core number.
  cpu LONG,
  -- CPU idle state (C-states).
  state LONG,
  -- The count of entering idle state.
  count LONG,
  -- Total CPU core idle state duration.
  dur DURATION,
  -- Average CPU core idle state duration.
  avg_dur DURATION,
  -- Idle state percentage of non suspend time (C-states + P-states).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  idle_percent DOUBLE
)
AS
WITH grouped AS (
  SELECT
    cpu,
    (idle + 1) AS state,
    COUNT(idle) AS count,
    SUM(dur) AS dur,
    SUM(dur) / COUNT(idle) AS avg_dur
  FROM cpu_idle_counters c
  WHERE c.idle >= 0
  GROUP BY c.cpu, c.idle
),
total AS (
  SELECT cpu, SUM(dur) AS dur
  FROM cpu_idle_counters
  GROUP BY cpu
)
SELECT
  g.*,
  g.dur * 100.0 / t.dur AS idle_percent
FROM grouped g
JOIN total t USING (cpu);

)_d3l1m1t3r_"
;

const char kLinuxCpuIdleTimeInState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
INCLUDE PERFETTO MODULE time.conversion;

-- Counter information for sysfs cpuidle states.
-- Tracks the percentage of time spent in each state between two timestamps, by
-- dividing the incremental time spent in one state, by time all CPUS spent in
-- any state.
CREATE PERFETTO TABLE cpu_idle_time_in_state_counters(
  -- Timestamp.
  ts TIMESTAMP,
  -- The machine this residency is calculated for.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  machine_id LONG,
  -- State name.
  state_name STRING,
  -- Percentage of time all CPUS spent in this state.
  idle_percentage DOUBLE,
  -- Incremental time spent in this state (residency), in microseconds.
  total_residency DOUBLE,
  -- Time all CPUS spent in any state, in microseconds.
  time_slice LONG
) AS
WITH cpu_counts_per_machine AS (
  SELECT machine_id, count(1) AS cpu_count
  FROM cpu
  GROUP BY machine_id
),
idle_states AS (
  SELECT
    c.ts,
    c.value,
    c.track_id,
    t.machine_id,
    EXTRACT_ARG(t.dimension_arg_set_id, 'cpu_idle_state') as state,
    EXTRACT_ARG(t.dimension_arg_set_id, 'cpu') as cpu
  FROM counter c
  JOIN track t on c.track_id = t.id
  WHERE t.classification = 'cpu_idle_state'
),
residency_deltas AS (
  SELECT
    ts,
    state,
    cpu,
    machine_id,
    value - (LAG(value) OVER (PARTITION BY track_id ORDER BY ts)) as delta
  FROM idle_states
),
total_residency_calc AS (
  SELECT
    ts,
    residency_deltas.machine_id,
    state AS state_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SUM(delta) as total_residency,
    -- Perfetto timestamp is in nanoseconds whereas sysfs cpuidle time
    -- is in microseconds.
    (
      cpu_counts_per_machine.cpu_count *
      (time_to_us(ts - LAG(ts, 1) over (PARTITION BY state ORDER BY ts)))
    )  as time_slice
  FROM residency_deltas
  -- The use of `IS` instead of `=` is intentional because machine_id can be
  -- null and we still want this join to work in that case.
  JOIN cpu_counts_per_machine
    ON residency_deltas.machine_id IS cpu_counts_per_machine.machine_id
  GROUP BY ts, residency_deltas.machine_id, state
)
SELECT
  ts,
  machine_id,
  state_name,
  MIN(100, (total_residency / time_slice) * 100) as idle_percentage,
  total_residency,
  time_slice
FROM total_residency_calc
WHERE time_slice IS NOT NULL
UNION ALL
-- Calculate c0 state by subtracting all other states from total time.
SELECT
  ts,
  machine_id,
  'C0' as state_name,
  (MAX(0,time_slice - SUM(total_residency)) / time_slice) * 100 AS idle_percentage,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  time_slice - SUM(total_residency),
  time_slice
FROM total_residency_calc
WHERE time_slice IS NOT NULL
GROUP BY ts;

)_d3l1m1t3r_"
;

const char kLinuxMemoryGeneral[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO VIEW _all_counters_per_process AS
SELECT
  ts,
  LEAD(
    ts, 1,
    (SELECT COALESCE(end_ts, trace_end())
    FROM process p WHERE p.upid = t.upid) + 1)
    OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  upid,
  value,
  track_id,
  name
FROM counter c JOIN process_counter_track t
ON t.id = c.track_id
WHERE upid IS NOT NULL;
)_d3l1m1t3r_"
;

const char kLinuxMemoryHighWatermark[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;
INCLUDE PERFETTO MODULE linux.memory.process;

CREATE PERFETTO TABLE _memory_rss_high_watermark_per_process_table AS
WITH with_rss AS (
    SELECT
        ts,
        dur,
        upid,
        COALESCE(file_rss, 0) + COALESCE(anon_rss, 0) + COALESCE(shmem_rss, 0) AS rss
    FROM _memory_rss_and_swap_per_process_table
),
high_watermark_as_counter AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
    ts,
    MAX(rss) OVER (PARTITION BY upid ORDER BY ts) AS value,
    -- `id` and `track_id` are hacks to use this table in
    -- `counter_leading_intervals` macro. As `track_id` is using for looking
    -- for duplicates, we are aliasing `upid` with it. `Id` is ignored by the macro.
    upid AS track_id,
    0 AS id
FROM with_rss
)
SELECT ts, dur, track_id AS upid, cast_int!(value) AS rss_high_watermark
FROM counter_leading_intervals!(high_watermark_as_counter);

-- For each process fetches the memory high watermark until or during
-- timestamp.
CREATE PERFETTO VIEW memory_rss_high_watermark_per_process
(
    -- Timestamp
    ts TIMESTAMP,
    -- Duration
    dur DURATION,
    -- Upid of the process
    upid JOINID(process.id),
    -- Pid of the process
    pid LONG,
    -- Name of the process
    process_name STRING,
    -- Maximum `rss` value until now
    rss_high_watermark LONG
) AS
SELECT
    ts,
    dur,
    upid,
    pid,
    name AS process_name,
    rss_high_watermark
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _memory_rss_high_watermark_per_process_table
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kLinuxMemoryProcess[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.memory.general;

-- All memory counters tables.

CREATE PERFETTO VIEW _anon_rss AS
SELECT
  ts,
  dur,
  upid,
  value AS anon_rss_val
FROM _all_counters_per_process
WHERE name = 'mem.rss.anon';

CREATE PERFETTO VIEW _file_rss AS
SELECT
  ts,
  dur,
  upid,
  value AS file_rss_val
FROM _all_counters_per_process
WHERE name = 'mem.rss.file';

CREATE PERFETTO VIEW _shmem_rss AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  ts,
  dur,
  upid,
  value AS shmem_rss_val
FROM _all_counters_per_process
WHERE name = 'mem.rss.shmem';

CREATE PERFETTO VIEW _swap AS
SELECT
  ts,
  dur,
  upid,
  value AS swap_val
FROM _all_counters_per_process
WHERE name = 'mem.swap';

-- Span joins

CREATE VIRTUAL TABLE _anon_swap_sj
USING SPAN_OUTER_JOIN(
  _anon_rss PARTITIONED upid,
  _swap PARTITIONED upid);

CREATE VIRTUAL TABLE _anon_swap_file_sj
USING SPAN_OUTER_JOIN(
  _anon_swap_sj PARTITIONED upid,
  _file_rss PARTITIONED upid
);

CREATE VIRTUAL TABLE _rss_swap_sj
USING SPAN_OUTER_JOIN(
  _anon_swap_file_sj PARTITIONED upid,
  _shmem_rss PARTITIONED upid
);

CREATE PERFETTO TABLE _memory_rss_and_swap_per_process_table AS
SELECT
  ts, dur, upid,
  cast_int!(anon_rss_val) AS anon_rss,
  cast_int!(file_rss_val) AS file_rss,
  cast_int!(shmem_rss_val) AS shmem_rss,
  cast_int!(swap_val) AS swap
FROM _rss_swap_sj;


-- Memory metrics timeline for each process.
CREATE PERFETTO VIEW memory_rss_and_swap_per_process(
  -- Timestamp
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Duration
  dur DURATION,
  -- Upid of the process
  upid JOINID(process.id),
  -- Pid of the process
  pid LONG,
  -- Name of the process
  process_name STRING,
  -- Anon RSS counter value
  anon_rss LONG,
  -- File RSS counter value
  file_rss LONG,
  -- Shared memory RSS counter value
  shmem_rss LONG,
  -- Total RSS value. Sum of `anon_rss`, `file_rss` and `shmem_rss`. Returns
  -- value even if one of the values is NULL.
  rss LONG,
  -- Swap counter value
  swap LONG,
  -- Sum or `anon_rss` and `swap`. Returns value even if one of the values is
  -- NULL.
  anon_rss_and_swap LONG,
  -- Sum or `rss` and `swap`. Returns value even if one of the values is NULL.
  rss_and_swap LONG
) AS
SELECT
  ts,
  dur,
  upid,
  pid,
  name AS process_name,
  anon_rss,
  file_rss,
  shmem_rss,
  -- We do COALESCE only on `shmem_rss` and `swap`, as it can be expected all
  -- process start to emit anon rss and file rss events (you'll need to at
  -- least read code and have some memory to work with) - so the NULLs are real
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  --  values. But it is possible that you will never swap or never use shmem,
  -- so those values are expected to often be NULLs, which shouldn't propagate
  -- into the values like `anon_and_swap` or `rss`.
  file_rss + anon_rss + COALESCE(shmem_rss, 0) AS rss,
  swap,
  anon_rss + COALESCE(swap, 0) AS anon_rss_and_swap,
  anon_rss + file_rss  + COALESCE(shmem_rss, 0) + COALESCE(swap, 0) AS rss_and_swap
FROM _memory_rss_and_swap_per_process_table
JOIN process USING (upid);

)_d3l1m1t3r_"
;

const char kLinuxPerfSamples[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE callstacks.stack_profile;

CREATE PERFETTO TABLE _linux_perf_raw_callstacks AS
SELECT *
FROM _callstacks_for_callsites!((
  SELECT p.callsite_id
  FROM perf_sample p
)) c
ORDER BY c.id;

-- Table summarising the callstacks captured during all
-- perf samples in the trace.
--
-- Specifically, this table returns a tree containing all
-- the callstacks seen during the trace with `self_count`
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- equal to the number of samples with that frame as the
-- leaf and `cumulative_count` equal to the number of
-- samples with the frame anywhere in the tree.
CREATE PERFETTO TABLE linux_perf_samples_summary_tree(
  -- The id of the callstack. A callstack in this context
  -- is a unique set of frames up to the root.
  id LONG,
  -- The id of the parent callstack for this callstack.
  parent_id LONG,
  -- The function name of the frame for this callstack.
  name STRING,
  -- The name of the mapping containing the frame. This
  -- can be a native binary, library, JAR or APK.
  mapping_name STRING,
  -- The name of the file containing the function.
  source_file STRING,
  -- The line number in the file the function is located at.
  line_number LONG,
  -- The number of samples with this function as the leaf
  -- frame.
  self_count LONG,
  -- The number of samples with this function appearing
  -- anywhere on the callstack.
  cumulative_count LONG
) AS
SELECT r.*, a.cumulative_count
FROM _callstacks_self_to_cumulative!((
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT id, parent_id, self_count
  FROM _linux_perf_raw_callstacks
)) a
JOIN _linux_perf_raw_callstacks r USING (id)
ORDER BY r.id;

)_d3l1m1t3r_"
;

const char kLinuxPerfSpe[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Contains ARM Statistical Profiling Extension records
CREATE PERFETTO VIEW linux_perf_spe_record(
  -- Timestap when the operation was sampled
  ts TIMESTAMP,
  -- Thread the operation executed in
  utid JOINID(thread.id),
  -- Exception level the instruction was executed in
  exception_level STRING,
  -- Instruction virtual address
  instruction_frame_id LONG,
  -- Type of operation sampled
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  operation STRING,
  -- The virtual address accessed by the operation (0 if no memory access was
  -- performed)
  data_virtual_address LONG,
  -- The physical address accessed by the operation (0 if no memory access was
  -- performed)
  data_physical_address LONG,
  -- Cycle count from the operation being dispatched for issue to the operation
  -- being complete.
  total_latency LONG,
  -- Cycle count from the operation being dispatched for issue to the operation
  -- being issued for execution.
  issue_latency LONG,
  -- Cycle count from a virtual address being passed to the MMU for translation
  -- to the result of the translation being available.
  translation_latency LONG,
  -- Where the data returned for a load operation was sourced
  data_source STRING,
  -- Operation generated an exception
  exception_gen BOOL,
  -- Operation architecturally retired
  retired BOOL,
  -- Operation caused a level 1 data cache access
  l1d_access BOOL,
  -- Operation caused a level 1 data cache refill
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  l1d_refill BOOL,
  -- Operation caused a TLB access
  tlb_access BOOL,
  -- Operation caused a TLB refill involving at least one translation table walk
  tlb_refill BOOL,
  -- Conditional instruction failed its condition code check
  not_taken BOOL,
  -- Whether a branch caused a correction to the predicted program flow
  mispred BOOL,
  -- Operation caused a last level data or unified cache access
  llc_access BOOL,
  -- Whether the operation could not be completed by the last level data cache
  -- (or any above)
  llc_refill BOOL,
  -- Operation caused an access to another socket in a multi-socket system
  remote_access BOOL,
  -- Operation that incurred additional latency due to the alignment of the
  -- address and the size of the data being accessed
  alignment BOOL,
  -- Whether the operation executed in transactional state
  tme_transaction BOOL,
  -- SVE or SME operation with at least one false element in the governing
  -- predicate(s)
  sve_partial_pred BOOL,
  -- SVE or SME operation with no true element in the governing predicate(s)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  sve_empty_pred BOOL,
  -- Whether a load operation caused a cache access to at least the level 2 data
  -- or unified cache
  l2d_access BOOL,
  -- Whether a load operation accessed and missed the level 2 data or unified
  -- cache. Not set for accesses that are satisfied from refilling data of a
  -- previous miss
  l2d_hit BOOL,
  -- Whether a load operation accessed modified data in a cache
  cache_data_modified BOOL,
  -- Wheter a load operation hit a recently fetched line in a cache
  recenty_fetched BOOL,
  -- Whether a load operation snooped data from a cache outside the cache
  -- hierarchy of this core
  data_snooped BOOL
) AS
SELECT
  ts,
  utid,
  exception_level,
  instruction_frame_id,
  operation,
  data_virtual_address,
  data_physical_address,
  total_latency,
  issue_latency,
  translation_latency,
  data_source,
  (events_bitmask & (1 << 0)) <> 0 AS exception_gen,
  (events_bitmask & (1 << 1)) <> 0 AS retired,
  (events_bitmask & (1 << 2)) <> 0 AS l1d_access,
  (events_bitmask & (1 << 3)) <> 0 AS l1d_refill,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  (events_bitmask & (1 << 4)) <> 0 AS tlb_access,
  (events_bitmask & (1 << 5)) <> 0 AS tlb_refill,
  (events_bitmask & (1 << 6)) <> 0 AS not_taken,
  (events_bitmask & (1 << 7)) <> 0 AS mispred,
  (events_bitmask & (1 << 8)) <> 0 AS llc_access,
  (events_bitmask & (1 << 9)) <> 0 AS llc_refill,
  (events_bitmask & (1 << 10)) <> 0 AS remote_access,
  (events_bitmask & (1 << 11)) <> 0 AS alignment,
  (events_bitmask & (1 << 17)) <> 0 AS tme_transaction,
  (events_bitmask & (1 << 17)) <> 0 AS sve_partial_pred,
  (events_bitmask & (1 << 18)) <> 0 AS sve_empty_pred,
  (events_bitmask & (1 << 19)) <> 0 AS l2d_access,
  (events_bitmask & (1 << 20)) <> 0 AS l2d_hit,
  (events_bitmask & (1 << 21)) <> 0 AS cache_data_modified,
  (events_bitmask & (1 << 22)) <> 0 AS recenty_fetched,
  (events_bitmask & (1 << 23)) <> 0 AS data_snooped
FROM __intrinsic_spe_record;

)_d3l1m1t3r_"
;

const char kLinuxBlockIo[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.overlap;

-- View tracking the number of IO operations remaining in the kernel IO queue or
-- a block device
CREATE PERFETTO VIEW linux_active_block_io_operations_by_device (
  -- timestamp when block_io_start or block_io_done happened
  ts LONG,
  -- the number of IO operations in the kernel queue or the device
  ops_in_queue_or_device LONG,
  -- the device processing the IO operations
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dev LONG
) AS
WITH
block_io_slice AS (
  SELECT
    slice.ts as ts,
    slice.dur as dur,
    extract_arg(track.dimension_arg_set_id, 'block_device') as dev
  FROM slice
  JOIN track ON slice.track_id = track.id AND track.classification = 'block_io'
)
SELECT
  ts,
  value as ops_in_queue_or_device,
  group_name as dev
FROM intervals_overlap_count_by_group!(block_io_slice, ts, dur, dev);

-- Extracts the major id from a device id
CREATE PERFETTO FUNCTION linux_device_major_id(
  -- device id (userland dev_t value)
  dev LONG
)
-- 12 bits major id
RETURNS LONG AS
SELECT ($dev >> 8) & ((1 << 12) - 1);

-- Extracts the minor id from a device id
CREATE PERFETTO FUNCTION linux_device_minor_id(
  -- device id (userland dev_t value)
  dev LONG
)
-- 20 bits minor id
RETURNS LONG AS
SELECT ($dev & ((1 << 8) - 1)) | (($dev >> 20) << 8);

)_d3l1m1t3r_"
;

const char kLinuxDevfreq[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;

-- Gets devfreq frequency counter based on device queried. These counters will
-- only be available if the "devfreq/devfreq_frequency" ftrace event is enabled.
CREATE PERFETTO FUNCTION _get_devfreq_counters(
  -- Devfreq name to query for.
  device_name STRING
)
RETURNS TABLE(
  -- Unique identifier for this counter.
  id LONG,
  -- Starting timestamp of the counter.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Duration in which counter is constant and frequency doesn't chamge.
  dur DURATION,
  -- Frequency in kHz of the device that corresponds to the counter.
  freq LONG
) AS
SELECT
  count_w_dur.id,
  count_w_dur.ts,
  count_w_dur.dur,
  cast_int!(count_w_dur.value) as freq
FROM counter_leading_intervals!((
  SELECT c.*
  FROM counter c
  JOIN track t ON t.id = c.track_id
  WHERE t.classification = 'linux_device_frequency'
    AND EXTRACT_ARG(t.dimension_arg_set_id, 'linux_device') GLOB $device_name
)) AS count_w_dur;

-- ARM DSU device frequency counters. This table will only be populated on
-- traces collected with "devfreq/devfreq_frequency" ftrace event enabled,
-- and from ARM devices with the DSU (DynamIQ Shared Unit) hardware.
CREATE PERFETTO TABLE linux_devfreq_dsu_counter(
  -- Unique identifier for this counter.
  id LONG,
  -- Starting timestamp of the counter.
  ts TIMESTAMP,
  -- Duration in which counter is constant and frequency doesn't chamge.
  dur DURATION,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Frequency in kHz of the device that corresponds to the counter.
  dsu_freq LONG
) AS
SELECT
  id, ts, dur, freq as dsu_freq
FROM _get_devfreq_counters("*devfreq_dsu");

)_d3l1m1t3r_"
;

const char kLinuxThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All kernel threads of the trace. As kernel threads are processes, provides
-- also process data.
CREATE PERFETTO TABLE linux_kernel_threads(
    -- Upid of kernel thread. Alias of |process.upid|.
    upid JOINID(process.id),
    -- Utid of kernel thread. Alias of |thread.utid|.
    utid JOINID(thread.id),
    -- Pid of kernel thread. Alias of |process.pid|.
    pid LONG,
    -- Tid of kernel thread. Alias of |process.pid|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    tid LONG,
    -- Name of kernel process. Alias of |process.name|.
    process_name STRING,
    -- Name of kernel thread. Alias of |thread.name|.
    thread_name STRING,
    -- Machine id of kernel thread. If NULL then it's a single machine trace.
    -- Alias of |process.machine_id|.
    machine_id LONG
) AS
WITH pid_2 AS (
    SELECT upid, pid, name, machine_id
    FROM process
    WHERE pid = 2
),
parent_pid_2 AS (
    SELECT p.upid, p.pid, p.name, p.machine_id
    FROM process p
    JOIN pid_2 ON p.parent_upid = pid_2.upid
)
SELECT
    upid,
    utid,
    pid,
    tid,
    p.name AS process_name,
    t.name AS thread_name,
    p.machine_id
FROM
(
    SELECT * FROM parent_pid_2
    UNION
    SELECT * FROM pid_2
) p
JOIN thread t USING (upid);
)_d3l1m1t3r_"
;

const char kPkvmHypervisor[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Events when CPU entered hypervisor.
CREATE PERFETTO VIEW pkvm_hypervisor_events(
  -- Id of the corresponding slice in slices table.
  slice_id JOINID(slice.id),
  -- CPU that entered hypervisor.
  cpu LONG,
  -- Timestamp when CPU entered hypervisor.
  ts TIMESTAMP,
  -- How much time CPU spent in hypervisor.
  dur DURATION,
  -- Reason for entering hypervisor (e.g. host_hcall, host_mem_abort), or NULL if unknown.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  reason STRING
) AS
SELECT
  slices.id as slice_id,
  cpu_track.cpu as cpu,
  slices.ts as ts,
  slices.dur as dur,
  EXTRACT_ARG(slices.arg_set_id, 'hyp_enter_reason') as reason
FROM slices
JOIN cpu_track ON cpu_track.id = slices.track_id
WHERE
  slices.category = 'pkvm_hyp'

)_d3l1m1t3r_"
;

const char kPreludeAfterEofCasts[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Casts |value| to INT.
CREATE PERFETTO MACRO cast_int(
    -- Query or subquery that will be cast.
    value Expr
) RETURNS Expr AS
CAST($value AS INT);

-- Casts |value| to DOUBLE.
CREATE PERFETTO MACRO cast_double(
    -- Query or subquery that will be cast.
    value Expr
) RETURNS Expr AS
CAST($value AS REAL);

-- Casts |value| to STRING.
CREATE PERFETTO MACRO cast_string(
    -- Query or subquery that will be cast.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    value Expr
) RETURNS Expr AS
CAST($value AS TEXT);
)_d3l1m1t3r_"
;

const char kPreludeAfterEofSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE prelude.after_eof.views;

-- Given two slice ids, returns whether the first is an ancestor of the second.
CREATE PERFETTO FUNCTION slice_is_ancestor(
  -- Id of the potential ancestor slice.
  ancestor_id LONG,
  -- Id of the potential descendant slice.
  descendant_id LONG
)
-- Whether `ancestor_id` slice is an ancestor of `descendant_id`.
RETURNS BOOL AS
SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ancestor.track_id = descendant.track_id AND
  ancestor.ts <= descendant.ts AND
  (ancestor.dur == -1 OR ancestor.ts + ancestor.dur >= descendant.ts + descendant.dur)
FROM slice ancestor
JOIN slice descendant
WHERE ancestor.id = $ancestor_id
  AND descendant.id = $descendant_id;
)_d3l1m1t3r_"
;

const char kPreludeAfterEofTablesViews[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE prelude.after_eof.views;

-- Lists all metrics built-into trace processor.
CREATE PERFETTO VIEW trace_metrics(
  -- The name of the metric.
  name STRING
) AS
SELECT name FROM _trace_metrics;

-- Definition of `trace_bounds` table. The values are being filled by Trace
-- Processor when parsing the trace.
-- It is recommended to depend on the `trace_start()` and `trace_end()`
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- functions rather than directly on `trace_bounds`.
CREATE PERFETTO VIEW trace_bounds(
  -- First ts in the trace.
  start_ts TIMESTAMP,
  -- End of the trace.
  end_ts TIMESTAMP
) AS
SELECT start_ts, end_ts FROM _trace_bounds;

-- Tracks are a fundamental concept in trace processor and represent a
-- "timeline" for events of the same type and with the same context. See
-- https://perfetto.dev/docs/analysis/trace-processor#tracks for a more
-- detailed explanation, with examples.
CREATE PERFETTO VIEW track (
  -- Unique identifier for this track. Identical to |track_id|, prefer using
  -- |track_id| instead.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track; can be null for some types of tracks (e.g. thread
  -- tracks).
  name STRING,
  -- The classification of a track indicates the "type of data" the track
  -- contains.
  --
  -- Every track is uniquely identified by the the combination of the
  -- classification and a set of dimensions: classifications allow identifying
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- a set of tracks with the same type of data within the whole universe of
  -- tracks while dimensions allow distinguishing between different tracks in
  -- that set.
  classification STRING,
  -- The dimensions of the track which uniquely identify the track within a
  -- given classification.
  --
  -- Join with the `args` table or use the `EXTRACT_ARG` helper function to
  -- expand the args.
  dimension_arg_set_id ARGSETID,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Generic key-value pairs containing extra information about the track.
  --
  -- Join with the `args` table or use the `EXTRACT_ARG` helper function to
  -- expand the args.
  source_arg_set_id ARGSETID,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG
) AS
SELECT
  id,
  type,
  name,
  classification,
  dimension_arg_set_id,
  parent_id,
  source_arg_set_id,
  machine_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM __intrinsic_track;

-- Contains information about the CPUs on the device this trace was taken on.
CREATE PERFETTO VIEW cpu (
  -- Unique identifier for this CPU. Identical to |ucpu|, prefer using |ucpu|
  -- instead.
  id ID,
  -- Unique identifier for this CPU. Isn't equal to |cpu| for remote machines
  -- and is equal to |cpu| for the host machine.
  ucpu ID,
  -- The 0-based CPU core identifier.
  cpu LONG,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The cluster id is shared by CPUs in the same cluster.
  cluster_id LONG,
  -- A string describing this core.
  processor STRING,
  -- Machine identifier, non-null for CPUs on a remote machine.
  machine_id LONG,
  -- Capacity of a CPU of a device, a metric which indicates the
  -- relative performance of a CPU on a device
  -- For details see:
  -- https://www.kernel.org/doc/Documentation/devicetree/bindings/arm/cpu-capacity.txt
  capacity LONG,
  -- Extra key/value pairs associated with this cpu.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_set_id ARGSETID
) AS
SELECT
  id,
  id AS ucpu,
  cpu,
  type AS type,
  cluster_id,
  processor,
  machine_id,
  capacity,
  arg_set_id
FROM
  __intrinsic_cpu
WHERE
  cpu IS NOT NULL;

-- Contains the frequency values that the CPUs on the device are capable of
-- running at.
CREATE PERFETTO VIEW cpu_available_frequencies (
  -- Unique identifier for this cpu frequency.
  id ID,
  -- The CPU for this frequency, meaningful only in single machine traces.
  -- For multi-machine, join with the `cpu` table on `ucpu` to get the CPU
  -- identifier of each machine.
  cpu LONG,
  -- CPU frequency in KHz.
  freq LONG,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  ucpu LONG
) AS
SELECT
  id,
  ucpu AS cpu,
  freq,
  ucpu
FROM
  __intrinsic_cpu_freq;

-- This table holds slices with kernel thread scheduling information. These
-- slices are collected when the Linux "ftrace" data source is used with the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- "sched/switch" and "sched/wakeup*" events enabled.
--
-- The rows in this table will always have a matching row in the |thread_state|
-- table with |thread_state.state| = 'Running'
CREATE PERFETTO VIEW sched_slice (
  --  Unique identifier for this scheduling slice.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu LONG,
  -- The thread's unique id in the trace.
  utid JOINID(thread.id),
  -- A string representing the scheduling state of the kernel
  -- thread at the end of the slice.  The individual characters in
  -- the string mean the following: R (runnable), S (awaiting a
  -- wakeup), D (in an uninterruptible sleep), T (suspended),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- t (being traced), X (exiting), P (parked), W (waking),
  -- I (idle), N (not contributing to the load average),
  -- K (wakeable on fatal signals) and Z (zombie, awaiting
  -- cleanup).
  end_state STRING,
  -- The kernel priority that the thread ran at.
  priority LONG,
  -- The unique CPU identifier that the slice executed on.
  ucpu LONG
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  end_state,
  priority,
  ucpu
FROM
  __intrinsic_sched_slice;

-- Shorter alias for table `sched_slice`.
CREATE PERFETTO VIEW sched(
  -- Alias for `sched_slice.id`.
  id ID,
  -- Alias for `sched_slice.type`.
  type STRING,
  -- Alias for `sched_slice.ts`.
  ts TIMESTAMP,
  -- Alias for `sched_slice.dur`.
  dur DURATION,
  -- Alias for `sched_slice.cpu`.
  cpu LONG,
  -- Alias for `sched_slice.utid`.
  utid JOINID(thread.id),
  -- Alias for `sched_slice.end_state`.
  end_state STRING,
  -- Alias for `sched_slice.priority`.
  priority LONG,
  -- Alias for `sched_slice.ucpu`.
  ucpu LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Legacy column, should no longer be used.
  ts_end LONG
) AS
SELECT *, ts + dur as ts_end
FROM sched_slice;

-- This table contains the scheduling state of every thread on the system during
-- the trace.
--
-- The rows in this table which have |state| = 'Running', will have a
-- corresponding row in the |sched_slice| table.
CREATE PERFETTO VIEW thread_state (
  -- Unique identifier for this thread state.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The CPU that the thread executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu LONG,
  -- The thread's unique id in the trace.
  utid JOINID(thread.id),
  -- The scheduling state of the thread. Can be "Running" or any of the states
  -- described in |sched_slice.end_state|.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  state STRING,
  -- Indicates whether this thread was blocked on IO.
  io_wait LONG,
  -- The function in the kernel this thread was blocked on.
  blocked_function STRING,
  -- The unique thread id of the thread which caused a wakeup of this thread.
  waker_utid JOINID(thread.id),
  -- The unique thread state id which caused a wakeup of this thread.
  waker_id JOINID(thread_state.id),
  -- Whether the wakeup was from interrupt context or process context.
  irq_context LONG,
  -- The unique CPU identifier that the thread executed on.
  ucpu LONG
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  state,
  io_wait,
  blocked_function,
  waker_utid,
  waker_id,
  irq_context,
  ucpu
FROM
  __intrinsic_thread_state;

-- Contains 'raw' events from the trace for some types of events. This table
-- only exists for debugging purposes and should not be relied on in production
-- usecases (i.e. metrics, standard library etc.)
CREATE PERFETTO VIEW raw (
  -- Unique identifier for this raw event.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp of this event.
  ts TIMESTAMP,
  -- The name of the event. For ftrace events, this will be the ftrace event
  -- name.
  name STRING,
  -- The CPU this event was emitted on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu LONG,
  -- The thread this event was emitted on.
  utid JOINID(thread.id),
  -- The set of key/value pairs associated with this event.
  arg_set_id ARGSETID,
  -- Ftrace event flags for this event. Currently only emitted for sched_waking
  -- events.
  common_flags LONG,
  -- The unique CPU identifier that this event was emitted on.
  ucpu LONG
) AS
SELECT
  id,
  type,
  ts,
  name,
  ucpu AS cpu,
  utid,
  arg_set_id,
  common_flags,
  ucpu
FROM
  __intrinsic_raw;

-- Contains all the ftrace events in the trace. This table exists only for
-- debugging purposes and should not be relied on in production usecases (i.e.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- metrics, standard library etc). Note also that this table might be empty if
-- raw ftrace parsing has been disabled.
CREATE PERFETTO VIEW ftrace_event (
  -- Unique identifier for this ftrace event.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp of this event.
  ts TIMESTAMP,
  -- The ftrace event name.
  name STRING,
  -- The CPU this event was emitted on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu LONG,
  -- The thread this event was emitted on.
  utid JOINID(thread.id),
  -- The set of key/value pairs associated with this event.
  arg_set_id ARGSETID,
  -- Ftrace event flags for this event. Currently only emitted for
  -- sched_waking events.
  common_flags LONG,
  -- The unique CPU identifier that this event was emitted on.
  ucpu LONG
) AS
SELECT
  id,
  type,
  ts,
  name,
  ucpu AS cpu,
  utid,
  arg_set_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  common_flags,
  ucpu
FROM
  __intrinsic_ftrace_event;

-- The sched_slice table with the upid column.
CREATE PERFETTO VIEW experimental_sched_upid (
  -- Unique identifier for this scheduling slice.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The CPU that the slice executed on (meaningful only in single machine
  -- traces). For multi-machine, join with the `cpu` table on `ucpu` to get the
  -- CPU identifier of each machine.
  cpu LONG,
  -- The thread's unique id in the trace.
  utid JOINID(thread.id),
  -- A string representing the scheduling state of the kernel thread at the end
  -- of the slice. The individual characters in the string mean the following: R
  -- (runnable), S (awaiting a wakeup), D (in an uninterruptible sleep), T
  -- (suspended), t (being traced), X (exiting), P (parked), W (waking), I
  -- (idle), N (not contributing to the load average), K (wakeable on fatal
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- signals) and Z (zombie, awaiting cleanup).
  end_state STRING,
  -- The kernel priority that the thread ran at.
  priority LONG,
  -- The unique CPU identifier that the slice executed on.
  ucpu LONG,
  -- The process's unique id in the trace.
  upid JOINID(process.id)
) AS
SELECT
  id,
  type,
  ts,
  dur,
  ucpu AS cpu,
  utid,
  end_state,
  priority,
  ucpu,
  upid
FROM
  __intrinsic_sched_upid;

-- Tracks which are associated to a single CPU.
CREATE PERFETTO VIEW cpu_track (
  -- Unique identifier for this cpu track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id LONG,
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id ARGSETID,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The CPU that the track is associated with.
  cpu LONG
) AS
SELECT
  id,
  type,
  name,
  parent_id,
  source_arg_set_id,
  machine_id,
  cpu
FROM
  __intrinsic_cpu_track;

-- Tracks containing counter-like events.
CREATE PERFETTO VIEW counter_track (
  -- Unique identifier for this cpu counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- The classification of a track indicates the "type of data" the track
  -- contains.
  --
  -- Every track is uniquely identified by the the combination of the
  -- classification and a set of dimensions: classifications allow identifying
  -- a set of tracks with the same type of data within the whole universe of
  -- tracks while dimensions allow distinguishing between different tracks in
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- that set.
  classification STRING,
  -- The dimensions of the track which uniquely identify the track within a
  -- given classification.
  dimension_arg_set_id ARGSETID,
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id ARGSETID,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING
) AS
SELECT
  id,
  type,
  name,
  NULL AS parent_id,
  classification,
  dimension_arg_set_id,
  source_arg_set_id,
  machine_id,
  counter_unit AS unit,
  EXTRACT_ARG(source_arg_set_id, 'description') AS description
FROM __intrinsic_track
WHERE event_type = 'counter';

-- Tracks containing counter-like events associated to a CPU.
CREATE PERFETTO TABLE cpu_counter_track (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Unique identifier for this cpu counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id ARGSETID,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING,
  -- The CPU that the track is associated with.
  cpu LONG
) AS
SELECT
  ct.id,
  ct.type,
  ct.name,
  ct.parent_id,
  ct.source_arg_set_id,
  ct.machine_id,
  ct.unit,
  ct.description,
  args.int_value as cpu
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM counter_track AS ct
JOIN args ON ct.dimension_arg_set_id = args.arg_set_id
WHERE args.key = 'cpu';

-- Tracks containing counter-like events associated to a GPU.
CREATE PERFETTO TABLE gpu_counter_track (
  -- Unique identifier for this gpu counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id LONG,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The GPU that the track is associated with.
  gpu_id LONG
) AS
SELECT
  ct.id,
  ct.type,
  ct.name,
  ct.parent_id,
  ct.source_arg_set_id,
  ct.machine_id,
  ct.unit,
  ct.description,
  args.int_value AS gpu_id
FROM counter_track AS ct
JOIN args ON ct.dimension_arg_set_id = args.arg_set_id
WHERE args.key = 'gpu';

-- Tracks containing counter-like events associated to a process.
CREATE PERFETTO TABLE process_counter_track (
  -- Unique identifier for this process counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id LONG,
  -- Machine identifier, non-null for tracks on a remote machine.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING,
  -- The upid of the process that the track is associated with.
  upid LONG
) AS
SELECT
  ct.id,
  ct.type,
  ct.name,
  ct.parent_id,
  ct.source_arg_set_id,
  ct.machine_id,
  ct.unit,
  ct.description,
  args.int_value AS upid
FROM counter_track AS ct
JOIN args ON ct.dimension_arg_set_id = args.arg_set_id
WHERE args.key = 'upid';

-- Tracks containing counter-like events associated to a thread.
CREATE PERFETTO TABLE thread_counter_track (
  -- Unique identifier for this thread counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Args for this track which store information about "source" of this track in
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id LONG,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING,
  -- The utid of the thread that the track is associated with.
  utid LONG
) AS
SELECT
  ct.id,
  ct.type,
  ct.name,
  ct.parent_id,
  ct.source_arg_set_id,
  ct.machine_id,
  ct.unit,
  ct.description,
  args.int_value AS utid
FROM counter_track AS ct
JOIN args ON ct.dimension_arg_set_id = args.arg_set_id
WHERE args.key = 'utid';

-- Tracks containing counter-like events collected from Linux perf.
CREATE PERFETTO TABLE perf_counter_track (
  -- Unique identifier for this thread counter track.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Name of the track.
  name STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The track which is the "parent" of this track. Only non-null for tracks
  -- created using Perfetto's track_event API.
  parent_id JOINID(track.id),
  -- Args for this track which store information about "source" of this track in
  -- the trace. For example: whether this track orginated from atrace, Chrome
  -- tracepoints etc.
  source_arg_set_id LONG,
  -- Machine identifier, non-null for tracks on a remote machine.
  machine_id LONG,
  -- The units of the counter. This column is rarely filled.
  unit STRING,
  -- The description for this track. For debugging purposes only.
  description STRING,
  -- The id of the perf session this counter was captured on.
  perf_session_id LONG,
  -- The CPU the counter is associated with.
  cpu LONG,
  -- Whether this counter is the sampling timebase for the session.
  is_timebase BOOL
) AS
SELECT
  ct.id,
  ct.type,
  ct.name,
  ct.parent_id,
  ct.source_arg_set_id,
  ct.machine_id,
  ct.unit,
  ct.description,
  extract_arg(ct.dimension_arg_set_id, 'perf_session_id') AS perf_session_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  extract_arg(ct.dimension_arg_set_id, 'cpu') AS cpu,
  extract_arg(ct.source_arg_set_id, 'is_timebase') AS is_timebase
FROM counter_track AS ct
WHERE ct.classification = 'perf_counter';

-- Alias of the `counter` table.
CREATE PERFETTO VIEW counters(
  -- Alias of `counter.id`.
  id ID,
  -- Alias of `counter.type`.
  type STRING,
  -- Alias of `counter.ts`.
  ts TIMESTAMP,
  -- Alias of `counter.track_id`.
  track_id JOINID(track.id),
  -- Alias of `counter.value`.
  value DOUBLE,
  -- Alias of `counter.arg_set_id`.
  arg_set_id LONG,
  -- Legacy column, should no longer be used.
  name STRING,
  -- Legacy column, should no longer be used.
  unit STRING
) AS
SELECT v.*, t.name, t.unit
FROM counter v
JOIN counter_track t ON v.track_id = t.id
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kPreludeAfterEofViews[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE prelude.after_eof.casts;

-- Counters are values put into tracks during parsing of the trace.
CREATE PERFETTO VIEW counter(
  -- Unique id of a counter value
  id ID,
  -- Time of fetching the counter value.
  ts TIMESTAMP,
  -- Track this counter value belongs to.
  track_id JOINID(track.id),
  -- Value.
  value DOUBLE,
  -- Additional information about the counter value.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  arg_set_id ARGSETID,
  -- Legacy column, should no longer be used.
  type STRING
) AS
SELECT
  id,
  ts,
  track_id,
  value,
  arg_set_id,
  type
FROM __intrinsic_counter;

-- Contains slices from userspace which explains what threads were doing
-- during the trace.
CREATE PERFETTO VIEW slice(
  -- The id of the slice.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The timestamp at the start of the slice.
  ts TIMESTAMP,
  -- The duration of the slice.
  dur DURATION,
  -- The id of the track this slice is located on.
  track_id JOINID(track.id),
  -- The "category" of the slice. If this slice originated with track_event,
  -- this column contains the category emitted.
  -- Otherwise, it is likely to be null (with limited exceptions).
  category STRING,
  -- The name of the slice. The name describes what was happening during the
  -- slice.
  name STRING,
  -- The depth of the slice in the current stack of slices.
  depth LONG,
  -- A unique identifier obtained from the names of all slices in this stack.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- This is rarely useful and kept around only for legacy reasons.
  stack_id LONG,
  -- The stack_id for the parent of this slice. Rarely useful.
  parent_stack_id LONG,
  -- The id of the parent (i.e. immediate ancestor) slice for this slice.
  parent_id JOINID(slice.id),
  -- The id of the argument set associated with this slice.
  arg_set_id ARGSETID,
  -- The thread timestamp at the start of the slice. This columnwill only be
  -- populated if thread timestamp collection is enabled with track_event.
  thread_ts TIMESTAMP,
  -- The thread time used by this slice. This column will only be populated if
  -- thread timestamp collection is enabled with track_event.
  thread_dur DURATION,
  -- The value of the CPU instruction counter at the start of the slice. This
  -- column will only be populated if thread instruction collection is enabled
  -- with track_event.
  thread_instruction_count LONG,
  -- The change in value of the CPU instruction counter between the start and
  -- end of the slice. This column will only be populated if thread instruction
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- collection is enabled with track_event.
  thread_instruction_delta LONG,
  -- Alias of `category`.
  cat STRING,
  -- Alias of `id`.
  slice_id JOINID(slice.id)
) AS
SELECT *, category AS cat, id AS slice_id
FROM __intrinsic_slice;

-- Contains instant events from userspace which indicates what happened at a
-- single moment in time.
CREATE PERFETTO VIEW instant(
  -- The timestamp of the instant.
  ts TIMESTAMP,
  -- The id of the track this instant is located on.
  track_id JOINID(track.id),
  -- The name of the instant. The name describes what happened during the
  -- instant.
  name STRING,
  -- The id of the argument set associated with this instant.
  arg_set_id ARGSETID
) AS
SELECT ts, track_id, name, arg_set_id
FROM slice
WHERE dur = 0;

-- Alternative alias of table `slice`.
CREATE PERFETTO VIEW slices(
  -- Alias of `slice.id`.
  id JOINID(slice.id),
  -- Alias of `slice.type`.
  type STRING,
  -- Alias of `slice.ts`.
  ts TIMESTAMP,
  -- Alias of `slice.dur`.
  dur DURATION,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Alias of `slice.track_id`.
  track_id JOINID(track.id),
  -- Alias of `slice.category`.
  category STRING,
  -- Alias of `slice.name`.
  name STRING,
  -- Alias of `slice.depth`.
  depth LONG,
  -- Alias of `slice.stack_id`.
  stack_id LONG,
  -- Alias of `slice.parent_stack_id`.
  parent_stack_id LONG,
  -- Alias of `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias of `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias of `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias of `slice.thread_dur`.
  thread_dur DURATION,
  -- Alias of `slice.thread_instruction_count`.
  thread_instruction_count LONG,
  -- Alias of `slice.thread_instruction_delta`.
  thread_instruction_delta LONG,
  -- Alias of `slice.cat`.
  cat STRING,
  -- Alias of `slice.slice_id`.
  slice_id JOINID(slice.id)
) AS
SELECT * FROM slice;

-- Contains information of threads seen during the trace.
CREATE PERFETTO VIEW thread(
  -- The id of the thread. Prefer using `utid` instead.
  id ID,
  -- The name of the "most-specific" child table containing this row.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  type STRING,
  -- Unique thread id. This is != the OS tid. This is a monotonic number
  -- associated to each thread. The OS thread id (tid) cannot be used as primary
  -- key because tids and pids are recycled by most kernels.
  utid ID,
  -- The OS id for this thread. Note: this is *not* unique over the lifetime of
  -- the trace so cannot be used as a primary key. Use |utid| instead.
  tid LONG,
  -- The name of the thread. Can be populated from many sources (e.g. ftrace,
  -- /proc scraping, track event etc).
  name STRING,
  -- The start timestamp of this thread (if known). Is null in most cases unless
  -- a thread creation event is enabled (e.g. task_newtask ftrace event on
  -- Linux/Android).
  start_ts TIMESTAMP,
  -- The end timestamp of this thread (if known). Is null in most cases unless
  -- a thread destruction event is enabled (e.g. sched_process_free ftrace event
  -- on Linux/Android).
  end_ts TIMESTAMP,
  -- The process hosting this thread.
  upid JOINID(process.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Boolean indicating if this thread is the main thread in the process.
  is_main_thread BOOL,
  -- Machine identifier, non-null for threads on a remote machine.
  machine_id LONG
) AS
SELECT id as utid, *
FROM __intrinsic_thread;

-- Contains information of processes seen during the trace.
CREATE PERFETTO VIEW process(
  -- The id of the process. Prefer using `upid` instead.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- Unique process id. This is != the OS pid. This is a monotonic number
  -- associated to each process. The OS process id (pid) cannot be used as
  -- primary key because tids and pids are recycled by most kernels.
  upid JOINID(process.id),
  -- The OS id for this process. Note: this is *not* unique over the lifetime of
  -- the trace so cannot be used as a primary key. Use |upid| instead.
  pid LONG,
  -- The name of the process. Can be populated from many sources (e.g. ftrace,
  -- /proc scraping, track event etc).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  name STRING,
  -- The start timestamp of this process (if known). Is null in most cases
  -- unless a process creation event is enabled (e.g. task_newtask ftrace event
  -- on Linux/Android).
  start_ts TIMESTAMP,
  -- The end timestamp of this process (if known). Is null in most cases unless
  -- a process destruction event is enabled (e.g. sched_process_free ftrace
  -- event on Linux/Android).
  end_ts TIMESTAMP,
  -- The upid of the process which caused this process to be spawned.
  parent_upid JOINID(process.id),
  -- The Unix user id of the process.
  uid LONG,
  -- Android appid of this process.
  android_appid LONG,
  -- /proc/cmdline for this process.
  cmdline STRING,
  -- Extra args for this process.
  arg_set_id ARGSETID,
  -- Machine identifier, non-null for processes on a remote machine.
  machine_id LONG
) AS
SELECT id as upid, *
FROM __intrinsic_process;

-- Arbitrary key-value pairs which allow adding metadata to other, strongly
-- typed tables.
-- Note: for a given row, only one of |int_value|, |string_value|, |real_value|
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- will be non-null.
CREATE PERFETTO VIEW args(
  -- The id of the arg.
  id ID,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The id for a single set of arguments.
  arg_set_id ARGSETID,
  -- The "flat key" of the arg: this is the key without any array indexes.
  flat_key STRING,
  -- The key for the arg.
  key STRING,
  -- The integer value of the arg.
  int_value LONG,
  -- The string value of the arg.
  string_value STRING,
  -- The double value of the arg.
  real_value DOUBLE,
  -- The type of the value of the arg. Will be one of 'int', 'uint', 'string',
  -- 'real', 'pointer', 'bool' or 'json'.
  value_type STRING,
  -- The human-readable formatted value of the arg.
  display_value STRING
) AS
SELECT
  *,
  -- This should be kept in sync with GlobalArgsTracker::AddArgSet.
  CASE value_type
    WHEN 'int' THEN cast_string!(int_value)
    WHEN 'uint' THEN cast_string!(int_value)
    WHEN 'string' THEN string_value
    WHEN 'real' THEN cast_string!(real_value)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN 'pointer' THEN printf('0x%x', int_value)
    WHEN 'bool' THEN (
      CASE WHEN int_value <> 0 THEN 'true'
      ELSE 'false' END)
    WHEN 'json' THEN string_value
  ELSE NULL END AS display_value
FROM __intrinsic_args;

-- Contains the Linux perf sessions in the trace.
CREATE PERFETTO VIEW perf_session(
  -- The id of the perf session. Prefer using `perf_session_id` instead.
  id LONG,
  -- The name of the "most-specific" child table containing this row.
  type STRING,
  -- The id of the perf session.
  perf_session_id LONG,
  -- Command line used to collect the data.
  cmdline STRING
)
AS
SELECT *, id AS perf_session_id
FROM __intrinsic_perf_session;

)_d3l1m1t3r_"
;

const char kPreludeBeforeEofTables[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Lists all metrics built-into trace processor.
CREATE TABLE _trace_metrics(
  -- The name of the metric.
  name STRING
);

-- Helper table to generate a time-interval.
CREATE VIRTUAL TABLE window USING window();

)_d3l1m1t3r_"
;

const char kPreludeBeforeEofTraceBounds[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- The values are being filled by Trace Processor when parsing the trace.
-- Exposed with `trace_bounds`.
CREATE TABLE _trace_bounds AS
SELECT 0 AS start_ts, 0 AS end_ts;

-- Fetch start of the trace.
CREATE PERFETTO FUNCTION trace_start()
-- Start of the trace.
RETURNS TIMESTAMP AS
SELECT start_ts FROM _trace_bounds;

-- Fetch end of the trace.
CREATE PERFETTO FUNCTION trace_end()
-- End of the trace.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS TIMESTAMP AS
SELECT end_ts FROM _trace_bounds;

-- Fetch duration of the trace.
CREATE PERFETTO FUNCTION trace_dur()
-- Duration of the trace.
RETURNS DURATION AS
SELECT trace_end() - trace_start();
)_d3l1m1t3r_"
;

const char kSchedLatency[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE sched.runnable;

CREATE PERFETTO VIEW _sched_with_thread_state_join AS
SELECT
    thread_state.id AS thread_state_id,
    sched.id AS sched_id
FROM sched
JOIN thread_state USING (utid, ts, dur);

-- Scheduling latency of running thread states.
-- For each time the thread was running, returns the duration of the runnable
-- state directly before.
CREATE PERFETTO TABLE sched_latency_for_running_interval(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Running state of the thread.
    thread_state_id JOINID(thread_state.id),
    -- Id of a corresponding slice in a `sched` table.
    sched_id JOINID(sched.id),
    -- Thread with running state.
    utid JOINID(thread.id),
    -- Runnable state before thread is "running". Duration of this thread state
    -- is `latency_dur`. One of `thread_state.id`.
    runnable_latency_id JOINID(thread_state.id),
    -- Scheduling latency of thread state. Duration of thread state with
    -- `runnable_latency_id`.
    latency_dur LONG
) AS
SELECT
    r.id AS thread_state_id,
    sched_id,
    utid,
    prev_runnable_id AS runnable_latency_id,
    dur AS latency_dur
FROM sched_previous_runnable_on_thread r
JOIN thread_state prev_ts ON prev_runnable_id = prev_ts.id
JOIN _sched_with_thread_state_join ON thread_state_id = r.id


)_d3l1m1t3r_"
;

const char kSchedRunnable[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

-- Previous runnable slice on the same thread.
-- For each "Running" thread state finds:
-- - previous "Runnable" (or runnable preempted) state.
-- - previous uninterrupted "Runnable" state with a valid waker thread.
CREATE PERFETTO TABLE sched_previous_runnable_on_thread(
    -- Running thread state
    id JOINID(thread_state.id),
    -- Previous runnable thread state.
    prev_runnable_id JOINID(thread_state.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Previous runnable thread state with valid waker thread.
    prev_wakeup_runnable_id JOINID(thread_state.id)
) AS
WITH running_and_runnable AS (
  SELECT
        id,
        state,
        MAX(id)
          FILTER (WHERE state != 'Running')
          OVER utid_part AS prev_runnable_id,
        MAX(id)
          FILTER (WHERE
            waker_utid IS NOT NULL
            AND (irq_context IS NULL OR irq_context != 1))
          OVER utid_part AS prev_wakeup_runnable_id
    FROM thread_state
    -- Optimal operation for state IN (R, R+, Running)
    WHERE state GLOB 'R*' AND dur != -1
    WINDOW utid_part AS (PARTITION BY utid ORDER BY id)
)
SELECT
  id,
  prev_runnable_id,
  prev_wakeup_runnable_id
FROM running_and_runnable
WHERE state = 'Running'
ORDER BY id;
)_d3l1m1t3r_"
;

const char kSchedStates[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- TODO(altimin): `sched_humanly_readable_name` doesn't handle some corner
-- cases which thread_state.ts handles (as complex strings manipulations in
-- SQL are pretty painful), but they are pretty niche.

-- Translates a single-letter scheduling state to a human-readable string.
CREATE PERFETTO FUNCTION sched_state_to_human_readable_string(
  -- An individual character string representing the scheduling state of the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- kernel thread at the end of the slice.
  short_name STRING
)
-- Humanly readable string representing the scheduling state of the kernel
-- thread. The individual characters in the string mean the following: R
-- (runnable), S (awaiting a wakeup), D (in an uninterruptible sleep), T
-- (suspended), t (being traced), X (exiting), P (parked), W (waking), I
-- (idle), N (not contributing to the load average), K (wakeable on fatal
-- signals) and Z (zombie, awaiting cleanup).
RETURNS STRING AS
SELECT CASE $short_name
WHEN 'Running' THEN 'Running'
WHEN 'R' THEN 'Runnable'
WHEN 'R+' THEN 'Runnable (Preempted)'
WHEN 'S' THEN 'Sleeping'
WHEN 'D' THEN 'Uninterruptible Sleep'
WHEN 'T' THEN 'Stopped'
WHEN 't' THEN 'Traced'
WHEN 'X' THEN 'Exit (Dead)'
WHEN 'Z' THEN 'Exit (Zombie)'
WHEN 'x' THEN 'Task Dead'
WHEN 'I' THEN 'Idle'
WHEN 'K' THEN 'Wakekill'
WHEN 'W' THEN 'Waking'
WHEN 'P' THEN 'Parked'
WHEN 'N' THEN 'No Load'
-- ETW SPECIFIC STATES
WHEN 'Stand By' THEN 'Stand By'
WHEN 'Initialized' THEN 'Initialized'
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHEN 'Waiting' THEN 'Waiting'
WHEN 'Transition' THEN 'Transition'
WHEN 'Deferred Ready' THEN 'Deferred Ready'
ELSE $short_name
END;

-- Translates a single-letter scheduling state and IO wait information to
-- a human-readable string.
CREATE PERFETTO FUNCTION sched_state_io_to_human_readable_string(
  -- An individual character string representing the scheduling state of the
  -- kernel thread at the end of the slice.
  sched_state STRING,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL
)
-- A human readable string with information about the scheduling state and IO wait.
RETURNS STRING AS
SELECT printf(
  '%s%s',
  sched_state_to_human_readable_string($sched_state),
  CASE $io_wait
    WHEN 1 THEN ' (IO)'
    WHEN 0 THEN ' (non-IO)'
    ELSE ''
  END
);

)_d3l1m1t3r_"
;

const char kSchedThreadExecutingSpan[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE graphs.critical_path;
INCLUDE PERFETTO MODULE graphs.search;
INCLUDE PERFETTO MODULE intervals.overlap;
INCLUDE PERFETTO MODULE intervals.intersect;

-- A 'thread_executing_span' is thread_state span starting with a runnable slice
-- until the next runnable slice that's woken up by a process (as opposed
-- to an interrupt). Note that within a 'thread_executing_span' we can have sleep
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- spans blocked on an interrupt.
-- We consider the id of this span to be the id of the first thread_state in the span.

--
-- Finds all runnable states that are woken up by a process.
--
-- We achieve this by checking that the |thread_state.irq_context|
-- value is NOT 1. In otherwords, it is either 0 or NULL. The NULL check
-- is important to support older Android versions.
--
-- On older versions of Android (<U). We don't have IRQ context information,
-- so this table might contain wakeups from interrupt context, consequently, the
-- wakeup graph generated might not be accurate.
--
CREATE PERFETTO TABLE _runnable_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_id,
  thread_state.waker_utid,
  IIF(thread_state.irq_context = 0 OR thread_state.irq_context IS NULL,
      IFNULL(thread_state.io_wait, 0), 1) AS is_irq
FROM thread_state
WHERE
  thread_state.dur != -1
  AND thread_state.waker_id IS NOT NULL;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Similar to |_runnable_state| but finds the first runnable state at thread.
CREATE PERFETTO TABLE _first_runnable_state
AS
WITH
  first_state AS (
    SELECT
      MIN(thread_state.id) AS id
    FROM thread_state
    GROUP BY utid
  )
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.utid,
  thread_state.waker_id,
  thread_state.waker_utid,
  IIF(thread_state.irq_context = 0 OR thread_state.irq_context IS NULL,
      IFNULL(thread_state.io_wait, 0), 1) AS is_irq
FROM thread_state
JOIN first_state
  USING (id)
WHERE
  thread_state.dur != -1
  AND thread_state.state = 'R';

--
-- Finds all sleep states including interruptible (S) and uninterruptible (D).
CREATE PERFETTO TABLE _sleep_state
AS
SELECT
  thread_state.id,
  thread_state.ts,
  thread_state.dur,
  thread_state.state,
  thread_state.blocked_function,
  thread_state.utid
FROM thread_state
WHERE dur != -1 AND (state = 'S' OR state = 'D' OR state = 'I');

--
-- Finds the last execution for every thread to end executing_spans without a Sleep.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
CREATE PERFETTO TABLE _thread_end_ts
AS
SELECT
  MAX(ts) + dur AS end_ts,
  utid
FROM thread_state
WHERE dur != -1
GROUP BY utid;

-- Similar to |_sleep_state| but finds the first sleep state in a thread.
CREATE PERFETTO TABLE _first_sleep_state
AS
SELECT
  MIN(s.id) AS id,
  s.ts,
  s.dur,
  s.state,
  s.blocked_function,
  s.utid
FROM _sleep_state s
JOIN _runnable_state r
  ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
GROUP BY s.utid;

--
-- Finds all neighbouring ('Sleeping', 'Runnable') thread_states pairs from the same thread.
-- More succintly, pairs of S[n-1]-R[n] where R is woken by a process context and S is an
-- interruptible or uninterruptible sleep state.
--
-- This is achieved by joining the |_runnable_state|.ts with the
-- |_sleep_state|.|ts + dur|.
--
-- With the S-R pairs of a thread, we can re-align to [R-S) intervals with LEADS and LAGS.
--
-- Given the following thread_states on a thread:
-- S0__|R0__Running0___|S1__|R1__Running1___|S2__|R2__Running2__S2|.
--
-- We have 3 thread_executing_spans: [R0, S0), [R1, S1), [R2, S2).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--
-- We define the following markers in this table:
--
-- prev_id          = R0_id.
--
-- prev_end_ts      = S0_ts.
-- state            = 'S' or 'D'.
-- blocked_function = <kernel blocking function>
--
-- id               = R1_id.
-- ts               = R1_ts.
--
-- end_ts           = S1_ts.
CREATE PERFETTO TABLE _wakeup
AS
WITH
  all_wakeups AS (
    SELECT
      s.state,
      s.blocked_function,
      r.id,
      r.ts AS ts,
      r.utid AS utid,
      r.waker_id,
      r.waker_utid,
      s.ts AS prev_end_ts,
      is_irq
    FROM _runnable_state r
    JOIN _sleep_state s
      ON s.utid = r.utid AND (s.ts + s.dur = r.ts)
    UNION ALL
    SELECT
      NULL AS state,
      NULL AS blocked_function,
      r.id,
      r.ts,
      r.utid AS utid,
      r.waker_id,
      r.waker_utid,
      NULL AS prev_end_ts,
      is_irq
    FROM _first_runnable_state r
    LEFT JOIN _first_sleep_state s
      ON s.utid = r.utid
  )
SELECT
  all_wakeups.*, thread_end.end_ts AS thread_end_ts
FROM all_wakeups
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN _thread_end_ts thread_end
  USING (utid);

-- Mapping from running thread state to runnable
-- TODO(zezeozue): Switch to use `sched_previous_runnable_on_thread`.
CREATE PERFETTO TABLE _wakeup_map
AS
WITH x AS (
SELECT id, waker_id, utid, state FROM thread_state WHERE state = 'Running' AND dur != -1
UNION ALL
SELECT id, waker_id, utid, state FROM _first_runnable_state
UNION ALL
SELECT id, waker_id, utid, state FROM _runnable_state
), y AS (
    SELECT
      id AS waker_id,
      state,
      MAX(id)
        filter(WHERE state = 'R')
          OVER (PARTITION BY utid ORDER BY id) AS id
    FROM x
  )
SELECT id, waker_id FROM y WHERE state = 'Running' ORDER BY waker_id;

--
-- Builds the waker and prev relationships for all thread_executing_spans.
--
CREATE PERFETTO TABLE _wakeup_graph
AS
WITH
  _wakeup_events AS (
    SELECT
      utid,
      thread_end_ts,
      IIF(is_irq, 'IRQ', state) AS idle_state,
      blocked_function AS idle_reason,
      _wakeup.id,
      IIF(is_irq, NULL, _wakeup_map.id) AS waker_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      _wakeup.ts,
      prev_end_ts AS idle_ts,
      IIF(is_irq OR _wakeup_map.id IS NULL OR (state IS NOT NULL AND state != 'S'), 1, 0)
        AS is_idle_reason_self
    FROM _wakeup
    LEFT JOIN _wakeup_map
      USING (waker_id)
  )
SELECT
  utid,
  id,
  waker_id,
  ts,
  idle_state,
  idle_reason,
  ts - idle_ts AS idle_dur,
  is_idle_reason_self,
  LAG(id) OVER (PARTITION BY utid ORDER BY ts) AS prev_id,
  LEAD(id) OVER (PARTITION BY utid ORDER BY ts) AS next_id,
  IFNULL(LEAD(idle_ts) OVER (PARTITION BY utid ORDER BY ts), thread_end_ts) - ts AS dur,
  LEAD(is_idle_reason_self) OVER (PARTITION BY utid ORDER BY ts) AS is_next_idle_reason_self
FROM _wakeup_events
ORDER BY id;

-- View of all the edges for the userspace critical path.
CREATE PERFETTO VIEW _wakeup_userspace_edges
AS
SELECT
  id AS source_node_id,
  COALESCE(IIF(is_idle_reason_self, prev_id, waker_id), id) AS dest_node_id,
  id - COALESCE(IIF(is_idle_reason_self, prev_id, waker_id), id) AS edge_weight
FROM _wakeup_graph;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- View of all the edges for the kernel critical path.
CREATE PERFETTO VIEW _wakeup_kernel_edges
AS
SELECT
  id AS source_node_id,
  COALESCE(waker_id, id) AS dest_node_id,
  id - COALESCE(waker_id, id) AS edge_weight
FROM _wakeup_graph;

-- View of the relevant timestamp and intervals for all nodes in the critical path.
CREATE PERFETTO VIEW _wakeup_intervals
AS
SELECT id, ts, dur, idle_dur FROM _wakeup_graph;

-- Converts a table with <ts, dur, utid> columns to a unique set of wakeup roots <id> that
-- completely cover the time intervals.
CREATE PERFETTO MACRO _intervals_to_roots(_source_table TableOrSubQuery,
                                          _node_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
  WITH _interval_to_root_nodes AS (
      SELECT * FROM $_node_table
    ),
    _source AS (
      SELECT * FROM $_source_table
    ),
    _thread_bounds AS (
      SELECT utid, MIN(ts) AS min_start, MAX(ts) AS max_start
      FROM _interval_to_root_nodes
      GROUP BY utid
    ),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    _start AS (
      SELECT
        _interval_to_root_nodes.utid,
        MAX(_interval_to_root_nodes.id) AS _start_id,
        _source.ts,
        _source.dur
      FROM _interval_to_root_nodes
      JOIN _thread_bounds USING (utid)
      JOIN _source
        ON _source.utid = _interval_to_root_nodes.utid
          AND MAX(_source.ts, min_start) >= _interval_to_root_nodes.ts
      GROUP BY _source.ts, _source.utid
    ),
    _end AS (
      SELECT
        _interval_to_root_nodes.utid,
        MIN(_interval_to_root_nodes.id) AS _end_id,
        _source.ts,
        _source.dur
      FROM _interval_to_root_nodes
      JOIN _thread_bounds USING (utid)
      JOIN _source
        ON _source.utid = _interval_to_root_nodes.utid
          AND MIN((_source.ts + _source.dur), max_start) <= _interval_to_root_nodes.ts
      GROUP BY _source.ts, _source.utid
    ),
    _bound AS (
      SELECT _start.utid, _start.ts, _start.dur, _start_id, _end_id
      FROM _start
      JOIN _end
        ON _start.ts = _end.ts AND _start.dur = _end.dur AND _start.utid = _end.utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  SELECT DISTINCT id AS root_node_id, id - COALESCE(prev_id, id) AS capacity
  FROM _bound
  JOIN _interval_to_root_nodes
    ON _interval_to_root_nodes.id BETWEEN _start_id AND _end_id
      AND _interval_to_root_nodes.utid = _bound.utid
);

-- Adjusts the userspace critical path such that any interval that includes a kernel stall
-- gets the next id, the root id of the kernel critical path. This ensures that the merge
-- step associates the userspace critical path and kernel critical path on the same interval
-- correctly.
CREATE PERFETTO MACRO _critical_path_userspace_adjusted(_critical_path_table TableOrSubQuery,
                                                        _node_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
    SELECT
      cr.root_id,
      cr.root_id AS parent_id,
      IIF(node.is_next_idle_reason_self, node.next_id, cr.id) AS id,
      cr.ts,
      cr.dur
    FROM (SELECT * FROM $_critical_path_table) cr
    JOIN $_node_table node
      USING (id)
);

-- Adjusts the start and end of the kernel critical path such that it is completely bounded within
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- its corresponding userspace critical path.
CREATE PERFETTO MACRO _critical_path_kernel_adjusted(_userspace_critical_path_table TableOrSubQuery,
                                                     _kernel_critical_path_table TableOrSubQuery,
                                                     _node_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
    SELECT
      kernel_cr.root_id,
      kernel_cr.root_id AS parent_id,
      kernel_cr.id,
      MAX(kernel_cr.ts, userspace_cr.ts) AS ts,
      MIN(kernel_cr.ts + kernel_cr.dur, userspace_cr.ts + userspace_cr.dur)
        - MAX(kernel_cr.ts, userspace_cr.ts) AS dur
    FROM $_kernel_critical_path_table kernel_cr
    JOIN $_node_table node
      ON kernel_cr.parent_id = node.id
    JOIN $_userspace_critical_path_table userspace_cr
      ON userspace_cr.id = kernel_cr.parent_id AND userspace_cr.root_id = kernel_cr.root_id
);

-- Merge the kernel and userspace critical path such that the corresponding kernel critical path
-- has priority over userpsace critical path it overlaps.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO MACRO _critical_path_merged(_userspace_critical_path_table TableOrSubQuery,
                                            _kernel_critical_path_table TableOrSubQuery,
                                            _node_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
WITH _userspace_critical_path AS (
  SELECT DISTINCT *
  FROM _critical_path_userspace_adjusted!(
    $_userspace_critical_path_table,
    $_node_table)
  ),
  _merged_critical_path AS (
    SELECT * FROM _userspace_critical_path
     UNION ALL
    SELECT DISTINCT *
    FROM _critical_path_kernel_adjusted!(
      _userspace_critical_path,
      $_kernel_critical_path_table,
      $_node_table)
    WHERE id != parent_id
    ),
    _roots_critical_path AS (
      SELECT root_id, MIN(ts) AS root_ts, MAX(ts + dur) - MIN(ts) AS root_dur
      FROM _userspace_critical_path
      GROUP BY root_id
    ),
    _roots_and_merged_critical_path AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        parent_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        id,
        ts,
        dur
      FROM _merged_critical_path
      JOIN _roots_critical_path USING(root_id)
    )
    SELECT
      flat.root_id,
      flat.id,
      flat.ts,
      flat.dur
    FROM
    _intervals_flatten!(_roots_and_merged_critical_path) flat
    WHERE flat.dur > 0
    GROUP BY flat.root_id, flat.ts
);

-- Generates the critical path for only the set of roots <id> passed in.
-- _intervals_to_roots can be used to generate root ids from a given time interval.
-- This can be used to genrate the critical path over sparse regions of a trace, e.g
-- binder transactions. It might be more efficient to generate the _critical_path
-- for the entire trace, see _thread_executing_span_critical_path_all, but for a
-- per-process susbset of binder txns for instance, this is likely faster.
CREATE PERFETTO MACRO _critical_path_by_roots(_roots_table TableOrSubQuery,
                                              _node_table TableOrSubQuery)
RETURNS TableOrSubQuery
AS (
  WITH _userspace_critical_path_by_roots AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT *
    FROM
      _critical_path_intervals
        !(_wakeup_userspace_edges,
          $_roots_table,
          _wakeup_intervals)
  ),
  _kernel_nodes AS (
    SELECT id, root_id FROM _userspace_critical_path_by_roots
    JOIN $_node_table node USING (id) WHERE is_idle_reason_self = 1
  ),
  _kernel_critical_path_by_roots AS (
    SELECT _kernel_nodes.root_id, cr.root_id AS parent_id, cr.id, cr.ts, cr.dur
    FROM
      _critical_path_intervals
        !(_wakeup_kernel_edges,
          (
           SELECT graph.id AS root_node_id, graph.id - COALESCE(graph.prev_id, graph.id) AS capacity
           FROM _kernel_nodes
           JOIN _wakeup_graph graph USING(id)
          ),
          _wakeup_intervals)
          cr
    JOIN _kernel_nodes
      ON _kernel_nodes.id = cr.root_id
  ) SELECT * FROM _critical_path_merged!(
    _userspace_critical_path_by_roots,
    _kernel_critical_path_by_roots,
    $_node_table)
);

-- Generates the critical path for only the time intervals for the utids given.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- Currently expensive because of naive interval_intersect implementation.
-- Prefer _critical_paths_by_roots for performance. This is useful for a small
-- set of intervals, e.g app startups in a trace.
CREATE PERFETTO MACRO _critical_path_by_intervals(_intervals_table TableOrSubQuery,
                                                  _node_table TableOrSubQuery)
RETURNS TableOrSubQuery AS (
  WITH _nodes AS (
    SELECT * FROM $_node_table
  ), _intervals AS (
    SELECT
      ROW_NUMBER() OVER(ORDER BY ts) AS id,
      ts,
      dur,
      utid AS root_utid
    FROM $_intervals_table
  ), _critical_path AS (
    SELECT
      ROW_NUMBER() OVER(ORDER BY ts) AS id,
      root_id,
      id AS cr_id,
      ts,
      dur
    FROM _critical_path_by_roots!(
      _intervals_to_roots!($_intervals_table, $_node_table),
      _nodes)
  ), _span AS (
    SELECT
      _root_nodes.utid AS root_utid,
      _nodes.utid,
      cr.root_id,
      cr.cr_id,
      cr.id,
      cr.ts,
      cr.dur
    FROM _critical_path cr
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    JOIN _nodes _root_nodes ON _root_nodes.id = cr.root_id
    JOIN _nodes ON _nodes.id = cr.cr_id
  ) SELECT DISTINCT
      _span.root_utid,
      _span.utid,
      _span.root_id,
      _span.cr_id AS id,
      ii.ts,
      ii.dur,
      _intervals.ts AS interval_ts,
      _intervals.dur AS interval_dur
    FROM _interval_intersect!((_span, _intervals), (root_utid)) ii
    JOIN _span ON _span.id = ii.id_0
    JOIN _intervals ON _intervals.id = ii.id_1
);

-- Generates the critical path for a given utid over the <ts, dur> interval.
-- The duration of a thread executing span in the critical path is the range between the
-- start of the thread_executing_span and the start of the next span in the critical path.
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path(
  -- Utid of the thread to compute the critical path for.
  root_utid JOINID(thread.id),
  -- Timestamp.
  ts TIMESTAMP,
  -- Duration.
  dur DURATION)
RETURNS TABLE(
  -- Thread Utid the critical path was filtered to.
  root_utid JOINID(thread.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Id of thread executing span following the sleeping thread state for which the critical path is
  -- computed.
  root_id LONG,
  -- Id of the first (runnable) thread state in thread_executing_span.
  id LONG,
  -- Timestamp of first thread_state in thread_executing_span.
  ts TIMESTAMP,
  -- Duration of thread_executing_span.
  dur DURATION,
  -- Utid of thread with thread_state.
  utid JOINID(thread.id)
) AS
SELECT root_utid, root_id, id, ts, dur, utid FROM _critical_path_by_intervals!(
  (SELECT $root_utid AS utid, $ts as ts, $dur AS dur),
  _wakeup_graph);

)_d3l1m1t3r_"
;

const char kSchedThreadExecutingSpanWithSlice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--

INCLUDE PERFETTO MODULE slices.flat_slices;
INCLUDE PERFETTO MODULE sched.thread_executing_span;

CREATE PERFETTO TABLE _critical_path_userspace
AS
SELECT *
FROM
  _critical_path_intervals
    !(_wakeup_userspace_edges,
      (SELECT id AS root_node_id, id - COALESCE(prev_id, id) AS capacity FROM _wakeup_graph),
      _wakeup_intervals);

CREATE PERFETTO TABLE _critical_path_kernel
)_d3l1m1t3r_"
R"_d3l1m1t3r_(AS
WITH _kernel_nodes AS (
  SELECT id, root_id FROM _critical_path_userspace
  JOIN _wakeup_graph USING (id) WHERE is_idle_reason_self = 1
)
SELECT _kernel_nodes.root_id, cr.root_id AS parent_id, cr.id, cr.ts, cr.dur
FROM
  _critical_path_intervals
    !(_wakeup_kernel_edges,
      (
        SELECT graph.id AS root_node_id, graph.id - COALESCE(graph.prev_id, graph.id) AS capacity
        FROM _kernel_nodes
        JOIN _wakeup_graph graph USING(id)
      ),
      _wakeup_intervals) cr
JOIN _kernel_nodes
  ON _kernel_nodes.id = cr.root_id;

CREATE PERFETTO TABLE _critical_path_userspace_adjusted AS
SELECT DISTINCT * FROM _critical_path_userspace_adjusted!(_critical_path_userspace, _wakeup_graph);

CREATE PERFETTO TABLE _critical_path_kernel_adjusted AS
SELECT DISTINCT * FROM _critical_path_kernel_adjusted!(_critical_path_userspace_adjusted, _critical_path_kernel, _wakeup_graph);

CREATE PERFETTO TABLE _critical_path_merged_adjusted AS
  SELECT root_id, parent_id, id, ts, dur FROM _critical_path_userspace_adjusted
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  UNION ALL
  SELECT root_id, parent_id, id, ts, dur FROM _critical_path_kernel_adjusted WHERE id != parent_id;

CREATE PERFETTO TABLE _critical_path_roots AS
  SELECT root_id, min(ts) AS root_ts, max(ts + dur) - min(ts) AS root_dur
  FROM _critical_path_userspace_adjusted
  GROUP BY root_id;

CREATE PERFETTO TABLE _critical_path_roots_and_merged AS
  WITH roots_and_merged_critical_path AS (
      SELECT
        root_id,
        root_ts,
        root_dur,
        parent_id,
        id,
        ts,
        dur
      FROM _critical_path_merged_adjusted
      JOIN _critical_path_roots USING(root_id)
    )
    SELECT
      flat.root_id,
      flat.id,
      flat.ts,
      flat.dur
    FROM
    _intervals_flatten!(roots_and_merged_critical_path) flat
    WHERE flat.dur > 0
    GROUP BY flat.root_id, flat.ts;

CREATE PERFETTO TABLE _critical_path_all
AS
SELECT
  ROW_NUMBER() OVER(ORDER BY cr.ts) AS id,
  cr.ts,
  cr.dur,
  cr.ts + cr.dur AS ts_end,
  id_graph.utid,
  root_id_graph.utid AS root_utid
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  FROM _critical_path_roots_and_merged cr
  JOIN _wakeup_graph id_graph ON cr.id = id_graph.id
  JOIN _wakeup_graph root_id_graph ON cr.root_id = root_id_graph.id ORDER BY cr.ts;

-- Limited thread_state view that will later be span joined with the |_thread_executing_span_graph|.
CREATE PERFETTO VIEW _span_thread_state_view
AS
SELECT id AS thread_state_id, ts, dur, utid, state, blocked_function AS function, io_wait, cpu
FROM thread_state;

-- Limited slice_view that will later be span joined with the critical path.
CREATE PERFETTO VIEW _span_slice_view
AS
SELECT
  slice_id,
  depth AS slice_depth,
  name AS slice_name,
  cast_int!(ts) AS ts,
  cast_int!(dur) AS dur,
  utid
FROM _slice_flattened;

-- thread state span joined with slice.
CREATE VIRTUAL TABLE _span_thread_state_slice_sp
USING
  SPAN_LEFT_JOIN(
    _span_thread_state_view PARTITIONED utid,
    _span_slice_view PARTITIONED utid);

CREATE PERFETTO TABLE _span_thread_state_slice
AS
SELECT
  ROW_NUMBER() OVER(ORDER BY ts) AS id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts,
  dur,
  ts + dur AS ts_end,
  utid,
  thread_state_id,
  state,
  function,
  cpu,
  io_wait,
  slice_id,
  slice_name,
  slice_depth
  FROM _span_thread_state_slice_sp WHERE dur > 0 ORDER BY ts;

CREATE PERFETTO TABLE _critical_path_thread_state_slice_raw
AS
SELECT
  id_0 AS cr_id,
  id_1 AS th_id,
  ts,
  dur
FROM _interval_intersect!((_critical_path_all, _span_thread_state_slice), (utid));

CREATE PERFETTO TABLE _critical_path_thread_state_slice
AS
SELECT
  raw.ts,
  raw.dur,
  cr.utid,
  thread_state_id,
  state,
  function,
  cpu,
  io_wait,
  slice_id,
  slice_name,
  slice_depth,
  root_utid
FROM _critical_path_thread_state_slice_raw raw
JOIN _critical_path_all cr
  ON cr.id = raw.cr_id
JOIN _span_thread_state_slice th
  ON th.id = raw.th_id;

-- Flattened slices span joined with their thread_states. This contains the 'self' information
-- without 'critical_path' (blocking) information.
CREATE VIRTUAL TABLE _self_sp USING
  SPAN_LEFT_JOIN(thread_state PARTITIONED utid, _slice_flattened PARTITIONED utid);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Limited view of |_self_sp|.
CREATE PERFETTO VIEW _self_view
  AS
  SELECT
    id AS self_thread_state_id,
    slice_id AS self_slice_id,
    ts,
    dur,
    utid AS root_utid,
    state AS self_state,
    blocked_function AS self_function,
    cpu AS self_cpu,
    io_wait AS self_io_wait,
    name AS self_slice_name,
    depth AS self_slice_depth
    FROM _self_sp;

-- Self and critical path span join. This contains the union of the time intervals from the following:
--  a. Self slice stack + thread_state.
--  b. Critical path stack + thread_state.
CREATE VIRTUAL TABLE _self_and_critical_path_sp
USING
  SPAN_JOIN(
    _self_view PARTITIONED root_utid,
    _critical_path_thread_state_slice PARTITIONED root_utid);

-- Returns a view of |_self_and_critical_path_sp| unpivoted over the following columns:
-- self thread_state.
-- self blocked_function (if one exists).
-- self process_name (enabled with |enable_process_name|).
-- self thread_name (enabled with |enable_thread_name|).
-- self slice_stack (enabled with |enable_self_slice|).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- critical_path thread_state.
-- critical_path process_name.
-- critical_path thread_name.
-- critical_path slice_stack (enabled with |enable_critical_path_slice|).
-- running cpu (if one exists).
-- A 'stack' is the group of resulting unpivoted rows sharing the same timestamp.
CREATE PERFETTO FUNCTION _critical_path_stack(root_utid JOINID(thread.id), ts TIMESTAMP, dur DURATION, enable_process_name LONG, enable_thread_name LONG, enable_self_slice LONG, enable_critical_path_slice LONG)
RETURNS
  TABLE(
    id LONG,
    ts TIMESTAMP,
    dur DURATION,
    utid JOINID(thread.id),
    stack_depth LONG,
    name STRING,
    table_name STRING,
    root_utid JOINID(thread.id)) AS
  -- Spans filtered to the query time window and root_utid.
  -- This is a preliminary step that gets the start and end ts of all the rows
  -- so that we can chop the ends of each interval correctly if it overlaps with the query time interval.
  WITH relevant_spans_starts AS (
    SELECT
      self_thread_state_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      self_state,
      self_slice_id,
      self_slice_name,
      self_slice_depth,
      self_function,
      self_io_wait,
      thread_state_id,
      state,
      function,
      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      cpu,
      utid,
      MAX(ts, $ts) AS ts,
      MIN(ts + dur, $ts + $dur) AS end_ts,
      root_utid
    FROM _self_and_critical_path_sp
    WHERE dur > 0 AND root_utid = $root_utid
  ),
  -- This is the final step that gets the |dur| of each span from the start and
  -- and end ts of the previous step.
  -- Now we manually unpivot the result with 3 key steps: 1) Self 2) Critical path 3) CPU
  -- This CTE is heavily used throughout the entire function so materializing it is
  -- very important.
  relevant_spans AS MATERIALIZED (
    SELECT
      self_thread_state_id,
      self_state,
      self_slice_id,
      self_slice_name,
      self_slice_depth,
      self_function,
      self_io_wait,
      thread_state_id,
      state,
      function,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      cpu,
      utid,
      ts,
      end_ts - ts AS dur,
      root_utid,
      utid
    FROM relevant_spans_starts
    WHERE dur > 0
  ),
  -- 1. Builds the 'self' stack of items as an ordered UNION ALL
  self_stack AS MATERIALIZED (
    -- Builds the self thread_state
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      root_utid AS utid,
      0 AS stack_depth,
      'thread_state: ' || self_state AS name,
      'thread_state' AS table_name,
      root_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self kernel blocked_function
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      root_utid AS utid,
      1 AS stack_depth,
      IIF(self_state GLOB 'R*', NULL, 'kernel function: ' || self_function) AS name,
      'thread_state' AS table_name,
      root_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self kernel io_wait
    SELECT
      self_thread_state_id AS id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      ts,
      dur,
      root_utid AS utid,
      2 AS stack_depth,
      IIF(self_state GLOB 'R*', NULL, 'io_wait: ' || self_io_wait) AS name,
      'thread_state' AS table_name,
      root_utid
    FROM relevant_spans
    UNION ALL
    -- Builds the self process_name
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      3 AS stack_depth,
      IIF($enable_process_name, 'process_name: ' || process.name, NULL) AS name,
      'thread_state' AS table_name,
      root_utid
    FROM relevant_spans
    LEFT JOIN thread
      ON thread.utid = root_utid
    LEFT JOIN process
      USING (upid)
    -- Builds the self thread_name
    UNION ALL
    SELECT
      self_thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      4 AS stack_depth,
      IIF($enable_thread_name, 'thread_name: ' || thread.name, NULL) AS name,
      'thread_state' AS table_name,
      root_utid
    FROM relevant_spans
    LEFT JOIN thread
      ON thread.utid = root_utid
    JOIN process
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      USING (upid)
    UNION ALL
    -- Builds the self 'ancestor' slice stack
    SELECT
      anc.id,
      slice.ts,
      slice.dur,
      root_utid AS utid,
      anc.depth + 5 AS stack_depth,
      IIF($enable_self_slice, anc.name, NULL) AS name,
      'slice' AS table_name,
      root_utid
    FROM relevant_spans slice
    JOIN ancestor_slice(self_slice_id) anc WHERE anc.dur != -1
    UNION ALL
    -- Builds the self 'deepest' ancestor slice stack
    SELECT
      self_slice_id AS id,
      ts,
      dur,
      root_utid AS utid,
      self_slice_depth + 5 AS stack_depth,
      IIF($enable_self_slice, self_slice_name, NULL) AS name,
      'slice' AS table_name,
      root_utid
    FROM relevant_spans slice
    -- Ordering by stack depth is important to ensure the items can
    -- be renedered in the UI as a debug track in the order in which
    -- the sub-queries were 'unioned'.
    ORDER BY stack_depth
  ),
  -- Prepares for stage 2 in building the entire stack.
  -- Computes the starting depth for each stack. This is necessary because
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- each self slice stack has variable depth and the depth in each stack
  -- most be contiguous in order to efficiently generate a pprof in the future.
  critical_path_start_depth AS MATERIALIZED (
    SELECT root_utid, ts, MAX(stack_depth) + 1 AS start_depth
    FROM self_stack
    GROUP BY root_utid, ts
  ),
  critical_path_span AS MATERIALIZED (
    SELECT
      thread_state_id,
      state,
      function,
      io_wait,
      slice_id,
      slice_name,
      slice_depth,
      spans.ts,
      spans.dur,
      spans.root_utid,
      utid,
      start_depth
    FROM relevant_spans spans
    JOIN critical_path_start_depth
      ON
        critical_path_start_depth.root_utid = spans.root_utid
        AND critical_path_start_depth.ts = spans.ts
    WHERE critical_path_start_depth.root_utid = $root_utid AND spans.root_utid != spans.utid
  ),
  -- 2. Builds the 'critical_path' stack of items as an ordered UNION ALL
  critical_path_stack AS MATERIALIZED (
    -- Builds the critical_path thread_state
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      thread_state_id AS id,
      ts,
      dur,
      utid,
      start_depth AS stack_depth,
      'blocking thread_state: ' || state AS name,
      'thread_state' AS table_name,
      root_utid
    FROM critical_path_span
    UNION ALL
    -- Builds the critical_path process_name
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 1 AS stack_depth,
      'blocking process_name: ' || process.name,
      'thread_state' AS table_name,
      root_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    LEFT JOIN process USING (upid)
    UNION ALL
    -- Builds the critical_path thread_name
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 2 AS stack_depth,
      'blocking thread_name: ' || thread.name,
      'thread_state' AS table_name,
      root_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path kernel blocked_function
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 3 AS stack_depth,
      'blocking kernel_function: ' || function,
      'thread_state' AS table_name,
      root_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path kernel io_wait
    SELECT
      thread_state_id AS id,
      ts,
      dur,
      thread.utid,
      start_depth + 4 AS stack_depth,
      'blocking io_wait: ' || io_wait,
      'thread_state' AS table_name,
      root_utid
    FROM critical_path_span
    JOIN thread USING (utid)
    UNION ALL
    -- Builds the critical_path 'ancestor' slice stack
    SELECT
      anc.id,
      slice.ts,
      slice.dur,
      slice.utid,
      anc.depth + start_depth + 5 AS stack_depth,
      IIF($enable_critical_path_slice, anc.name, NULL) AS name,
      'slice' AS table_name,
      root_utid
    FROM critical_path_span slice
    JOIN ancestor_slice(slice_id) anc WHERE anc.dur != -1
    UNION ALL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- Builds the critical_path 'deepest' slice
    SELECT
      slice_id AS id,
      ts,
      dur,
      utid,
      slice_depth + start_depth + 5 AS stack_depth,
      IIF($enable_critical_path_slice, slice_name, NULL) AS name,
      'slice' AS table_name,
      root_utid
    FROM critical_path_span slice
    -- Ordering is also important as in the 'self' step above.
    ORDER BY stack_depth
  ),
  -- Prepares for stage 3 in building the entire stack.
  -- Computes the starting depth for each stack using the deepest stack_depth between
  -- the critical_path stack and self stack. The self stack depth is
  -- already computed and materialized in |critical_path_start_depth|.
  cpu_start_depth_raw AS (
    SELECT root_utid, ts, MAX(stack_depth) + 1 AS start_depth
    FROM critical_path_stack
    GROUP BY root_utid, ts
    UNION ALL
    SELECT * FROM critical_path_start_depth
  ),
  cpu_start_depth AS (
    SELECT root_utid, ts, MAX(start_depth) AS start_depth
    FROM cpu_start_depth_raw
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    GROUP BY root_utid, ts
  ),
  -- 3. Builds the 'CPU' stack for 'Running' states in either the self or critical path stack.
  cpu_stack AS (
    SELECT
      thread_state_id AS id,
      spans.ts,
      spans.dur,
      utid,
      start_depth AS stack_depth,
      'cpu: ' || cpu AS name,
      'thread_state' AS table_name,
      spans.root_utid
    FROM relevant_spans spans
    JOIN cpu_start_depth
      ON
        cpu_start_depth.root_utid = spans.root_utid
        AND cpu_start_depth.ts = spans.ts
    WHERE cpu_start_depth.root_utid = $root_utid AND state = 'Running' OR self_state = 'Running'
  ),
  merged AS (
    SELECT * FROM self_stack
    UNION ALL
    SELECT * FROM critical_path_stack
    UNION ALL
    SELECT * FROM cpu_stack
  )
SELECT * FROM merged WHERE id IS NOT NULL;

-- Critical path stack of thread_executing_spans with the following entities in the critical path
-- stacked from top to bottom: self thread_state, self blocked_function, self process_name,
-- self thread_name, slice stack, critical_path thread_state, critical_path process_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- critical_path thread_name, critical_path slice_stack, running_cpu.
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path_stack(
  -- Thread utid to filter critical paths to.
  root_utid JOINID(thread.id),
  -- Timestamp of start of time range to filter critical paths to.
  ts TIMESTAMP,
  -- Duration of time range to filter critical paths to.
  dur DURATION)
RETURNS
  TABLE(
    -- Id of the thread_state or slice in the thread_executing_span.
    id LONG,
    -- Timestamp of slice in the critical path.
    ts TIMESTAMP,
    -- Duration of slice in the critical path.
    dur DURATION,
    -- Utid of thread that emitted the slice.
    utid JOINID(thread.id),
    -- Stack depth of the entitity in the debug track.
    stack_depth LONG,
    -- Name of entity in the critical path (could be a thread_state, kernel blocked_function, process_name, thread_name, slice name or cpu).
    name STRING,
    -- Table name of entity in the critical path (could be either slice or thread_state).
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    table_name STRING,
    -- Utid of the thread the critical path was filtered to.
    root_utid JOINID(thread.id)
) AS
SELECT * FROM _critical_path_stack($root_utid, $ts, $dur, 1, 1, 1, 1);

-- Returns a pprof aggregation of the stacks in |_critical_path_stack|.
CREATE PERFETTO FUNCTION _critical_path_graph(graph_title STRING, root_utid JOINID(thread.id), ts TIMESTAMP, dur DURATION, enable_process_name LONG, enable_thread_name LONG, enable_self_slice LONG, enable_critical_path_slice LONG)
RETURNS TABLE(pprof BYTES)
AS
WITH
  stack AS MATERIALIZED (
    SELECT
      ts,
      dur - IFNULL(LEAD(dur) OVER (PARTITION BY root_utid, ts ORDER BY stack_depth), 0) AS dur,
      name,
      utid,
      root_utid,
      stack_depth
    FROM
      _critical_path_stack($root_utid, $ts, $dur, $enable_process_name, $enable_thread_name, $enable_self_slice, $enable_critical_path_slice)
  ),
  graph AS (
    SELECT CAT_STACKS($graph_title) AS stack
  ),
  parent AS (
    SELECT
      cr.ts,
      cr.dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      cr.name,
      cr.utid,
      cr.stack_depth,
      CAT_STACKS(graph.stack, cr.name) AS stack,
      cr.root_utid
    FROM stack cr, graph
    WHERE stack_depth = 0
    UNION ALL
    SELECT
      child.ts,
      child.dur,
      child.name,
      child.utid,
      child.stack_depth,
      CAT_STACKS(stack, child.name) AS stack,
      child.root_utid
    FROM stack child
    JOIN parent
      ON
        parent.root_utid = child.root_utid
        AND parent.ts = child.ts
        AND child.stack_depth = parent.stack_depth + 1
  ),
  stacks AS (
    SELECT dur, stack FROM parent
  )
SELECT EXPERIMENTAL_PROFILE(stack, 'duration', 'ns', dur) AS pprof FROM stacks;

-- Returns a pprof aggreagation of the stacks in |_thread_executing_span_critical_path_stack|
CREATE PERFETTO FUNCTION _thread_executing_span_critical_path_graph(
  -- Descriptive name for the graph.
  graph_title STRING,
  -- Thread utid to filter critical paths to.
  root_utid JOINID(thread.id),
  -- Timestamp of start of time range to filter critical paths to.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Duration of time range to filter critical paths to.
  dur DURATION)
RETURNS TABLE(
  -- Pprof of critical path stacks.
  pprof BYTES
)
AS
SELECT * FROM _critical_path_graph($graph_title, $root_utid, $ts, $dur, 1, 1, 1, 1);

)_d3l1m1t3r_"
;

const char kSchedThreadLevelParallelism[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- This module contains helpers for computing the thread-level parallelism counters,
-- including how many threads were runnable at a given time and how many threads
-- where running at a given point in time.

INCLUDE PERFETTO MODULE intervals.overlap;

-- The count of runnable threads over time.
CREATE PERFETTO TABLE sched_runnable_thread_count(
  -- Timestamp when the runnable thread count changed to the current value.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Number of runnable threads, covering the range from this timestamp to the
  -- next row's timestamp.
  runnable_thread_count LONG
) AS
WITH
runnable AS (
  SELECT ts, dur FROM thread_state
  where state = 'R'
)
SELECT
  ts, value as runnable_thread_count
FROM intervals_overlap_count!(runnable, ts, dur)
ORDER BY ts;

-- The count of threads in uninterruptible sleep over time.
CREATE PERFETTO TABLE sched_uninterruptible_sleep_thread_count(
  -- Timestamp when the thread count changed to the current value.
  ts TIMESTAMP,
  -- Number of threads in uninterrutible sleep, covering the range from this timestamp to the
  -- next row's timestamp.
  uninterruptible_sleep_thread_count LONG
) AS
WITH
uninterruptible_sleep AS (
  SELECT ts, dur FROM thread_state
  where state = 'D'
)
SELECT
  ts, value as uninterruptible_sleep_thread_count
FROM intervals_overlap_count!(uninterruptible_sleep, ts, dur)
ORDER BY ts;

-- The count of active CPUs over time.
CREATE PERFETTO TABLE sched_active_cpu_count(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Timestamp when the number of active CPU changed.
  ts TIMESTAMP,
  -- Number of active CPUs, covering the range from this timestamp to the next
  -- row's timestamp.
  active_cpu_count LONG
) AS
WITH
-- Filter sched events corresponding to running tasks.
-- utid=0 is the swapper thread / idle task.
tasks AS (
  SELECT ts, dur
  FROM sched
  WHERE utid != 0
)
SELECT
  ts, value as active_cpu_count
FROM intervals_overlap_count!(tasks, ts, dur)
ORDER BY ts;

)_d3l1m1t3r_"
;

const char kSchedThreadStateFlattened[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE slices.flat_slices;

-- Create a table which joins the thread state across the flattened slices.
CREATE VIRTUAL TABLE __span_joined_thread USING
  SPAN_JOIN(_slice_flattened PARTITIONED utid, thread_state PARTITIONED utid);

-- Get the thread state breakdown of a flattened slice from its slice id.
-- This table pivoted and summed for better visualization and aggregation.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting. For more information, read the description
-- of _slice_flattened.
CREATE PERFETTO FUNCTION _get_flattened_thread_state(
  -- Id of the slice of interest.
  slice_id JOINID(slice.id),
  -- Utid.
  utid JOINID(thread.id))
RETURNS
  TABLE(
    -- Timestamp.
    ts TIMESTAMP,
    -- Duration.
    dur DURATION,
    -- Utid.
    utid JOINID(thread.id),
    -- Depth.
    depth LONG,
    -- Name.
    name STRING,
    -- Slice id.
    slice_id JOINID(slice.id),
    -- Track id.
    track_id JOINID(track.id),
    -- CPU.
    cpu LONG,
    -- State.
    state STRING,
    -- IO wait.
    io_wait LONG,
    -- Thread state's blocked_function.
    blocked_function STRING,
    -- Thread state's waker utid.
    waker_utid JOINID(thread.id),
    -- Thread state's IRQ context.
    irq_context LONG
) AS
WITH
interesting_slice AS (
  SELECT ts, dur, slice.track_id AS track_id
  FROM slice
  JOIN thread_track
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    ON slice.track_id = thread_track.id
  JOIN thread
    USING (utid)
  WHERE
    (($slice_id IS NOT NULL AND slice.id = $slice_id) OR ($slice_id IS NULL))
    AND (($utid IS NOT NULL AND utid = $utid) OR ($utid IS NULL))
)
SELECT
  ts,
  dur,
  utid,
  depth,
  name,
  slice_id,
  track_id,
  cpu,
  state,
  io_wait,
  blocked_function,
  waker_utid,
  irq_context
FROM __span_joined_thread
WHERE
  track_id = (SELECT track_id FROM interesting_slice)
  AND ts >= (SELECT ts FROM interesting_slice)
  AND ts < (SELECT ts + dur FROM interesting_slice);

-- Get the thread state breakdown of a flattened slice from slice id.
-- This table pivoted and summed for better visualization and aggragation.
-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting. For more information, read the description
-- of _slice_flattened.
CREATE PERFETTO FUNCTION _get_flattened_thread_state_aggregated(
  -- Slice id.
  slice_id JOINID(slice.id),
  -- Utid.
  utid JOINID(thread.id))
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS TABLE(
  -- Id of a slice.
  slice_id JOINID(slice.id),
  -- Name of the slice.
  slice_name STRING,
  -- Time (ns) spent in Uninterruptible Sleep (non-IO)
  Uninterruptible_Sleep_nonIO LONG,
  -- Time (ns) spent in Uninterruptible Sleep (IO)
  Uninterruptible_Sleep_IO LONG,
  -- Time (ns) spent in Runnable
  Runnable LONG,
  -- Time (ns) spent in Sleeping
  Sleeping LONG,
  -- Time (ns) spent in Stopped
  Stopped LONG,
  -- Time (ns) spent in Traced
  Traced LONG,
  -- Time (ns) spent in Exit (Dead)
  Exit_Dead LONG,
  -- Time (ns) spent in Exit (Zombie)
  Exit_Zombie LONG,
  -- Time (ns) spent in Task Dead
  Task_Dead LONG,
  -- Time (ns) spent in Wake Kill
  Wake_Kill LONG,
  -- Time (ns) spent in Waking
  Waking LONG,
  -- Time (ns) spent in Parked
  Parked LONG,
  -- Time (ns) spent in No Load
  No_Load LONG,
  -- Time (ns) spent in Runnable (Preempted)
  Runnable_Preempted LONG,
  -- Time (ns) spent in Running
  Running LONG,
  -- Time (ns) spent in Idle
  Idle LONG,
  -- Total duration of the slice
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- Depth of the slice in Perfetto
  depth LONG)
AS
WITH
final_table AS (
  SELECT *
  FROM _get_flattened_thread_state($slice_id, $utid)
)
SELECT
fs.slice_id,
fs.name AS slice_name,
SUM(CASE WHEN fs.state = 'D' AND io_wait = 0 THEN fs.dur END)
  Uninterruptible_Sleep_nonIO,
SUM(CASE WHEN fs.state = 'D' AND io_wait = 1 THEN fs.dur END)
  Uninterruptible_Sleep_IO,
SUM(CASE WHEN fs.state = 'R' THEN fs.dur END) Runnable,
SUM(CASE WHEN fs.state = 'S' THEN fs.dur END) Sleeping,
SUM(CASE WHEN fs.state = 'T' THEN fs.dur END) Stopped,
SUM(CASE WHEN fs.state = 't' THEN fs.dur END) Traced,
SUM(CASE WHEN fs.state = 'X' THEN fs.dur END) Exit_Dead,
SUM(CASE WHEN fs.state = 'Z' THEN fs.dur END) Exit_Zombie,
SUM(CASE WHEN fs.state = 'x' THEN fs.dur END) Task_Dead,
SUM(CASE WHEN fs.state = 'K' THEN fs.dur END) Wake_Kill,
SUM(CASE WHEN fs.state = 'W' THEN fs.dur END) Waking,
SUM(CASE WHEN fs.state = 'P' THEN fs.dur END) Parked,
SUM(CASE WHEN fs.state = 'N' THEN fs.dur END) No_Load,
SUM(CASE WHEN fs.state = 'R+' THEN fs.dur END) Runnable_Preempted,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SUM(CASE WHEN fs.state = 'Running' THEN fs.dur END) Running,
SUM(CASE WHEN fs.state = 'I' THEN fs.dur END) Idle,
SUM(fs.dur) dur,
fs.depth
FROM final_table fs
GROUP BY fs.slice_id;
)_d3l1m1t3r_"
;

const char kSchedTimeInState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;

-- The time a thread spent in each scheduling state during it's lifetime.
CREATE PERFETTO TABLE sched_time_in_state_for_thread(
  -- Utid of the thread.
  utid JOINID(thread.id),
  -- Total runtime of thread.
  total_runtime LONG,
  -- One of the scheduling states of kernel thread.
  state STRING,
  -- Total time spent in the scheduling state.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  time_in_state LONG,
  -- Percentage of time thread spent in scheduling state in [0-100] range.
  percentage_in_state LONG
) AS
WITH total_dur AS (
  SELECT
    utid,
    sum(dur) AS sum_dur
  FROM thread_state
  GROUP BY 1
),
summed AS (
  SELECT
    utid,
    state,
    sum(dur) AS time_in_state
  FROM thread_state group by 1, 2
)
SELECT
  utid,
  sum_dur AS total_runtime,
  state,
  time_in_state,
  (time_in_state*100)/(sum_dur) AS percentage_in_state
FROM summed JOIN total_dur USING (utid);

CREATE PERFETTO MACRO _case_for_state(state Expr)
RETURNS Expr AS
MAX(CASE WHEN state = $state THEN percentage_in_state END);

-- Summary of time spent by thread in each scheduling state, in percentage ([0, 100]
-- ranges). Sum of all states might be smaller than 100, as those values
-- are rounded down.
CREATE PERFETTO TABLE sched_percentage_of_time_in_state(
  -- Utid of the thread.
  utid JOINID(thread.id),
  -- Percentage of time thread spent in running ('Running') state in [0, 100]
  -- range.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  running LONG,
  -- Percentage of time thread spent in runnable ('R') state in [0, 100]
  -- range.
  runnable LONG,
  -- Percentage of time thread spent in preempted runnable ('R+') state in
  -- [0, 100] range.
  runnable_preempted LONG,
  -- Percentage of time thread spent in sleeping ('S') state in [0, 100] range.
  sleeping LONG,
  -- Percentage of time thread spent in uninterruptible sleep ('D') state in
  -- [0, 100] range.
  uninterruptible_sleep LONG,
  -- Percentage of time thread spent in other ('T', 't', 'X', 'Z', 'x', 'I',
  -- 'K', 'W', 'P', 'N') states in [0, 100] range.
  other LONG
) AS
SELECT
  utid,
  _case_for_state!('Running') AS running,
  _case_for_state!('R') AS runnable,
  _case_for_state!('R+') AS runnable_preempted,
  _case_for_state!('S') AS sleeping,
  _case_for_state!('D') AS uninterruptible_sleep,
  SUM(
    CASE WHEN state IN ('T', 't', 'X', 'Z', 'x', 'I', 'K', 'W', 'P', 'N')
    THEN time_in_state END
  ) * 100/total_runtime AS other
FROM sched_time_in_state_for_thread
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY utid;

-- Time the thread spent each state in a given interval.
--
-- This function is only designed to run over a small number of intervals
-- (10-100 at most). It will be *very slow* for large sets of intervals.
--
-- Specifically for any non-trivial subset of thread slices, prefer using
-- `thread_slice_time_in_state` in the `slices.time_in_state` module for this
-- purpose instead.
CREATE PERFETTO FUNCTION sched_time_in_state_for_thread_in_interval(
  -- The start of the interval.
  ts TIMESTAMP,
  -- The duration of the interval.
  dur DURATION,
  -- The utid of the thread.
  utid JOINID(thread.id)
)
RETURNS TABLE(
  -- The scheduling state (from the `thread_state` table).
  --
  -- Use the `sched_state_to_human_readable_string` function in the `sched`
  -- package to get full name.
  state STRING,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL,
  -- If the `state` is uninterruptible sleep, `io_wait` indicates if it was
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- an IO sleep. Will be null if `state` is *not* uninterruptible sleep or if
  -- we cannot tell if it was an IO sleep or not.
  --
  -- Only available on Android when
  -- `sched/sched_blocked_reason` ftrace tracepoint is enabled.
  blocked_function LONG,
  -- The duration of time the threads slice spent for each
  -- (state, io_wait, blocked_function) tuple.
  dur DURATION
) AS
SELECT
  state,
  io_wait,
  blocked_function,
  sum(ii.dur) as dur
FROM thread_state
JOIN (
  SELECT *
  FROM _interval_intersect_single!(
    $ts, $dur,
    (
      SELECT id, ts, dur
      FROM thread_state
      WHERE utid = $utid AND dur > 0
    )
  )
) ii USING (id)
GROUP BY 1, 2, 3
ORDER BY 4 DESC;

-- Time the thread spent each state and cpu in a given interval.
CREATE PERFETTO FUNCTION sched_time_in_state_and_cpu_for_thread_in_interval(
  -- The start of the interval.
  ts TIMESTAMP,
  -- The duration of the interval.
  dur DURATION,
  -- The utid of the thread.
  utid JOINID(thread.id))
RETURNS TABLE(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Thread state (from the `thread_state` table).
  -- Use `sched_state_to_human_readable_string` function to get full name.
  state STRING,
  -- A (posssibly NULL) boolean indicating, if the device was in uninterruptible
  -- sleep, if it was an IO sleep.
  io_wait BOOL,
  -- Id of the CPU.
  cpu LONG,
  -- Some states can specify the blocked function. Usually NULL.
  blocked_function LONG,
  -- Total time spent with this state, cpu and blocked function.
  dur DURATION) AS
SELECT
  state,
  io_wait,
  cpu,
  blocked_function,
  sum(ii.dur) as dur
FROM thread_state
JOIN
  (SELECT * FROM _interval_intersect_single!(
    $ts, $dur,
    (SELECT id, ts, dur
    FROM thread_state
    WHERE utid = $utid AND dur > 0))) ii USING (id)
GROUP BY 1, 2, 3, 4
ORDER BY 5 DESC;

-- Time spent by CPU in each scheduling state in a provided interval.
CREATE PERFETTO FUNCTION sched_time_in_state_for_cpu_in_interval(
    -- CPU id.
    cpu LONG,
    -- Interval start.
    ts TIMESTAMP,
    -- Interval duration.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    dur LONG
) RETURNS TABLE (
    -- End state. From `sched.end_state`.
    end_state STRING,
    -- Duration in state.
    dur LONG
) AS
WITH sched_for_cpu AS (
  SELECT id, ts, dur
  FROM sched
  WHERE cpu = $cpu AND dur != -1
)
SELECT
    end_state,
    sum(ii.dur) AS dur
FROM sched
JOIN _interval_intersect_single!($ts, $dur, sched_for_cpu) ii
USING (id)
GROUP BY end_state;




)_d3l1m1t3r_"
;

const char kSlicesCpuTime[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE linux.cpu.utilization.slice;

-- Time each thread slice spent running on CPU.
-- Requires scheduling data to be available in the trace.
CREATE PERFETTO TABLE thread_slice_cpu_time(
  -- Slice.
  id JOINID(slice.id),
  -- Name of the slice.
  name STRING,
  -- Id of the thread the slice is running on.
  utid JOINID(thread.id),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Name of the thread.
  thread_name STRING,
  -- Id of the process the slice is running on.
  upid JOINID(process.id),
  -- Name of the process.
  process_name STRING,
  -- Duration of the time the slice was running.
  cpu_time LONG) AS
SELECT
id_0 AS id,
name,
ts.utid,
thread_name,
upid,
process_name,
SUM(ii.dur) AS cpu_time
FROM _interval_intersect!((
  (SELECT * FROM thread_slice WHERE utid > 0 AND dur > 0),
  (SELECT * FROM sched WHERE dur > 0)
  ), (utid)) ii
JOIN thread_slice ts ON ts.id = ii.id_0
GROUP BY id
ORDER BY id;

-- CPU cycles per each slice.
CREATE PERFETTO VIEW thread_slice_cpu_cycles(
  -- Id of a slice.
  id JOINID(slice.id),
  -- Name of the slice.
  name STRING,
  -- Id of the thread the slice is running on.
  utid JOINID(thread.id),
  -- Name of the thread.
  thread_name STRING,
  -- Id of the process the slice is running on.
  upid JOINID(process.id),
  -- Name of the process.
  process_name STRING,
  -- Sum of CPU millicycles. Null if frequency couldn't be fetched for any
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- period during the runtime of the slice.
  millicycles LONG,
  -- Sum of CPU megacycles. Null if frequency couldn't be fetched for any
  -- period during the runtime of the slice.
  megacycles LONG
) AS
SELECT
  id,
  name,
  utid,
  thread_name,
  upid,
  process_name,
  millicycles,
  megacycles
FROM cpu_cycles_per_thread_slice;

)_d3l1m1t3r_"
;

const char kSlicesFlatSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2023 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
INCLUDE PERFETTO MODULE slices.with_context;
INCLUDE PERFETTO MODULE intervals.overlap;

-- The concept of a "flat slice" is to take the data in the slice table and
-- remove all notion of nesting; we do this by projecting every slice in a stack to
-- their ancestor slice, i.e at any point in time, taking the  most specific active
-- slice (i.e. the slice at the bottom of the stack) and representing that as the
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- *only* slice that was running during that period.
--
-- This concept becomes very useful when you try and linearise a trace and
-- compare it with other traces spanning the same user action; "self time" (i.e.
-- time spent in a slice but *not* any children) is easily computed and span
-- joins with thread state become possible without limiting to only depth zero
--- slices.
--
-- Note that, no slices will be generated for intervals without without any slices.
--
-- As an example, consider the following slice stack:
-- ```
-- A-------------B.
-- ----C----D----.
-- ```
-- The flattened slice will be:
-- ```
-- A----C----D----B.
-- ```
--
-- @column slice_id           Id of most active slice.
-- @column ts                 Timestamp when `slice.id` became the most active slice.
-- @column dur                Duration of `slice.id` as the most active slice until the next active slice.
-- @column depth              Depth of `slice.id` in the original stack.
-- @column name               Name of `slice.id`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- @column root_name          Name of the top most slice of the stack.
-- @column root_id            Id of of the top most slice of the stack.
-- @column track_id           Alias for `slice.track_id`.
-- @column utid               Alias for `thread.utid`.
-- @column tid                Alias for `thread.tid`
-- @column thread_name        Alias for `thread.name`.
-- @column upid               Alias for `process.upid`.
-- @column pid                Alias for `process.pid`.
-- @column process_name       Alias for `process.name`.
CREATE PERFETTO TABLE _slice_flattened
AS
WITH
  root_slices AS (
    SELECT * FROM slice WHERE parent_id IS NULL
  ),
  child_slices AS (
    SELECT anc.id AS root_id, slice.*
    FROM slice
    JOIN ancestor_slice(slice.id) anc
    WHERE slice.parent_id IS NOT NULL
  ),
  flat_slices AS (
    SELECT id, ts, dur
    FROM _intervals_flatten !(_intervals_merge_root_and_children!(root_slices, child_slices))
  )
SELECT
  id AS slice_id,
  flat_slices.ts,
  flat_slices.dur,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  depth,
  name,
  track_id,
  utid,
  tid,
  thread_name,
  upid,
  pid,
  process_name
FROM flat_slices
JOIN thread_slice
  USING (id);

CREATE PERFETTO INDEX _slice_flattened_id_idx
ON _slice_flattened(slice_id);

CREATE PERFETTO INDEX _slice_flattened_ts_idx
ON _slice_flattened(ts);

)_d3l1m1t3r_"
;

const char kSlicesFlow[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.search;

-- It's very typical to filter the flow table on either incoming or outgoing slice ids.
--
-- Ideally, this should be automatic and shouldn't require any additional imports, however we
-- can't add it to prelude (because it is initialised before the trace is loaded and the indexes
-- are not rebuilt when the new data is loaded), so the interested parties should remember to import
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- this module.
CREATE PERFETTO INDEX flow_in ON flow(slice_in);
CREATE PERFETTO INDEX flow_out ON flow(slice_out);

-- Computes the "reachable" set of slices from the |flows| table, starting from slice ids
-- specified in |source_table|. This provides a more efficient result than with the in-built
-- following_flow operator.
CREATE PERFETTO MACRO _slice_following_flow(
  -- A table/view/subquery corresponding to the nodes to start the reachability search.
  -- This table must have a uint32 "id" column.
  source_table TableOrSubquery
)
-- The returned table has the schema (root_node_id, node_id LONG, parent_node_id LONG).
-- |root_node_id| is the id of the starting node under which this edge was encountered.
-- |node_id| is the id of the node from the input graph and |parent_node_id|
-- is the id of the node which was the first encountered predecessor in a DFS
-- search of the graph.
RETURNS TableOrSubquery AS
(
SELECT *
FROM
  graph_reachable_weight_bounded_dfs
    !((SELECT slice_out AS source_node_id, slice_in AS dest_node_id, 0 AS edge_weight FROM flow),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      (
        SELECT slice_out AS root_node_id, 1 AS root_target_weight
        FROM flow
        JOIN (SELECT id FROM $source_table) source
          ON slice_out = source.id
      ),
      1)
);

)_d3l1m1t3r_"
;

const char kSlicesHierarchy[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Similar to `ancestor_slice`, but returns the slice itself in addition to strict ancestors.
CREATE PERFETTO FUNCTION _slice_ancestor_and_self(
  -- Id of the slice.
  slice_id JOINID(slice.id)
)
RETURNS TABLE(
  -- Slice
  id JOINID(slice.id),
  -- Alias of `slice.type`.
  type STRING,
  -- Alias of `slice.ts`.
  ts TIMESTAMP,
  -- Alias of `slice.dur`.
  dur DURATION,
  -- Alias of `slice.track_id`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  track_id JOINID(track.id),
  -- Alias of `slice.category`.
  category STRING,
  -- Alias of `slice.name`.
  name STRING,
  -- Alias of `slice.depth`.
  depth LONG,
  -- Alias of `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias of `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias of `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias of `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  id, type, ts, dur, track_id, category, name, depth, parent_id, arg_set_id, thread_ts, thread_dur
FROM slice
WHERE id = $slice_id
UNION ALL
SELECT
  id, type, ts, dur, track_id, category, name, depth, parent_id, arg_set_id, thread_ts, thread_dur
FROM ancestor_slice($slice_id);

-- Similar to `descendant_slice`, but returns the slice itself in addition to strict descendants.
CREATE PERFETTO FUNCTION _slice_descendant_and_self(
  -- Id of the slice.
  slice_id JOINID(slice.id)
)
RETURNS TABLE(
  -- Slice
  id JOINID(slice.id),
  -- Alias of `slice.type`.
  type STRING,
  -- Alias of `slice.ts`.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  -- Alias of `slice.dur`.
  dur DURATION,
  -- Track.
  track_id JOINID(track.id),
  -- Alias of `slice.category`.
  category STRING,
  -- Alias of `slice.name`.
  name STRING,
  -- Alias of `slice.depth`.
  depth LONG,
  -- Alias of `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias of `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias of `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias of `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  id, type, ts, dur, track_id, category, name, depth, parent_id, arg_set_id, thread_ts, thread_dur
FROM slice
WHERE id = $slice_id
UNION ALL
SELECT
  id, type, ts, dur, track_id, category, name, depth, parent_id, arg_set_id, thread_ts, thread_dur
FROM descendant_slice($slice_id);

-- Delete rows from |slice_table| where the |column_name| value is NULL.
--
-- The |parent_id| of the remaining rows are adjusted to point to the closest
-- ancestor remaining. This keeps the trees as connected as possible,
-- allowing further graph analysis.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO MACRO _slice_remove_nulls_and_reparent(
  -- Table or subquery containing a subset of the slice table. Required columns are
  -- (id LONG, parent_id LONG, depth LONG, <column_name>).
  slice_table TableOrSubQuery,
  -- Column name for which a NULL value indicates the row will be deleted.
  column_name ColumnName)
  -- The returned table has the schema (id LONG, parent_id LONG, depth LONG, <column_name>).
RETURNS TableOrSubQuery
AS (
  WITH _slice AS (
    SELECT * FROM $slice_table WHERE $column_name IS NOT NULL
  )
  SELECT
    id,
    parent_id,
    depth,
    $column_name
  FROM _slice
  WHERE depth = 0
  UNION ALL
  SELECT
    child.id,
    anc.id AS parent_id,
    MAX(IIF(parent.$column_name IS NULL, 0, anc.depth)) AS depth,
    child.$column_name
  FROM _slice child
  JOIN ancestor_slice(child.id) anc
  LEFT JOIN _slice parent
    ON parent.id = anc.id
  GROUP BY child.id
);

)_d3l1m1t3r_"
;

const char kSlicesSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2022 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All slices with related process and thread info if available. Unlike
-- `thread_slice` and `process_slice`, this view contains all slices,
-- with thread- and process-related columns set to NULL if the slice
-- is not associated with a thread or a process.
CREATE PERFETTO VIEW _slice_with_thread_and_process_info(
  -- Slice
  id JOINID(slice.id),
  -- Alias for `slice.type`.
  type STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Alias for `slice.ts`.
  ts TIMESTAMP,
  -- Alias for `slice.dur`.
  dur DURATION,
  -- Alias for `slice.category`.
  category STRING,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id JOINID(track.id),
  -- Alias for `track.name`.
  track_name STRING,
  -- Alias for `thread.name`.
  thread_name STRING,
  -- Alias for `thread.utid`.
  utid JOINID(thread.id),
  -- Alias for `thread.tid`
  tid LONG,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid JOINID(process.id),
  -- Alias for `process.pid`.
  pid LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias for `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias for `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  track.name AS track_name,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread.name AS thread_name,
  thread.utid,
  thread.tid,
  COALESCE(process1.name, process2.name) AS process_name,
  COALESCE(process1.upid, process2.upid) AS upid,
  COALESCE(process1.pid, process2.pid) AS pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN track ON slice.track_id = track.id
LEFT JOIN thread_track ON slice.track_id = thread_track.id
LEFT JOIN thread USING (utid)
LEFT JOIN process process1 ON thread.upid = process1.upid
LEFT JOIN process_track ON slice.track_id = process_track.id
LEFT JOIN process process2 ON process_track.upid = process2.upid;

)_d3l1m1t3r_"
;

const char kSlicesTimeInState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE slices.with_context;

-- For each thread slice, returns the sum of the time it spent in various
-- scheduling states.
--
-- Requires scheduling data to be available in the trace.
CREATE PERFETTO TABLE thread_slice_time_in_state(
  -- Thread slice.
  id JOINID(slice.id),
  -- Name of the slice.
  name STRING,
  -- Thread the slice is running on.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  utid JOINID(thread.id),
  -- Name of the thread.
  thread_name STRING,
  -- Id of the process the slice is running on.
  upid JOINID(process.id),
  -- Name of the process.
  process_name STRING,
  -- The scheduling state (from the `thread_state` table).
  --
  -- Use the `sched_state_to_human_readable_string` function in the `sched`
  -- package to get full name.
  state STRING,
  -- If the `state` is uninterruptible sleep, `io_wait` indicates if it was
  -- an IO sleep. Will be null if `state` is *not* uninterruptible sleep or if
  -- we cannot tell if it was an IO sleep or not.
  --
  -- Only available on Android when
  -- `sched/sched_blocked_reason` ftrace tracepoint is enabled.
  io_wait BOOL,
  -- If in uninterruptible sleep (D), the kernel function on which was blocked.
  -- Only available on userdebug Android builds when
  -- `sched/sched_blocked_reason` ftrace tracepoint is enabled.
  blocked_function LONG,
  -- The duration of time the threads slice spent for each
  -- (state, io_wait, blocked_function) tuple.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION
) AS
SELECT
  ii.id_0 AS id,
  ts.name,
  ts.utid,
  ts.thread_name,
  ts.upid,
  ts.process_name,
  tstate.state,
  tstate.io_wait,
  tstate.blocked_function,
  SUM(ii.dur) AS dur
FROM _interval_intersect!(
  (
    (SELECT * FROM thread_slice WHERE utid > 0 AND dur > 0),
    (SELECT * FROM thread_state WHERE dur > 0)
  ),
  (utid)
) ii
JOIN thread_slice ts ON ts.id = ii.id_0
JOIN thread_state tstate ON tstate.id = ii.id_1
GROUP BY ii.id_0, tstate.state, tstate.io_wait, tstate.blocked_function
ORDER BY ii.id_0;

)_d3l1m1t3r_"
;

const char kSlicesWithContext[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- All thread slices with data about thread, thread track and process.
-- Where possible, use available view functions which filter this view.
CREATE PERFETTO VIEW thread_slice(
  -- Slice
  id JOINID(slice.id),
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts TIMESTAMP,
  -- Alias for `slice.dur`.
  dur DURATION,
  -- Alias for `slice.category`.
  category STRING,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id JOINID(track.id),
  -- Alias for `thread_track.name`.
  track_name STRING,
  -- Alias for `thread.name`.
  thread_name STRING,
  -- Alias for `thread.utid`.
  utid JOINID(thread.id),
  -- Alias for `thread.tid`.
  tid LONG,
  -- Alias for `thread.is_main_thread`.
  is_main_thread BOOL,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid JOINID(process.id),
  -- Alias for `process.pid`.
  pid LONG,
  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias for `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias for `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  thread_track.name AS track_name,
  thread.name AS thread_name,
  thread.utid,
  thread.tid,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  thread.is_main_thread,
  process.name AS process_name,
  process.upid,
  process.pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN thread_track ON slice.track_id = thread_track.id
JOIN thread USING (utid)
LEFT JOIN process USING (upid);

-- All process slices with data about process track and process.
-- Where possible, use available view functions which filter this view.
CREATE PERFETTO VIEW process_slice(
  -- Slice
  id JOINID(slice.id),
  -- Alias for `slice.type`.
  type STRING,
  -- Alias for `slice.ts`.
  ts TIMESTAMP,
  -- Alias for `slice.dur`.
  dur DURATION,
  -- Alias for `slice.category`.
  category STRING,
  -- Alias for `slice.name`.
  name STRING,
  -- Alias for `slice.track_id`.
  track_id JOINID(track.id),
  -- Alias for `process_track.name`.
  track_name STRING,
  -- Alias for `process.name`.
  process_name STRING,
  -- Alias for `process.upid`.
  upid JOINID(process.id),
  -- Alias for `process.pid`.
  pid LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Alias for `slice.depth`.
  depth LONG,
  -- Alias for `slice.parent_id`.
  parent_id JOINID(slice.id),
  -- Alias for `slice.arg_set_id`.
  arg_set_id ARGSETID,
  -- Alias for `slice.thread_ts`.
  thread_ts TIMESTAMP,
  -- Alias for `slice.thread_dur`.
  thread_dur LONG
) AS
SELECT
  slice.id,
  slice.type,
  slice.ts,
  slice.dur,
  slice.category,
  slice.name,
  slice.track_id,
  process_track.name AS track_name,
  process.name AS process_name,
  process.upid,
  process.pid,
  slice.depth,
  slice.parent_id,
  slice.arg_set_id,
  slice.thread_ts,
  slice.thread_dur
FROM slice
JOIN process_track ON slice.track_id = process_track.id
JOIN process USING (upid);
)_d3l1m1t3r_"
;

const char kStackTraceJit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- Represents a jitted code snippet.
-- TODO(carlscab): Make public
CREATE PERFETTO VIEW _jit_code (
  -- Unique jit code id.
  jit_code_id LONG,
  -- Time this code was created / allocated.
  create_ts TIMESTAMP,
  -- Time this code was destroyed / deallocated. This is a upper bound, as we
  -- can only detect deletions indirectly when new code is allocated overlapping
  -- existing one.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  estimated_delete_ts TIMESTAMP,
  -- Thread that generated the code.
  utid JOINID(thread.id),
  -- Start address for the generated code.
  start_address LONG,
  -- Size in bytes of the generated code.
  size LONG,
  -- Function name.
  function_name STRING,
  -- Jitted code (binary data).
  native_code BYTES
) AS
SELECT
  id AS jit_code_id,
  create_ts,
  estimated_delete_ts,
  utid,
  start_address,
  size,
  function_name,
  base64_decode(native_code_base64) AS native_code
FROM __intrinsic_jit_code;

-- Represents a jitted frame.
-- TODO(carlscab): Make public
CREATE PERFETTO VIEW _jit_frame (
  -- Jitted code snipped the frame is in (joins with _jit_code.jit_code_id).
  jit_code_id LONG,
  -- Jitted frame (joins with stack_profile_frame.id).
  frame_id LONG
) AS
SELECT
  jit_code_id,
  frame_id
FROM
  __intrinsic_jit_frame;

)_d3l1m1t3r_"
;

const char kStacksCpuProfiling[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the 'License');
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an 'AS IS' BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE callstacks.stack_profile;

-- Table containing all the timestamped samples of CPU profiling which occurred
-- during the trace.
--
-- Currently, this table is backed by the following data sources:
--  * Linux perf
--  * macOS instruments
--  * Chrome CPU profiling
--  * Legacy V8 CPU profiling
--  * Profiling data in Gecko traces
CREATE PERFETTO TABLE cpu_profiling_samples(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- The id of the sample.
  id LONG,
  -- The timestamp of the sample.
  ts TIMESTAMP,
  -- The utid of the thread of the sample, if available.
  utid JOINID(thread.id),
  -- The tid of the sample, if available.
  tid LONG,
  -- The thread name of thread of the sample, if available.
  thread_name STRING,
  -- The ucpu of the sample, if available.
  ucpu LONG,
  -- The cpu of the sample, if available.
  cpu LONG,
  -- The callsite id of the sample.
  callsite_id LONG
)
AS
WITH raw_samples AS (
  -- Linux perf samples.
  SELECT p.ts, p.utid, p.cpu AS ucpu, p.callsite_id
  FROM perf_sample p
  UNION ALL
  -- Instruments samples.
  SELECT p.ts, p.utid, p.cpu AS ucpu, p.callsite_id
  FROM instruments_sample p
  UNION ALL
  -- All other CPU profiling.
  SELECT s.ts, s.utid, NULL AS ucpu, s.callsite_id
  FROM cpu_profile_stack_sample s
)
SELECT
  ROW_NUMBER() OVER (ORDER BY ts) AS id,
  r.*,
  t.tid,
  t.name AS thread_name,
  c.cpu
FROM raw_samples r
LEFT JOIN thread t USING (utid)
LEFT JOIN cpu c USING (ucpu)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(ORDER BY ts;

CREATE PERFETTO TABLE _cpu_profiling_self_callsites AS
SELECT *
FROM _callstacks_for_callsites!((
  SELECT callsite_id
  FROM cpu_profiling_samples
))
ORDER BY id;

-- Table summarising the callstacks captured during any CPU profiling which
-- occurred during the trace.
--
-- Specifically, this table returns a tree containing all the callstacks seen
-- during the trace with `self_count` equal to the number of samples with that
-- frame as the leaf and `cumulative_count` equal to the number of samples with
-- the frame anywhere in the tree.
--
-- The data sources supported are the same as the `cpu_profiling_samples` table.
CREATE PERFETTO TABLE cpu_profiling_summary_tree(
  -- The id of the callstack; by callstack we mean a unique set of frames up to
  -- the root frame.
  id LONG,
  -- The id of the parent callstack for this callstack. NULL if this is root.
  parent_id LONG,
  -- The function name of the frame for this callstack.
  name STRING,
  -- The name of the mapping containing the frame. This can be a native binary,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- library, JAR or APK.
  mapping_name STRING,
  -- The name of the file containing the function.
  source_file STRING,
  -- The line number in the file the function is located at.
  line_number LONG,
  -- The number of samples with this function as the leaf frame.
  self_count LONG,
  -- The number of samples with this function appearing anywhere on the
  -- callstack.
  cumulative_count LONG
) AS
SELECT
  id,
  parent_id,
  name,
  mapping_name,
  source_file,
  line_number,
  SUM(self_count) AS self_count,
  SUM(cumulative_count) AS cumulative_count
FROM (
  SELECT r.*, a.cumulative_count
  FROM _cpu_profiling_self_callsites r
  JOIN _callstacks_self_to_cumulative!((
    SELECT id, parent_id, self_count
    FROM _cpu_profiling_self_callsites
  )) a USING (id)
)
GROUP BY id;

)_d3l1m1t3r_"
;

const char kTimeConversion[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns the provided nanosecond duration, which is the default
-- representation of time durations in trace processor. Provided for
-- consistency with other functions.
CREATE PERFETTO FUNCTION time_from_ns(
  -- Time duration in nanoseconds.
  nanos LONG
)
-- Time duration in nanoseconds.
RETURNS TIMESTAMP AS
SELECT $nanos;

-- Converts a duration in microseconds to nanoseconds, which is the default
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_us(
  -- Time duration in microseconds.
  micros LONG
)
-- Time duration in nanoseconds.
RETURNS LONG AS
SELECT $micros * 1000;

-- Converts a duration in millseconds to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_ms(
  -- Time duration in milliseconds.
  millis LONG
)
-- Time duration in nanoseconds.
RETURNS TIMESTAMP AS
SELECT $millis * 1000 * 1000;

-- Converts a duration in seconds to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_s(
  -- Time duration in seconds.
  seconds LONG
)
-- Time duration in nanoseconds.
RETURNS TIMESTAMP AS
SELECT $seconds * 1000 * 1000 * 1000;

-- Converts a duration in minutes to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_min(
  -- Time duration in minutes.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  minutes LONG
)
-- Time duration in nanoseconds.
RETURNS TIMESTAMP AS
SELECT $minutes * 60 * 1000 * 1000 * 1000;

-- Converts a duration in hours to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_hours(
  -- Time duration in hours.
  hours LONG
)
-- Time duration in nanoseconds.
RETURNS TIMESTAMP AS
SELECT $hours * 60 * 60 * 1000 * 1000 * 1000;

-- Converts a duration in days to nanoseconds, which is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_from_days(
  -- Time duration in days.
  days LONG
)
-- Time duration in nanoseconds.
RETURNS LONG AS
SELECT $days * 24 * 60 * 60 * 1000 * 1000 * 1000;

-- Returns the provided nanosecond duration, which is the default
-- representation of time durations in trace processor. Provided for
-- consistency with other functions.
CREATE PERFETTO FUNCTION time_to_ns(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in nanoseconds.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS LONG AS
SELECT $nanos;

-- Converts a duration in nanoseconds to microseconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_us(
-- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in microseconds.
RETURNS LONG AS
SELECT $nanos / 1000;

-- Converts a duration in nanoseconds to millseconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_ms(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in milliseconds.
RETURNS LONG AS
SELECT $nanos / (1000 * 1000);

-- Converts a duration in nanoseconds to seconds. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_s(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in seconds.
RETURNS LONG AS
SELECT $nanos / (1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to minutes. Nanoseconds is the default
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_min(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in minutes.
RETURNS LONG AS
SELECT $nanos / (60 * 1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to hours. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_hours(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in hours.
RETURNS LONG AS
SELECT $nanos / (60 * 60 * 1000 * 1000 * 1000);

-- Converts a duration in nanoseconds to days. Nanoseconds is the default
-- representation of time durations in trace processor.
CREATE PERFETTO FUNCTION time_to_days(
  -- Time duration in nanoseconds.
  nanos TIMESTAMP
)
-- Time duration in days.
RETURNS LONG AS
SELECT $nanos / (24 * 60 * 60 * 1000 * 1000 * 1000);


)_d3l1m1t3r_"
;

const char kV8Jit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- These are the tables for the V8 jit data source
-- (protos/perfetto/trace/chrome/v8.proto).
--
-- All events are associated to a V8 isolate instance. There can be multiple
-- instances associated to a given thread, although this is rare.
--
-- Generated code in V8 is allocated in the V8 heap (in a special executeable
-- section), this means that code can be garbage collected (when no longer used)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- or can be moved around (e.g. during heap compactation). This means that a
-- given callsite might correspond to function `A` at one point in time and to
-- function `B` later on.
-- In addition V8 code has various levels of optimization, so a function might
-- have multiple associated code snippets.
--
-- V8 does not track code deletion, so we have to indirectly infer it by
-- detecting code overlaps, if a newer code creation event overlaps with older
-- code we need to asume that the old code was deleted. Code moves are logged,
-- and there is an event to track those.

-- A V8 Isolate instance. A V8 Isolate represents an isolated instance of the V8
-- engine.
CREATE PERFETTO VIEW v8_isolate(
  -- Unique V8 isolate id.
  v8_isolate_id LONG,
  -- Process the isolate was created in.
  upid JOINID(process.id),
  -- Internal id used by the v8 engine. Unique in a process.
  internal_isolate_id LONG,
  -- Absolute start address of the embedded code blob.
  embedded_blob_code_start_address LONG,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- Size in bytes of the embedded code blob.
  embedded_blob_code_size LONG,
  -- Base address of the code range if the isolate defines one.
  code_range_base_address LONG,
  -- Size of a code range if the isolate defines one.
  code_range_size LONG,
  -- Whether the code range for this Isolate is shared with others in the same
  -- process. There is at max one such shared code range per process.
  shared_code_range LONG,
  -- Used when short builtin calls are enabled, where embedded builtins are
  -- copied into the CodeRange so calls can be nearer.
  embedded_blob_code_copy_start_address LONG
) AS
SELECT
  id AS v8_isolate_id,
  upid,
  internal_isolate_id,
  embedded_blob_code_start_address,
  embedded_blob_code_size,
  code_range_base_address,
  code_range_size,
  shared_code_range,
  embedded_blob_code_copy_start_address
FROM
  __intrinsic_v8_isolate;


-- Represents a script that was compiled to generate code. Some V8 code is
-- generated out of scripts and will reference a V8Script other types of code
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- will not (e.g. builtins).
CREATE PERFETTO VIEW v8_js_script (
  -- Unique V8 JS script id.
  v8_js_script_id LONG,
  -- V8 isolate this script belongs to (joinable with
  -- `v8_isolate.v8_isolate_id`).
  v8_isolate_id LONG,
  -- Script id used by the V8 engine.
  internal_script_id LONG,
  -- Script type.
  script_type STRING,
  -- Script name.
  name STRING,
  -- Actual contents of the script.
  source STRING
) AS
SELECT
  id AS v8_js_script_id,
  v8_isolate_id,
  internal_script_id,
  script_type,
  name,
  source
FROM
  __intrinsic_v8_js_script;


-- Represents one WASM script.
CREATE PERFETTO VIEW v8_wasm_script (
  -- Unique V8 WASM script id.
  v8_wasm_script_id LONG,
  -- V8 Isolate this script belongs to (joinable with
  -- `v8_isolate.v8_isolate_id`).
  v8_isolate_id LONG,
  -- Script id used by the V8 engine.
  internal_script_id LONG,
  -- URL of the source.
  url STRING,
  -- Actual contents of the script.
  source STRING
) AS
SELECT
  id AS v8_wasm_script_id,
  v8_isolate_id,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  internal_script_id,
  url,
  source
FROM
  __intrinsic_v8_wasm_script;


-- Represents a v8 Javascript function.
CREATE PERFETTO VIEW v8_js_function (
  -- Unique V8 JS function id.
  v8_js_function_id LONG,
  -- Function name.
  name STRING,
  -- Script where the function is defined (joinable with
  -- `v8_js_script.v8_js_script_id`).
  v8_js_script_id LONG,
  -- Whether this function represents the top level script.
  is_toplevel BOOL,
  -- Function kind (e.g. regular function or constructor).
  kind STRING,
  -- Line in script where function is defined. Starts at 1.
  line LONG,
  -- Column in script where function is defined. Starts at 1.
  col LONG
) AS
SELECT
  id AS v8_js_function_id,
  name,
  v8_js_script_id,
  is_toplevel,
  kind,
  line,
  col
FROM
  __intrinsic_v8_js_function;


-- Represents a v8 code snippet for a Javascript function. A given function can
-- have multiple code snippets (e.g. for different compilation tiers, or as the
-- function moves around the heap).
-- TODO(carlscab): Make public once `_jit_code` is public too
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO VIEW _v8_js_code(
  -- Unique id
  id LONG,
  -- Associated jit code. Set for all tiers except IGNITION. Joinable with
  -- `_jit_code.jit_code_id`.
  jit_code_id LONG,
  -- JS function for this snippet. Joinable with
  -- `v8_js_function.v8_js_function_id`.
  v8_js_function_id LONG,
  -- Compilation tier
  tier STRING,
  -- V8 VM bytecode. Set only for the IGNITION tier.
  bytecode BYTES
) AS
SELECT
  id,
  jit_code_id,
  v8_js_function_id,
  tier,
  base64_decode(bytecode_base64) AS bytecode
FROM
  __intrinsic_v8_js_code;


-- Represents a v8 code snippet for a v8 internal function.
-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_internal_code(
  -- Unique id
  id LONG,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id LONG,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id LONG,
  -- Function name.
  function_name STRING,
  -- Type of internal code.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  code_type STRING
) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  function_name,
  code_type
FROM
  __intrinsic_v8_internal_code;

-- Represents the code associated to a WASM function.
-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_wasm_code(
  -- Unique id
  id LONG,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id LONG,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id LONG,
  -- Script where the function is defined. Joinable with
  -- `v8_wasm_script.v8_wasm_script_id`.
  v8_wasm_script_id LONG,
  -- Function name.
  function_name STRING,
  -- Compilation tier.
  tier STRING,
  -- Offset into the WASM module where the function starts.
  code_offset_in_module LONG
 ) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  v8_wasm_script_id,
  function_name,
  tier,
  code_offset_in_module
FROM
  __intrinsic_v8_wasm_code;

-- Represents the code associated to a regular expression
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- TODO(carlscab): Make public once `_jit_code` is public too
CREATE PERFETTO VIEW _v8_regexp_code(
  -- Unique id
  id LONG,
  -- Associated jit code. Joinable with `_jit_code.jit_code_id`.
  jit_code_id LONG,
  -- V8 Isolate this code was created in. Joinable with
  -- `v8_isolate.v8_isolate_id`.
  v8_isolate_id LONG,
  -- The pattern the this regular expression was compiled from.
  pattern STRING
) AS
SELECT
  id,
  jit_code_id,
  v8_isolate_id,
  pattern
FROM
  __intrinsic_v8_regexp_code;

)_d3l1m1t3r_"
;

const char kVizSummaryCounters[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _counter_track_summary AS
WITH distinct_ids AS (
  SELECT DISTINCT track_id as id
  FROM counter
)
SELECT
  distinct_ids.id,
  COALESCE(SUM(
    args.key = 'upid'
    OR args.key = 'utid'
    OR args.key = 'cpu'
    OR args.key = 'gpu'
  ), 0) = 0 AS is_legacy_global
FROM distinct_ids
JOIN counter_track USING (id)
LEFT JOIN args ON counter_track.dimension_arg_set_id = args.arg_set_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(GROUP BY distinct_ids.id;

)_d3l1m1t3r_"
;

const char kVizSummaryProcesses[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;
INCLUDE PERFETTO MODULE viz.summary.threads;

CREATE PERFETTO TABLE _process_track_summary AS
SELECT upid, SUM(cnt) AS slice_count
FROM process_track
JOIN _slice_track_summary USING (id)
GROUP BY upid;

CREATE PERFETTO TABLE _heap_profile_allocation_summary AS
SELECT upid, COUNT() AS allocation_count
FROM heap_profile_allocation
GROUP BY upid;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _heap_profile_graph_summary AS
SELECT upid, COUNT() AS graph_object_count
FROM heap_graph_object
GROUP BY upid;

CREATE PERFETTO TABLE _thread_process_grouped_summary AS
SELECT
  upid,
  MAX(max_running_dur) AS max_running_dur,
  SUM(sum_running_dur) AS sum_running_dur,
  SUM(running_count) AS running_count,
  SUM(slice_count) AS slice_count,
  SUM(perf_sample_count) AS perf_sample_count
FROM _thread_available_info_summary
JOIN thread USING (utid)
WHERE upid IS NOT NULL
GROUP BY upid;

CREATE PERFETTO TABLE _process_available_info_summary AS
WITH r AS (
  SELECT
    upid,
    t_summary.upid as summary_upid,
    t_summary.max_running_dur AS max_running_dur,
    t_summary.sum_running_dur,
    t_summary.running_count,
    t_summary.slice_count AS thread_slice_count,
    t_summary.perf_sample_count AS perf_sample_count,
    (
      SELECT slice_count
      FROM _process_track_summary
      WHERE upid = p.upid
    ) AS process_slice_count,
    (
      SELECT allocation_count
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM _heap_profile_allocation_summary
      WHERE upid = p.upid
    ) AS allocation_count,
    (
      SELECT graph_object_count
      FROM _heap_profile_graph_summary
      WHERE upid = p.upid
    ) AS graph_object_count
  FROM process p
  LEFT JOIN _thread_process_grouped_summary t_summary USING (upid)
)
SELECT
  upid,
  IFNULL(max_running_dur, 0) AS max_running_dur,
  IFNULL(sum_running_dur, 0) AS sum_running_dur,
  IFNULL(running_count, 0) AS running_count,
  IFNULL(thread_slice_count, 0) AS thread_slice_count,
  IFNULL(perf_sample_count, 0) AS perf_sample_count,
  IFNULL(process_slice_count, 0) AS process_slice_count,
  IFNULL(allocation_count, 0) AS allocation_count,
  IFNULL(graph_object_count, 0) AS graph_object_count
FROM r
WHERE
  NOT(
    r.summary_upid IS NULL
    AND process_slice_count IS NULL
    AND allocation_count IS NULL
    AND graph_object_count IS NULL
  )
  OR upid IN (SELECT upid FROM process_counter_track);

)_d3l1m1t3r_"
;

const char kVizSummarySlices[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE PERFETTO TABLE _slice_track_summary AS
SELECT
  track_id as id,
  COUNT() AS cnt,
  MIN(dur) AS min_dur,
  MAX(dur) AS max_dur,
  MAX(depth) AS max_depth
FROM slice
GROUP BY track_id;

)_d3l1m1t3r_"
;

const char kVizSummaryThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;

CREATE PERFETTO TABLE _sched_summary AS
SELECT
  utid,
  MAX(dur) AS max_running_dur,
  SUM(dur) AS sum_running_dur,
  COUNT() AS running_count
FROM sched
WHERE utid != 0 AND dur != -1
GROUP BY utid;

CREATE PERFETTO TABLE _thread_track_summary AS
SELECT utid, SUM(cnt) AS slice_count
FROM thread_track
JOIN _slice_track_summary USING (id)
GROUP BY utid;
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _perf_sample_summary AS
SELECT utid, count() AS perf_sample_cnt
FROM perf_sample
WHERE callsite_id IS NOT NULL
GROUP BY utid;

CREATE PERFETTO TABLE _thread_available_info_summary AS
WITH raw AS (
  SELECT
    utid,
    ss.max_running_dur,
    ss.sum_running_dur,
    ss.running_count,
    (
      SELECT slice_count
      FROM _thread_track_summary
      WHERE utid = t.utid
    ) AS slice_count,
    (
      SELECT perf_sample_cnt
      FROM _perf_sample_summary
      WHERE utid = t.utid
    ) AS perf_sample_count
  FROM thread t
  LEFT JOIN _sched_summary ss USING (utid)
)
SELECT
  utid,
  IFNULL(max_running_dur, 0) AS max_running_dur,
  IFNULL(sum_running_dur, 0) AS sum_running_dur,
  IFNULL(running_count, 0) AS running_count,
  IFNULL(slice_count, 0) AS slice_count,
  IFNULL(perf_sample_count, 0) AS perf_sample_count
FROM raw r
WHERE
  NOT (
    r.max_running_dur IS NULL
    AND r.sum_running_dur IS NULL
    AND r.running_count IS NULL
    AND r.slice_count IS NULL
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    AND r.perf_sample_count IS NULL
  )
  OR utid IN (SELECT utid FROM cpu_profile_stack_sample)
  OR utid IN (SELECT utid FROM thread_counter_track);

)_d3l1m1t3r_"
;

const char kVizSummaryThreadsWProcesses[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.process_metadata;

-- Establish relationships between thread and process
CREATE PERFETTO TABLE _thread_process_summary AS
SELECT
  thread.utid,
  thread.upid,
  thread.tid,
  process.pid,
  thread.name as thread_name,
  process.name as process_name
FROM thread
LEFT JOIN process USING (upid);

-- Add thread_state info to thread/process/package
CREATE PERFETTO TABLE _state_w_thread_process_summary AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  thread_state.ts,
  thread_state.dur,
  thread_state.cpu,
  thread_state.state,
  m.utid,
  m.upid,
  m.tid,
  m.pid,
  m.thread_name,
  m.process_name
FROM _thread_process_summary as m
JOIN thread_state USING (utid);

-- Add scheduling slices info to thread/process/package
CREATE PERFETTO TABLE _sched_w_thread_process_package_summary AS
SELECT
  sched.ts,
  sched.dur,
  sched.cpu,
  m.utid,
  m.upid,
  m.tid,
  m.pid,
  package.uid,
  m.thread_name,
  m.process_name,
  package.package_name
FROM _thread_process_summary as m
JOIN sched USING (utid)
LEFT JOIN android_process_metadata as package USING(upid)
WHERE dur > 0;

)_d3l1m1t3r_"
;

const char kVizSummaryTrace[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Returns 1 if trace is linux trace and 0 otherwise.
CREATE PERFETTO FUNCTION _is_linux_trace() RETURNS LONG AS
SELECT count() == 1
FROM metadata
WHERE name = 'system_name' AND str_value = 'Linux';
)_d3l1m1t3r_"
;

const char kVizSummaryTracks[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE viz.summary.slices;

CREATE PERFETTO VIEW _track_event_tracks_unordered AS
WITH extracted AS (
  SELECT
    t.id,
    t.parent_id,
    t.name,
    EXTRACT_ARG(t.source_arg_set_id, 'child_ordering') AS ordering,
    EXTRACT_ARG(t.source_arg_set_id, 'sibling_order_rank') AS rank
  FROM track t
)
SELECT
  t.id,
  t.parent_id,
  t.name,
  t.ordering,
  p.ordering AS parent_ordering,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IFNULL(t.rank, 0) AS rank
FROM extracted t
LEFT JOIN extracted p ON t.parent_id = p.id
WHERE p.ordering IS NOT NULL;

CREATE PERFETTO TABLE _track_event_tracks_ordered AS
WITH lexicographic_and_none AS (
  SELECT
    id, parent_id, name,
    ROW_NUMBER() OVER (ORDER BY parent_id, name) AS order_id
  FROM _track_event_tracks_unordered
  WHERE parent_ordering = 'lexicographic'
),
explicit AS (
SELECT
  id, parent_id, name,
  ROW_NUMBER() OVER (ORDER BY parent_id, rank) AS order_id
FROM _track_event_tracks_unordered
WHERE parent_ordering = 'explicit'
),
slice_chronological AS (
  SELECT
    t.*,
    min(ts) AS min_ts
  FROM _track_event_tracks_unordered t
  JOIN slice s on t.id = s.track_id
  WHERE parent_ordering = 'chronological'
  GROUP BY track_id
),
counter_chronological AS (
  SELECT
    t.*,
    min(ts) AS min_ts
  FROM _track_event_tracks_unordered t
  JOIN counter s on t.id = s.track_id
  WHERE parent_ordering = 'chronological'
  GROUP BY track_id
),
slice_and_counter_chronological AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT t.*, u.min_ts
  FROM _track_event_tracks_unordered t
  LEFT JOIN (
    SELECT * FROM slice_chronological
    UNION ALL
    SELECT * FROM counter_chronological) u USING (id)
  WHERE t.parent_ordering = 'chronological'
),
chronological AS (
  SELECT
    id, parent_id, name,
    ROW_NUMBER() OVER (ORDER BY parent_id, min_ts) AS order_id
  FROM slice_and_counter_chronological
),
all_tracks AS (
  SELECT id, parent_id, name, order_id
  FROM lexicographic_and_none
  UNION
  SELECT id, parent_id, name, order_id
  FROM explicit
  UNION
  SELECT id, parent_id, name, order_id
  FROM chronological
)
SELECT id, order_id
FROM all_tracks all_t
ORDER BY parent_id, order_id;

CREATE PERFETTO TABLE _thread_track_summary_by_utid_and_name AS
SELECT
  utid,
  parent_id,
  name,
  -- Only meaningful when track_count == 1.
  id as track_id,
  -- Only meaningful when track_count == 1.
  max_depth as max_depth,
  GROUP_CONCAT(id) AS track_ids,
  COUNT() AS track_count
FROM thread_track
JOIN _slice_track_summary USING (id)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN _track_event_tracks_ordered USING (id)
GROUP BY utid, parent_id, order_id, name;

CREATE PERFETTO TABLE _process_track_summary_by_upid_and_parent_id_and_name AS
SELECT
  id,
  parent_id,
  upid,
  name,
  GROUP_CONCAT(id) AS track_ids,
  COUNT() AS track_count
FROM process_track
JOIN _slice_track_summary USING (id)
LEFT JOIN _track_event_tracks_ordered USING (id)
GROUP BY upid, parent_id, order_id, name;
)_d3l1m1t3r_"
;

const char kVizFlamegraph[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.scan;

CREATE PERFETTO MACRO _viz_flamegraph_hash_coalesce(col ColumnName)
RETURNS _SqlFragment AS IFNULL($col, 0);

-- For each frame in |tab|, returns a row containing the result of running
-- all the filtering operations over that frame's name.
CREATE PERFETTO MACRO _viz_flamegraph_prepare_filter(
  tab TableOrSubquery,
  show_stack Expr,
  hide_stack Expr,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  show_from_frame Expr,
  hide_frame Expr,
  pivot Expr,
  impossible_stack_bits Expr,
  grouping _ColumnNameList
)
RETURNS TableOrSubquery
AS (
  SELECT
    *,
    IIF($hide_stack, $impossible_stack_bits, $show_stack) AS stackBits,
    $show_from_frame As showFromFrameBits,
    $hide_frame = 0 AS showFrame,
    $pivot AS isPivot,
    HASH(
      name,
      __intrinsic_token_apply!(_viz_flamegraph_hash_coalesce, $grouping)
    ) AS groupingHash
  FROM $tab
  ORDER BY id
);

-- Walks the forest from root to leaf and performs the following operations:
--  1) removes frames which were filtered out
--  2) make any pivot nodes become the roots
--  3) computes whether the stack as a whole should be retained or not
CREATE PERFETTO MACRO _viz_flamegraph_filter_frames(
  source TableOrSubquery,
  show_from_frame_bits Expr
)
RETURNS TableOrSubquery
AS (
  WITH edges AS (
    SELECT parentId AS source_node_id, id AS dest_node_id
    FROM $source
    WHERE parentId IS NOT NULL
  ),
  inits AS (
    SELECT
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      id,
      IIF(
        showFrame AND showFromFrameBits = $show_from_frame_bits,
        id,
        NULL
      ) AS filteredId,
      NULL AS filteredParentId,
      NULL AS filteredUnpivotedParentId,
      IIF(
        showFrame,
        showFromFrameBits,
        0
      ) AS showFromFrameBits,
      IIF(
        showFrame AND showFromFrameBits = $show_from_frame_bits,
        stackBits,
        0
      ) AS stackBits
    FROM $source
    WHERE parentId IS NULL
  )
  SELECT
    g.filteredId AS id,
    g.filteredParentId AS parentId,
    g.filteredUnpivotedParentId AS unpivotedParentId,
    g.stackBits,
    SUM(t.value) AS value
  FROM _graph_scan!(
    edges,
    inits,
    (filteredId, filteredParentId, filteredUnpivotedParentId, showFromFrameBits, stackBits),
    (
      SELECT
        t.id,
        IIF(
          x.showFrame AND (t.showFromFrameBits | x.showFromFrameBits) = $show_from_frame_bits,
          t.id,
          t.filteredId
        ) AS filteredId,
        IIF(
          x.showFrame AND (t.showFromFrameBits | x.showFromFrameBits) = $show_from_frame_bits,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(          IIF(x.isPivot, NULL, t.filteredId),
          t.filteredParentId
        ) AS filteredParentId,
        IIF(
          x.showFrame AND (t.showFromFrameBits | x.showFromFrameBits) = $show_from_frame_bits,
          t.filteredId,
          t.filteredParentId
        ) AS filteredUnpivotedParentId,
        IIF(
          x.showFrame,
          (t.showFromFrameBits | x.showFromFrameBits),
          t.showFromFrameBits
        ) AS showFromFrameBits,
        IIF(
          x.showFrame AND (t.showFromFrameBits | x.showFromFrameBits) = $show_from_frame_bits,
          (t.stackBits | x.stackBits),
          t.stackBits
        ) AS stackBits
      FROM $table t
      JOIN $source x USING (id)
    )
  ) g
  JOIN $source t USING (id)
  WHERE filteredId IS NOT NULL
  GROUP BY filteredId
  ORDER BY filteredId
);

-- Walks the forest from leaves to root and does the following:
--   1) removes nodes whose stacks are filtered out
--   2) computes the cumulative value for each node (i.e. the sum of the self
)_d3l1m1t3r_"
R"_d3l1m1t3r_(--      value of the node and all descendants).
CREATE PERFETTO MACRO _viz_flamegraph_accumulate(
  filtered TableOrSubquery,
  showStackBits Expr
)
RETURNS TableOrSubquery
AS (
  WITH edges AS (
    SELECT id AS source_node_id, parentId AS dest_node_id
    FROM $filtered
    WHERE parentId IS NOT NULL
  ), inits AS (
    SELECT f.id, f.value AS cumulativeValue
    FROM $filtered f
    LEFT JOIN $filtered c ON c.parentId = f.id
    WHERE c.id IS NULL AND f.stackBits = $showStackBits
  )
  SELECT id, cumulativeValue
  FROM _graph_aggregating_scan!(
    edges,
    inits,
    (cumulativeValue),
    (
      SELECT
        x.id,
        x.childValue + IIF(
          t.stackBits = $showStackBits,
          t.value,
          0
        ) AS cumulativeValue
      FROM (
        SELECT id, SUM(cumulativeValue) AS childValue
        FROM $table
        GROUP BY id
      ) x
      JOIN $filtered t USING (id)
    )
  )
  ORDER BY id
);

CREATE PERFETTO MACRO _viz_flamegraph_s_prefix(col ColumnName)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS _SqlFragment AS s.$col;

-- Propogates the cumulative value of the pivot nodes to the roots
-- and computes the "fingerprint" of the path.
CREATE PERFETTO MACRO _viz_flamegraph_upwards_hash(
  source TableOrSubquery,
  filtered TableOrSubquery,
  accumulated TableOrSubquery,
  grouping _ColumnNameList,
  grouped _ColumnNameList
)
RETURNS TableOrSubquery
AS (
  WITH edges AS (
    SELECT id AS source_node_id, unpivotedParentId AS dest_node_id
    FROM $filtered
    WHERE unpivotedParentId IS NOT NULL
  ),
  inits AS (
    SELECT
      f.id,
      HASH(-1, s.groupingHash) AS hash,
      NULL AS parentHash,
      -1 AS depth,
      a.cumulativeValue
    FROM $filtered f
    JOIN $source s USING (id)
    JOIN $accumulated a USING (id)
    WHERE s.isPivot AND a.cumulativeValue > 0
  )
  SELECT
    g.id,
    g.hash,
    g.parentHash,
    g.depth,
    s.name,
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouping),
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouped),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    f.value,
    g.cumulativeValue
  FROM _graph_scan!(
    edges,
    inits,
    (hash, parentHash, depth, cumulativeValue),
    (
      SELECT
        t.id,
        HASH(t.hash, x.groupingHash) AS hash,
        t.hash AS parentHash,
        t.depth - 1 AS depth,
        t.cumulativeValue
      FROM $table t
      JOIN $source x USING (id)
    )
  ) g
  JOIN $source s USING (id)
  JOIN $filtered f USING (id)
);

-- Computes the "fingerprint" of the path by walking from the laves
-- to the root.
CREATE PERFETTO MACRO _viz_flamegraph_downwards_hash(
  source TableOrSubquery,
  filtered TableOrSubquery,
  accumulated TableOrSubquery,
  grouping _ColumnNameList,
  grouped _ColumnNameList,
  showDownward Expr
)
RETURNS TableOrSubquery
AS (
  WITH
    edges AS (
      SELECT parentId AS source_node_id, id AS dest_node_id
      FROM $filtered
      WHERE parentId IS NOT NULL
    ),
    inits AS (
      SELECT
        f.id,
        HASH(1, s.groupingHash) AS hash,
        NULL AS parentHash,
        1 AS depth
)_d3l1m1t3r_"
R"_d3l1m1t3r_(      FROM $filtered f
      JOIN $source s USING (id)
      WHERE f.parentId IS NULL AND $showDownward
    )
  SELECT
    g.id,
    g.hash,
    g.parentHash,
    g.depth,
    s.name,
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouping),
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouped),
    f.value,
    a.cumulativeValue
  FROM _graph_scan!(
    edges,
    inits,
    (hash, parentHash, depth),
    (
      SELECT
        t.id,
        HASH(t.hash, x.groupingHash) AS hash,
        t.hash AS parentHash,
        t.depth + 1 AS depth
      FROM $table t
      JOIN $source x USING (id)
    )
  ) g
  JOIN $source s USING (id)
  JOIN $filtered f USING (id)
  JOIN $accumulated a USING (id)
  ORDER BY hash
);

CREATE PERFETTO MACRO _col_list_id(a ColumnName)
RETURNS _SqlFragment AS $a;

-- Converts a table of hashes and paretn hashes into ids and parent
-- ids, grouping all hashes together.
CREATE PERFETTO MACRO _viz_flamegraph_merge_hashes(
  hashed TableOrSubquery,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  grouping _ColumnNameList,
  grouped_agged_exprs _ColumnNameList
)
RETURNS TableOrSubquery
AS (
  SELECT
    _auto_id AS id,
    (
      SELECT p._auto_id
      FROM $hashed p
      WHERE p.hash = c.parentHash
      LIMIT 1
    ) AS parentId,
    depth,
    name,
    -- The grouping columns should be passed through as-is because the
    -- hash took them into account: we would not merged any nodes where
    -- the grouping columns were different.
    __intrinsic_token_apply!(_col_list_id, $grouping),
    __intrinsic_token_apply!(_col_list_id, $grouped_agged_exprs),
    SUM(value) AS value,
    SUM(cumulativeValue) AS cumulativeValue
  FROM $hashed c
  GROUP BY hash
);

-- Performs a "layout" of nodes in the flamegraph relative to their
-- siblings.
CREATE PERFETTO MACRO _viz_flamegraph_local_layout(
  merged TableOrSubquery
)
RETURNS TableOrSubquery
AS (
  WITH partial_layout AS (
    SELECT
      id,
      cumulativeValue,
      SUM(cumulativeValue) OVER win AS xEnd
    FROM $merged
    WHERE cumulativeValue > 0
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WINDOW win AS (
      PARTITION BY parentId, depth
      ORDER BY cumulativeValue DESC
      ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    )
  )
  SELECT id, xEnd - cumulativeValue as xStart, xEnd
  FROM partial_layout
  ORDER BY id
);

-- Walks the graph from root to leaf, propogating the layout of
-- parents to their children.
CREATE PERFETTO MACRO _viz_flamegraph_global_layout(
  merged TableOrSubquery,
  layout TableOrSubquery,
  grouping _ColumnNameList,
  grouped _ColumnNameList
)
RETURNS TableOrSubquery
AS (
  WITH edges AS (
    SELECT parentId AS source_node_id, id AS dest_node_id
    FROM $merged
    WHERE parentId IS NOT NULL
  ),
  inits AS (
    SELECT h.id, 1 AS rootDistance, l.xStart, l.xEnd
    FROM $merged h
    JOIN $layout l USING (id)
    WHERE h.parentId IS NULL
  )
  SELECT
    s.id,
    IFNULL(s.parentId, -1) AS parentId,
    IIF(s.name = '', 'unknown', s.name) AS name,
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouping),
    __intrinsic_token_apply!(_viz_flamegraph_s_prefix, $grouped),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    s.value AS selfValue,
    s.cumulativeValue,
    p.cumulativeValue AS parentCumulativeValue,
    s.depth,
    g.xStart,
    g.xEnd
  FROM _graph_scan!(
    edges,
    inits,
    (rootDistance, xStart, xEnd),
    (
      SELECT
        t.id,
        t.rootDistance + 1 as rootDistance,
        t.xStart + w.xStart AS xStart,
        t.xStart + w.xEnd AS xEnd
      FROM $table t
      JOIN $layout w USING (id)
    )
  ) g
  JOIN $merged s USING (id)
  LEFT JOIN $merged p ON s.parentId = p.id
  ORDER BY rootDistance, xStart
);

)_d3l1m1t3r_"
;

const char kVizSlices[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE graphs.scan;

CREATE PERFETTO MACRO _viz_slice_ancestor_agg(
  inits TableOrSubquery
)
RETURNS TableOrSubquery
AS
(
  SELECT id, parent_id AS parentId, name, self_dur, self_count
  FROM _graph_aggregating_scan!(
    (
      SELECT id AS source_node_id, parent_id AS dest_node_id
      FROM slice
      WHERE parent_id IS NOT NULL
    ),
    (SELECT id, dur, dur AS self_dur, 1 AS self_count FROM $inits),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    (dur, self_dur, self_count),
    (
      WITH agg AS (
        SELECT t.id, sum(t.dur) AS child_dur
        FROM $table t
        GROUP BY id
      )
      SELECT a.id, s.dur, s.dur - a.child_dur AS self_dur, 0 AS self_count
      FROM agg a
      JOIN slice s USING (id)
    )
  ) g
  JOIN slice s USING (id)
);

)_d3l1m1t3r_"
;

const char kVizThreads[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.threads;
INCLUDE PERFETTO MODULE viz.summary.trace;

-- Create a new table containing the utids of all the kernel threads.
-- Right now this table only supports linux traces. On all other traces the
-- resultant table will be empty.
CREATE PERFETTO TABLE _kernel_threads AS
SELECT
  utid
FROM linux_kernel_threads
WHERE _is_linux_trace() = 1;

CREATE PERFETTO TABLE _threads_with_kernel_flag AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT
  id,
  utid,
  upid,
  tid,
  name,
  is_main_thread,
  machine_id,
  utid IN (SELECT utid FROM _kernel_threads) AS is_kernel_thread
FROM thread

)_d3l1m1t3r_"
;

const char kWattsonArmDsu[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Converts event counter from count to rate (num of accesses per ns).
CREATE PERFETTO FUNCTION _get_rate(event STRING)
RETURNS TABLE(ts TIMESTAMP, dur DURATION, access_rate LONG)
AS
SELECT
  ts,
  lead(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts AS dur,
  -- Rate of event accesses in a section (i.e. count / dur).
  value / (lead(ts) OVER (PARTITION BY track_id ORDER BY ts) - ts) AS access_rate
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM counter AS c
JOIN counter_track AS t
  ON c.track_id = t.id
WHERE t.name = $event;

-- The rate of L3 misses for each time slice based on the ARM DSU PMU counter's
-- bus_access event. Units will be in number of L3 misses per ns. The number of
-- accesses in a given duration can be calculated by multiplying the appropriate
-- rate with the time in the window of interest.
CREATE PERFETTO TABLE _arm_l3_miss_rate
AS
SELECT
  ts, dur, access_rate AS l3_miss_rate
FROM _get_rate("arm_dsu_0/bus_access/_cpu0");

-- The rate of L3 accesses for each time slice based on the ARM DSU PMU
-- counter's l3d_cache event. Units will be in number of DDR accesses per ns.
-- The number of accesses in a given duration can be calculated by multiplying
-- the appropriate rate with the time in the window of interest.
CREATE PERFETTO TABLE _arm_l3_hit_rate
AS
SELECT
  ts, dur, access_rate AS l3_hit_rate
FROM _get_rate("arm_dsu_0/l3d_cache/_cpu0");


)_d3l1m1t3r_"
;

const char kWattsonCpuFreq[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE linux.cpu.frequency;
INCLUDE PERFETTO MODULE wattson.device_infos;

CREATE PERFETTO TABLE _adjusted_cpu_freq AS
  WITH _cpu_freq AS (
    SELECT
      ts,
      dur,
      freq,
      cf.ucpu as cpu,
      d_map.policy
    FROM cpu_frequency_counters as cf
    JOIN _dev_cpu_policy_map as d_map
    ON cf.ucpu = d_map.cpu
  ),
  -- Get first freq transition per CPU
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  first_cpu_freq_slices AS (
    SELECT ts, cpu FROM _cpu_freq
    GROUP BY cpu
    ORDER by ts ASC
  )
-- Prepend NULL slices up to first freq events on a per CPU basis
SELECT
  -- Construct slices from first cpu ts up to first freq event for each cpu
  trace_start() as ts,
  first_slices.ts - trace_start() as dur,
  NULL as freq,
  first_slices.cpu,
  d_map.policy
FROM first_cpu_freq_slices as first_slices
JOIN _dev_cpu_policy_map as d_map ON first_slices.cpu = d_map.cpu
UNION ALL
SELECT
  ts,
  dur,
  freq,
  cpu,
  policy
FROM _cpu_freq
UNION ALL
-- Add empty cpu freq counters for CPUs that are physically present, but did not
-- have a single freq event register. The time region needs to be defined so
-- that interval_intersect doesn't remove the undefined time region.
SELECT
  trace_start() as ts,
  trace_dur() as dur,
  NULL as freq,
  cpu,
  NULL as policy
FROM _dev_cpu_policy_map
WHERE cpu NOT IN (SELECT cpu FROM first_cpu_freq_slices);

)_d3l1m1t3r_"
;

const char kWattsonCpuFreqIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE wattson.cpu_freq;
INCLUDE PERFETTO MODULE wattson.cpu_idle;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- Helper macro for using Perfetto table with interval intersect
CREATE PERFETTO MACRO _ii_subquery(tab TableOrSubquery)
RETURNS TableOrSubquery AS (SELECT _auto_id AS id, * FROM $tab);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
-- Wattson estimation is valid from when first CPU0 frequency appears
CREATE PERFETTO TABLE _valid_window
AS
WITH window_start AS (
  SELECT ts as start_ts
  FROM _adjusted_cpu_freq
  WHERE cpu = 0 AND freq IS NOT NULL
  ORDER BY ts ASC
  LIMIT 1
),
window AS (
  SELECT start_ts as ts, trace_end() - start_ts as dur
  FROM window_start
)
SELECT *, 0 as cpu FROM window
UNION ALL
SELECT *, 1 as cpu FROM window
UNION ALL
SELECT *, 2 as cpu FROM window
UNION ALL
SELECT *, 3 as cpu FROM window
UNION ALL
SELECT *, 4 as cpu FROM window
UNION ALL
SELECT *, 5 as cpu FROM window
UNION ALL
SELECT *, 6 as cpu FROM window
UNION ALL
SELECT *, 7 as cpu FROM window;

-- Start matching CPUs with 1D curves based on combination of freq and idle
CREATE PERFETTO TABLE _idle_freq_materialized
AS
SELECT
  ii.ts, ii.dur, ii.cpu, freq.policy, freq.freq, idle.idle, lut.curve_value
FROM _interval_intersect!(
  (
    _ii_subquery!(_valid_window),
    _ii_subquery!(_adjusted_cpu_freq),
    _ii_subquery!(_adjusted_deep_idle)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ),
  (cpu)
) ii
JOIN _adjusted_cpu_freq AS freq ON freq._auto_id = id_1
JOIN _adjusted_deep_idle AS idle ON idle._auto_id = id_2
-- Left join since some CPUs may only match the 2D LUT
LEFT JOIN _filtered_curves_1d lut ON
  freq.policy = lut.policy AND
  freq.freq = lut.freq_khz AND
  idle.idle = lut.idle;


)_d3l1m1t3r_"
;

const char kWattsonCpuIdle[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE counters.intervals;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- Get the corresponding deep idle time offset based on device and CPU.
CREATE PERFETTO VIEW _filtered_deep_idle_offsets AS
SELECT cpu, offset_ns
FROM _device_cpu_deep_idle_offsets as offsets
JOIN _wattson_device as device
ON offsets.device = device.name;

-- Adjust duration of active portion to be slightly longer to account for
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- overhead cost of transitioning out of deep idle. This is done because the
-- device is active and consumes power for longer than the logs actually report.
CREATE PERFETTO TABLE _adjusted_deep_idle AS
WITH
  idle_prev AS (
    SELECT
      ts,
      LAG(ts, 1, trace_start()) OVER (PARTITION BY cpu ORDER by ts) as prev_ts,
      value AS idle,
      cli.value - cli.delta_value AS idle_prev,
      cct.cpu
    -- Same as cpu_idle_counters, but extracts some additional info that isn't
    -- nominally present in cpu_idle_counters, such that the already calculated
    -- lag values are reused instead of recomputed
    FROM counter_leading_intervals!((
      SELECT c.*
      FROM counter c
      JOIN cpu_counter_track cct ON cct.id = c.track_id AND cct.name = 'cpuidle'
    )) AS cli
    JOIN cpu_counter_track AS cct ON cli.track_id = cct.id
  ),
  -- Adjusted ts if applicable, which makes the current active state longer if
  -- it is coming from an idle exit.
  idle_mod AS (
    SELECT
      IIF(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(        idle_prev = 1 AND idle = 4294967295,
        -- extend ts backwards by offset_ns at most up to prev_ts
        MAX(ts - offset_ns, prev_ts),
        ts
      ) as ts,
      cpu,
      idle
    FROM idle_prev
    JOIN _filtered_deep_idle_offsets USING (cpu)
  ),
  _cpu_idle AS (
    SELECT
      ts,
      LEAD(ts, 1, trace_end()) OVER (PARTITION BY cpu ORDER by ts) - ts as dur,
      cpu,
      cast_int!(IIF(idle = 4294967295, -1, idle)) AS idle
    FROM idle_mod
  ),
  -- Get first idle transition per CPU
  first_cpu_idle_slices AS (
    SELECT ts, cpu FROM _cpu_idle
    GROUP BY cpu
    ORDER by ts ASC
  )
-- Prepend NULL slices up to first idle events on a per CPU basis
SELECT
  -- Construct slices from first cpu ts up to first freq event for each cpu
  trace_start() as ts,
  first_slices.ts - trace_start() as dur,
  first_slices.cpu,
  NULL as idle
FROM first_cpu_idle_slices as first_slices
WHERE dur > 0
UNION ALL
SELECT
  ts,
  dur,
  cpu,
  idle
FROM _cpu_idle
-- Some durations are 0 post-adjustment and won't work with interval intersect
)_d3l1m1t3r_"
R"_d3l1m1t3r_(WHERE dur > 0
UNION ALL
-- Add empty cpu idle counters for CPUs that are physically present, but did not
-- have a single idle event register. The time region needs to be defined so
-- that interval_intersect doesn't remove the undefined time region.
SELECT
  trace_start() as ts,
  trace_dur() as dur,
  cpu,
  NULL as idle
FROM _dev_cpu_policy_map
WHERE cpu NOT IN (SELECT cpu FROM first_cpu_idle_slices);

)_d3l1m1t3r_"
;

const char kWattsonCpuSplit[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.suspend;
INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE time.conversion;
INCLUDE PERFETTO MODULE wattson.arm_dsu;
INCLUDE PERFETTO MODULE wattson.cpu_freq_idle;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- Helper macro to do pivot function without policy information
CREATE PERFETTO MACRO _stats_wo_policy_subquery(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  cpu Expr, curve_col ColumnName, freq_col ColumnName, idle_col ColumnName
)
RETURNS TableOrSubquery AS (
  SELECT
    ts,
    dur,
    curve_value as $curve_col,
    freq as $freq_col,
    idle as $idle_col
  FROM _idle_freq_materialized
  WHERE cpu = $cpu
);

-- Helper macro to do pivot function with policy information
CREATE PERFETTO MACRO _stats_w_policy_subquery(
  cpu Expr,
  policy_col ColumnName,
  curve_col ColumnName,
  freq_col ColumnName,
  idle_col ColumnName
)
RETURNS TableOrSubquery AS (
  SELECT
    ts,
    dur,
    policy AS $policy_col,
    curve_value as $curve_col,
    freq as $freq_col,
    idle as $idle_col
  FROM _idle_freq_materialized
  WHERE cpu = $cpu
);

CREATE PERFETTO TABLE _stats_cpu0 AS
SELECT * FROM _stats_wo_policy_subquery!(0, cpu0_curve, freq_0, idle_0);

CREATE PERFETTO TABLE _stats_cpu1 AS
SELECT * FROM _stats_wo_policy_subquery!(1, cpu1_curve, freq_1, idle_1);

CREATE PERFETTO TABLE _stats_cpu2 AS
SELECT * FROM _stats_wo_policy_subquery!(2, cpu2_curve, freq_2, idle_2);
)_d3l1m1t3r_"
R"_d3l1m1t3r_(
CREATE PERFETTO TABLE _stats_cpu3 AS
SELECT * FROM _stats_wo_policy_subquery!(3, cpu3_curve, freq_3, idle_3);

CREATE PERFETTO TABLE _stats_cpu4 AS
SELECT * FROM _stats_w_policy_subquery!(4, policy_4, cpu4_curve, freq_4, idle_4);

CREATE PERFETTO TABLE _stats_cpu5 AS
SELECT * FROM _stats_w_policy_subquery!(5, policy_5, cpu5_curve, freq_5, idle_5);

CREATE PERFETTO TABLE _stats_cpu6 AS
SELECT * FROM _stats_w_policy_subquery!(6, policy_6, cpu6_curve, freq_6, idle_6);

CREATE PERFETTO TABLE _stats_cpu7 AS
SELECT * FROM _stats_w_policy_subquery!(7, policy_7, cpu7_curve, freq_7, idle_7);

CREATE PERFETTO TABLE _stats_cpu0123_suspend AS
SELECT
  ii.ts,
  ii.dur,
  id_0 as cpu0_id, id_1 as cpu1_id, id_2 as cpu2_id, id_3 as cpu3_id,
  ss.power_state = 'suspended' as suspended
FROM _interval_intersect!(
  (
    _ii_subquery!(_stats_cpu0),
    _ii_subquery!(_stats_cpu1),
    _ii_subquery!(_stats_cpu2),
    _ii_subquery!(_stats_cpu3),
    -- Includes suspend AND awake portions, which will cover entire trace and
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    -- allows us to use _interval_intersect instead of SPAN_OUTER_JOIN()
    _ii_subquery!(android_suspend_state)
  ),
  ()
) as ii
JOIN android_suspend_state AS ss ON ss._auto_id = id_4;

CREATE PERFETTO TABLE _stats_cpu4567 AS
SELECT
  ii.ts,
  ii.dur,
  id_0 as cpu4_id, id_1 as cpu5_id, id_2 as cpu6_id, id_3 as cpu7_id
FROM _interval_intersect!(
  (
    _ii_subquery!(_stats_cpu4),
    _ii_subquery!(_stats_cpu5),
    _ii_subquery!(_stats_cpu6),
    _ii_subquery!(_stats_cpu7)
  ),
  ()
) as ii;

-- SPAN OUTER JOIN because sometimes CPU4/5/6/7 are empty tables
CREATE VIRTUAL TABLE _stats_cpu01234567_suspend
USING
  SPAN_OUTER_JOIN(_stats_cpu0123_suspend, _stats_cpu4567);

-- Combine system state so that it has idle, freq, and L3 hit info.
CREATE VIRTUAL TABLE _idle_freq_l3_hit_slice
USING
  SPAN_OUTER_JOIN(_stats_cpu01234567_suspend, _arm_l3_hit_rate);

-- Combine system state so that it has idle, freq, L3 hit, and L3 miss info.
CREATE VIRTUAL TABLE _idle_freq_l3_hit_l3_miss_slice
USING
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SPAN_OUTER_JOIN(_idle_freq_l3_hit_slice, _arm_l3_miss_rate);

-- Does calculations for CPUs that are independent of other CPUs or frequencies
-- This is the last generic table before going to device specific table calcs
CREATE PERFETTO TABLE _w_independent_cpus_calc
AS
SELECT
  base.ts,
  base.dur,
  cast_int!(l3_hit_rate * base.dur) as l3_hit_count,
  cast_int!(l3_miss_rate * base.dur) as l3_miss_count,
  freq_0,
  idle_0,
  freq_1,
  idle_1,
  freq_2,
  idle_2,
  freq_3,
  idle_3,
  freq_4,
  idle_4,
  freq_5,
  idle_5,
  freq_6,
  idle_6,
  freq_7,
  idle_7,
  policy_4,
  policy_5,
  policy_6,
  policy_7,
  IIF(
    suspended,
    1,
    MIN(
      IFNULL(idle_0, 1),
      IFNULL(idle_1, 1),
      IFNULL(idle_2, 1),
      IFNULL(idle_3, 1)
    )
  ) as no_static,
  IIF(suspended, 0.0, cpu0_curve) as cpu0_curve,
  IIF(suspended, 0.0, cpu1_curve) as cpu1_curve,
  IIF(suspended, 0.0, cpu2_curve) as cpu2_curve,
  IIF(suspended, 0.0, cpu3_curve) as cpu3_curve,
  IIF(suspended, 0.0, cpu4_curve) as cpu4_curve,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  IIF(suspended, 0.0, cpu5_curve) as cpu5_curve,
  IIF(suspended, 0.0, cpu6_curve) as cpu6_curve,
  IIF(suspended, 0.0, cpu7_curve) as cpu7_curve,
  -- If dependency CPUs are active, then that CPU could contribute static power
  IIF(idle_4 = -1, lut4.curve_value, -1) as static_4,
  IIF(idle_5 = -1, lut5.curve_value, -1) as static_5,
  IIF(idle_6 = -1, lut6.curve_value, -1) as static_6,
  IIF(idle_7 = -1, lut7.curve_value, -1) as static_7
FROM _idle_freq_l3_hit_l3_miss_slice as base
-- Get CPU power curves for CPUs guaranteed on device
JOIN _stats_cpu0 ON _stats_cpu0._auto_id = base.cpu0_id
JOIN _stats_cpu1 ON _stats_cpu1._auto_id = base.cpu1_id
JOIN _stats_cpu2 ON _stats_cpu2._auto_id = base.cpu2_id
JOIN _stats_cpu3 ON _stats_cpu3._auto_id = base.cpu3_id
-- Get CPU power curves for CPUs that aren't always present
LEFT JOIN _stats_cpu4 ON _stats_cpu4._auto_id = base.cpu4_id
LEFT JOIN _stats_cpu5 ON _stats_cpu5._auto_id = base.cpu5_id
LEFT JOIN _stats_cpu6 ON _stats_cpu6._auto_id = base.cpu6_id
)_d3l1m1t3r_"
R"_d3l1m1t3r_(LEFT JOIN _stats_cpu7 ON _stats_cpu7._auto_id = base.cpu7_id
-- Match power curves if possible on CPUs that decide 2D dependence
LEFT JOIN _filtered_curves_2d lut4 ON
  _stats_cpu0.freq_0 = lut4.freq_khz AND
  _stats_cpu4.policy_4 = lut4.other_policy AND
  _stats_cpu4.freq_4 = lut4.other_freq_khz AND
  lut4.idle = 255
LEFT JOIN _filtered_curves_2d lut5 ON
  _stats_cpu0.freq_0 = lut5.freq_khz AND
  _stats_cpu5.policy_5 = lut5.other_policy AND
  _stats_cpu5.freq_5 = lut5.other_freq_khz AND
  lut5.idle = 255
LEFT JOIN _filtered_curves_2d lut6 ON
  _stats_cpu0.freq_0 = lut6.freq_khz AND
  _stats_cpu6.policy_6 = lut6.other_policy AND
  _stats_cpu6.freq_6 = lut6.other_freq_khz AND
  lut6.idle = 255
LEFT JOIN _filtered_curves_2d lut7 ON
  _stats_cpu0.freq_0 = lut7.freq_khz AND
  _stats_cpu7.policy_7 = lut7.other_policy AND
  _stats_cpu7.freq_7 = lut7.other_freq_khz AND
  lut7.idle = 255
-- Needs to be at least 1us to reduce inconsequential rows.
WHERE base.dur > time_from_us(1);

)_d3l1m1t3r_"
;

const char kWattsonCurvesDevice[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Device specific device curves with 1D dependency (i.e. curve characteristics
-- are dependent only on one CPU policy). See go/wattson for more info.
CREATE PERFETTO TABLE _device_curves_1d
AS
WITH data(device, policy, freq_khz, static, active, idle0, idle1) AS (
  VALUES
  -- 255 represents static curve; needs to be same type as rest
  ("monaco", 0, 614400, 4.8, 9.41, 0.76, 0),
  ("monaco", 0, 864000, 6.68, 13.64, 0.83, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("monaco", 0, 1363200, 12.6, 24.83, 1.1, 0),
  ("monaco", 0, 1708800, 18.39, 39.69, 1.34, 0),
  ("Tensor", 4, 400000, 0, 28.51, 5.24, 0),
  ("Tensor", 4, 553000, 0, 43.63, 6.1, 0),
  ("Tensor", 4, 696000, 0, 54.73, 6.76, 0),
  ("Tensor", 4, 799000, 0, 65.01, 6.89, 0),
  ("Tensor", 4, 910000, 0, 80.33, 7.61, 0),
  ("Tensor", 4, 1024000, 0, 92.91, 8.32, 0),
  ("Tensor", 4, 1197000, 0, 132.46, 8.09, 0),
  ("Tensor", 4, 1328000, 0, 146.82, 9.6, 0),
  ("Tensor", 4, 1491000, 0, 183.2, 11.58, 0),
  ("Tensor", 4, 1663000, 0, 238.55, 12.02, 0),
  ("Tensor", 4, 1836000, 0, 259.04, 16.11, 0),
  ("Tensor", 4, 1999000, 0, 361.98, 15.7, 0),
  ("Tensor", 4, 2130000, 0, 428.51, 18.94, 0),
  ("Tensor", 4, 2253000, 0, 527.05, 23.5, 0),
  ("Tensor", 6, 500000, 0, 87.31, 16.14, 0),
  ("Tensor", 6, 851000, 0, 170.29, 19.88, 0),
  ("Tensor", 6, 984000, 0, 207.43, 20.55, 0),
  ("Tensor", 6, 1106000, 0, 251.88, 23.06, 0),
  ("Tensor", 6, 1277000, 0, 306.57, 25.12, 0),
  ("Tensor", 6, 1426000, 0, 382.61, 26.76, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 6, 1582000, 0, 465.9, 29.74, 0),
  ("Tensor", 6, 1745000, 0, 556.25, 32.87, 0),
  ("Tensor", 6, 1826000, 0, 613.51, 36.01, 0),
  ("Tensor", 6, 2048000, 0, 758.89, 41.67, 0),
  ("Tensor", 6, 2188000, 0, 874.03, 47.92, 0),
  ("Tensor", 6, 2252000, 0, 949.55, 51.07, 0),
  ("Tensor", 6, 2401000, 0, 1099.53, 57.42, 0),
  ("Tensor", 6, 2507000, 0, 1267.19, 66.14, 0),
  ("Tensor", 6, 2630000, 0, 1500.6, 82.36, 0),
  ("Tensor", 6, 2704000, 0, 1660.81, 95.11, 0),
  ("Tensor", 6, 2802000, 0, 1942.89, 121.43, 0),
  ("Tensor G4", 4, 357000, 0, 39.49, 6.1, 0),
  ("Tensor G4", 4, 578000, 0, 62.09, 6.5, 0),
  ("Tensor G4", 4, 648000, 0, 70.05, 6.93, 0),
  ("Tensor G4", 4, 787000, 0, 83.26, 7.31, 0),
  ("Tensor G4", 4, 910000, 0, 97.12, 7.55, 0),
  ("Tensor G4", 4, 1065000, 0, 116.15, 7.9, 0),
  ("Tensor G4", 4, 1221000, 0, 138.37, 8.47, 0),
  ("Tensor G4", 4, 1328000, 0, 155.59, 8.94, 0),
  ("Tensor G4", 4, 1418000, 0, 172.52, 9.37, 0),
  ("Tensor G4", 4, 1549000, 0, 200.69, 10.21, 0),
  ("Tensor G4", 4, 1795000, 0, 267.18, 11.89, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 4, 1945000, 0, 317.06, 13.58, 0),
  ("Tensor G4", 4, 2130000, 0, 388.15, 16.02, 0),
  ("Tensor G4", 4, 2245000, 0, 430.4, 17.54, 0),
  ("Tensor G4", 4, 2367000, 0, 504.35, 20.92, 0),
  ("Tensor G4", 4, 2450000, 0, 579.03, 23.39, 0),
  ("Tensor G4", 4, 2600000, 0, 674.24, 31.07, 0),
  ("Tensor G4", 7, 700000, 0, 211.41, 17.97, 0),
  ("Tensor G4", 7, 1164000, 0, 375.49, 20.24, 0),
  ("Tensor G4", 7, 1396000, 0, 491.17, 22.35, 0),
  ("Tensor G4", 7, 1557000, 0, 589.06, 24.29, 0),
  ("Tensor G4", 7, 1745000, 0, 742.95, 26.79, 0),
  ("Tensor G4", 7, 1885000, 0, 862.73, 28.61, 0),
  ("Tensor G4", 7, 1999000, 0, 965.94, 30.04, 0),
  ("Tensor G4", 7, 2147000, 0, 1136.58, 32.65, 0),
  ("Tensor G4", 7, 2294000, 0, 1309.39, 35.62, 0),
  ("Tensor G4", 7, 2363000, 0, 1415.82, 37.93, 0),
  ("Tensor G4", 7, 2499000, 0, 1669.61, 42.96, 0),
  ("Tensor G4", 7, 2687000, 0, 2052.32, 52.16, 0),
  ("Tensor G4", 7, 2802000, 0, 2354.18, 60.2, 0),
  ("Tensor G4", 7, 2914000, 0, 2789.17, 77.16, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 7, 2943000, 0, 2840.06, 79.64, 0),
  ("Tensor G4", 7, 2970000, 0, 2949.03, 84.78, 0),
  ("Tensor G4", 7, 3015000, 0, 3029.38, 87.22, 0),
  ("Tensor G4", 7, 3105000, 0, 3327.56, 99.47, 0)
)
select * from data;

-- Device specific device curves with 2D dependency (i.e. curve characteristics
-- are dependent on another CPU policy). See go/wattson for more info.
CREATE PERFETTO TABLE _device_curves_2d
AS
WITH data(device, freq_khz, other_policy, other_freq_khz, static, active, idle0, idle1)
AS (
  VALUES
  -- 255 represents static curve; needs to be same type as rest
  ("Tensor", 300000, 4, 400000, 3.73, 21.84, 0.47, 0),
  ("Tensor", 300000, 4, 553000, 5.66, 18.97, 0.99, 0),
  ("Tensor", 300000, 6, 500000, 2.61, 22.89, 0.76, 0),
  ("Tensor", 574000, 4, 400000, 5.73, 35.85, 0.93, 0),
  ("Tensor", 574000, 4, 553000, 5.41, 36.54, 0.98, 0),
  ("Tensor", 574000, 4, 696000, 5.61, 32.98, 0.99, 0),
  ("Tensor", 574000, 4, 799000, 9.7, 40.29, 1.33, 0),
  ("Tensor", 574000, 4, 910000, 9.81, 44.42, 1.24, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 574000, 4, 1024000, 9.71, 43.95, 1.31, 0),
  ("Tensor", 574000, 6, 500000, 5.6, 34.69, 1.03, 0),
  ("Tensor", 574000, 6, 851000, 5.57, 33.66, 1.02, 0),
  ("Tensor", 574000, 6, 984000, 5.68, 36.2, 0.98, 0),
  ("Tensor", 574000, 6, 1106000, 5.59, 36.27, 1.02, 0),
  ("Tensor", 738000, 4, 400000, 6.62, 47.66, 1.08, 0),
  ("Tensor", 738000, 4, 553000, 6.7, 45.71, 1.03, 0),
  ("Tensor", 738000, 4, 696000, 6.7, 46.21, 1.04, 0),
  ("Tensor", 738000, 4, 799000, 9.8, 55.47, 1.23, 0),
  ("Tensor", 738000, 4, 910000, 9.69, 52.58, 1.31, 0),
  ("Tensor", 738000, 4, 1024000, 9.77, 54.81, 1.3, 0),
  ("Tensor", 738000, 4, 1197000, 18.75, 75.3, 2.05, 0),
  ("Tensor", 738000, 4, 1328000, 18.98, 75.84, 1.91, 0),
  ("Tensor", 738000, 6, 500000, 6.63, 44.56, 1.11, 0),
  ("Tensor", 738000, 6, 851000, 6.65, 46.62, 1.08, 0),
  ("Tensor", 738000, 6, 984000, 6.63, 50.28, 1.08, 0),
  ("Tensor", 738000, 6, 1106000, 6.74, 44.83, 1.07, 0),
  ("Tensor", 738000, 6, 1277000, 6.6, 44.15, 1.09, 0),
  ("Tensor", 738000, 6, 1426000, 18.97, 74.73, 1.94, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 930000, 4, 400000, 9.64, 81.16, 1.27, 0),
  ("Tensor", 930000, 4, 553000, 9.88, 67.4, 1.28, 0),
  ("Tensor", 930000, 4, 696000, 9.69, 67.33, 1.3, 0),
  ("Tensor", 930000, 4, 799000, 9.69, 67.82, 1.3, 0),
  ("Tensor", 930000, 4, 910000, 9.79, 67.52, 1.29, 0),
  ("Tensor", 930000, 4, 1024000, 9.75, 65.44, 1.28, 0),
  ("Tensor", 930000, 4, 1197000, 18.84, 83.73, 2.0, 0),
  ("Tensor", 930000, 4, 1328000, 18.88, 101.57, 1.97, 0),
  ("Tensor", 930000, 4, 1491000, 18.86, 94.45, 1.99, 0),
  ("Tensor", 930000, 4, 1663000, 35.46, 134.93, 3.29, 0),
  ("Tensor", 930000, 4, 1836000, 35.34, 135.55, 3.36, 0),
  ("Tensor", 930000, 6, 500000, 9.76, 66.0, 1.28, 0),
  ("Tensor", 930000, 6, 851000, 9.8, 73.08, 1.24, 0),
  ("Tensor", 930000, 6, 984000, 9.75, 74.87, 1.25, 0),
  ("Tensor", 930000, 6, 1106000, 9.68, 77.31, 1.3, 0),
  ("Tensor", 930000, 6, 1277000, 9.83, 80.03, 1.25, 0),
  ("Tensor", 930000, 6, 1426000, 19.01, 98.31, 1.94, 0),
  ("Tensor", 930000, 6, 1582000, 18.94, 94.51, 1.98, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 930000, 6, 1745000, 19.0, 94.38, 1.93, 0),
  ("Tensor", 930000, 6, 1826000, 18.98, 100.84, 1.92, 0),
  ("Tensor", 1098000, 4, 400000, 12.93, 109.45, 1.47, 0),
  ("Tensor", 1098000, 4, 553000, 12.92, 120.82, 1.48, 0),
  ("Tensor", 1098000, 4, 696000, 13.09, 107.17, 1.41, 0),
  ("Tensor", 1098000, 4, 799000, 12.82, 91.84, 1.56, 0),
  ("Tensor", 1098000, 4, 910000, 12.88, 99.1, 1.52, 0),
  ("Tensor", 1098000, 4, 1024000, 12.81, 87.32, 1.57, 0),
  ("Tensor", 1098000, 4, 1197000, 18.92, 115.83, 1.97, 0),
  ("Tensor", 1098000, 4, 1328000, 18.97, 137.08, 1.93, 0),
  ("Tensor", 1098000, 4, 1491000, 18.94, 120.36, 1.94, 0),
  ("Tensor", 1098000, 4, 1663000, 35.21, 156.0, 3.43, 0),
  ("Tensor", 1098000, 4, 1836000, 35.21, 155.3, 3.42, 0),
  ("Tensor", 1098000, 4, 1999000, 35.49, 157.04, 3.24, 0),
  ("Tensor", 1098000, 4, 2130000, 35.17, 156.91, 3.41, 0),
  ("Tensor", 1098000, 6, 500000, 13.0, 93.54, 1.45, 0),
  ("Tensor", 1098000, 6, 851000, 13.12, 104.28, 1.4, 0),
  ("Tensor", 1098000, 6, 984000, 12.85, 94.73, 1.52, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1098000, 6, 1106000, 12.68, 95.73, 1.6, 0),
  ("Tensor", 1098000, 6, 1277000, 12.94, 92.78, 1.46, 0),
  ("Tensor", 1098000, 6, 1426000, 18.81, 128.5, 2.03, 0),
  ("Tensor", 1098000, 6, 1582000, 19.0, 124.51, 1.89, 0),
  ("Tensor", 1098000, 6, 1745000, 18.75, 121.84, 2.0, 0),
  ("Tensor", 1098000, 6, 1826000, 19.01, 117.69, 1.9, 0),
  ("Tensor", 1098000, 6, 2048000, 18.97, 107.49, 1.89, 0),
  ("Tensor", 1098000, 6, 2188000, 18.95, 124.24, 1.92, 0),
  ("Tensor", 1197000, 4, 400000, 14.5, 128.64, 1.54, 0),
  ("Tensor", 1197000, 4, 553000, 14.41, 126.94, 1.58, 0),
  ("Tensor", 1197000, 4, 696000, 14.43, 123.96, 1.63, 0),
  ("Tensor", 1197000, 4, 799000, 14.39, 125.32, 1.59, 0),
  ("Tensor", 1197000, 4, 910000, 14.42, 126.37, 1.55, 0),
  ("Tensor", 1197000, 4, 1024000, 14.5, 110.43, 1.54, 0),
  ("Tensor", 1197000, 4, 1197000, 19.0, 121.68, 1.9, 222.0),
  ("Tensor", 1197000, 4, 1328000, 18.88, 122.27, 1.96, 0),
  ("Tensor", 1197000, 4, 1491000, 18.84, 118.62, 1.98, 0),
  ("Tensor", 1197000, 4, 1663000, 35.35, 175.31, 3.32, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1197000, 4, 1836000, 35.37, 178.17, 3.38, 0),
  ("Tensor", 1197000, 4, 1999000, 35.34, 186.68, 3.38, 0),
  ("Tensor", 1197000, 4, 2130000, 35.37, 176.06, 3.34, 0),
  ("Tensor", 1197000, 4, 2253000, 35.29, 169.24, 3.38, 111.0),
  ("Tensor", 1197000, 6, 500000, 14.47, 95.77, 1.55, 0),
  ("Tensor", 1197000, 6, 851000, 14.42, 101.17, 1.6, 0),
  ("Tensor", 1197000, 6, 984000, 14.21, 116.52, 1.68, 0),
  ("Tensor", 1197000, 6, 1106000, 14.32, 111.16, 1.62, 0),
  ("Tensor", 1197000, 6, 1277000, 14.42, 84.46, 1.6, 0),
  ("Tensor", 1197000, 6, 1426000, 18.83, 130.44, 2.01, 0),
  ("Tensor", 1197000, 6, 1582000, 18.98, 140.9, 1.9, 0),
  ("Tensor", 1197000, 6, 1745000, 18.82, 143.87, 1.94, 0),
  ("Tensor", 1197000, 6, 1826000, 18.91, 131.75, 1.96, 0),
  ("Tensor", 1197000, 6, 2048000, 18.99, 128.36, 1.96, 0),
  ("Tensor", 1197000, 6, 2188000, 18.71, 132.46, 2.07, 0),
  ("Tensor", 1197000, 6, 2252000, 18.82, 130.95, 2.0, 0),
  ("Tensor", 1328000, 4, 400000, 17.0, 135.89, 1.84, 0),
  ("Tensor", 1328000, 4, 553000, 17.1, 161.84, 1.78, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 4, 696000, 16.99, 142.03, 1.87, 0),
  ("Tensor", 1328000, 4, 799000, 17.07, 169.36, 1.83, 0),
  ("Tensor", 1328000, 4, 910000, 17.19, 111.73, 1.81, 0),
  ("Tensor", 1328000, 4, 1024000, 17.21, 128.66, 1.78, 0),
  ("Tensor", 1328000, 4, 1197000, 18.83, 129.66, 2.02, 0),
  ("Tensor", 1328000, 4, 1328000, 18.88, 132.55, 1.96, 0),
  ("Tensor", 1328000, 4, 1491000, 18.87, 146.14, 2.0, 0),
  ("Tensor", 1328000, 4, 1663000, 35.43, 185.94, 3.27, 0),
  ("Tensor", 1328000, 4, 1836000, 35.46, 165.55, 3.27, 0),
  ("Tensor", 1328000, 4, 1999000, 35.37, 186.76, 3.29, 0),
  ("Tensor", 1328000, 4, 2130000, 35.35, 207.2, 3.34, 0),
  ("Tensor", 1328000, 4, 2253000, 35.31, 209.73, 3.42, 0),
  ("Tensor", 1328000, 6, 500000, 17.15, 130.76, 1.77, 0),
  ("Tensor", 1328000, 6, 851000, 17.06, 123.6, 1.84, 0),
  ("Tensor", 1328000, 6, 984000, 17.21, 130.23, 1.77, 0),
  ("Tensor", 1328000, 6, 1106000, 17.16, 139.65, 1.84, 0),
  ("Tensor", 1328000, 6, 1277000, 17.14, 123.95, 1.83, 0),
  ("Tensor", 1328000, 6, 1426000, 19.15, 141.04, 1.91, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 6, 1582000, 19.13, 108.29, 1.91, 0),
  ("Tensor", 1328000, 6, 1745000, 19.12, 133.38, 1.9, 0),
  ("Tensor", 1328000, 6, 1826000, 18.87, 137.51, 2.06, 0),
  ("Tensor", 1328000, 6, 2048000, 19.02, 145.9, 1.96, 0),
  ("Tensor", 1328000, 6, 2188000, 19.06, 129.5, 1.94, 0),
  ("Tensor", 1328000, 6, 2252000, 19.05, 125.72, 1.91, 0),
  ("Tensor", 1328000, 6, 2401000, 35.57, 187.29, 3.33, 0),
  ("Tensor", 1328000, 6, 2507000, 35.38, 213.14, 3.44, 0),
  ("Tensor", 1328000, 6, 2630000, 35.47, 181.15, 3.41, 0),
  ("Tensor", 1401000, 4, 400000, 18.85, 184.12, 2.06, 0),
  ("Tensor", 1401000, 4, 553000, 18.91, 168.23, 1.98, 0),
  ("Tensor", 1401000, 4, 696000, 19.11, 184.69, 1.92, 0),
  ("Tensor", 1401000, 4, 799000, 19.16, 175.13, 1.91, 0),
  ("Tensor", 1401000, 4, 910000, 19.02, 161.7, 1.97, 0),
  ("Tensor", 1401000, 4, 1024000, 18.97, 156.68, 2.01, 0),
  ("Tensor", 1401000, 4, 1197000, 19.07, 155.0, 1.97, 0),
  ("Tensor", 1401000, 4, 1328000, 18.95, 159.64, 1.96, 0),
  ("Tensor", 1401000, 4, 1491000, 19.13, 136.78, 1.95, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 4, 1663000, 35.67, 186.73, 3.29, 0),
  ("Tensor", 1401000, 4, 1836000, 35.51, 220.26, 3.45, 0),
  ("Tensor", 1401000, 4, 1999000, 35.75, 249.18, 3.3, 0),
  ("Tensor", 1401000, 4, 2130000, 35.65, 217.48, 3.4, 0),
  ("Tensor", 1401000, 4, 2253000, 35.66, 248.9, 3.41, 0),
  ("Tensor", 1401000, 6, 500000, 19.05, 152.39, 1.98, 0),
  ("Tensor", 1401000, 6, 851000, 19.0, 148.12, 2.03, 0),
  ("Tensor", 1401000, 6, 984000, 19.01, 128.71, 2.0, 0),
  ("Tensor", 1401000, 6, 1106000, 18.18, 132.83, 2.01, 0),
  ("Tensor", 1401000, 6, 1277000, 19.07, 138.09, 1.95, 0),
  ("Tensor", 1401000, 6, 1426000, 18.92, 144.69, 2.05, 0),
  ("Tensor", 1401000, 6, 1582000, 18.95, 151.34, 2.05, 0),
  ("Tensor", 1401000, 6, 1745000, 18.98, 152.04, 2.01, 0),
  ("Tensor", 1401000, 6, 1826000, 19.11, 151.71, 1.95, 0),
  ("Tensor", 1401000, 6, 2048000, 19.04, 136.69, 1.98, 0),
  ("Tensor", 1401000, 6, 2188000, 18.97, 152.56, 2.0, 0),
  ("Tensor", 1401000, 6, 2252000, 19.09, 149.02, 1.97, 0),
  ("Tensor", 1401000, 6, 2401000, 35.91, 210.3, 3.23, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 6, 2507000, 35.64, 188.64, 3.32, 0),
  ("Tensor", 1401000, 6, 2630000, 35.41, 202.75, 3.5, 0),
  ("Tensor", 1401000, 6, 2704000, 35.69, 204.49, 3.4, 0),
  ("Tensor", 1401000, 6, 2802000, 35.64, 208.14, 3.45, 0),
  ("Tensor", 1598000, 4, 400000, 24.83, 196.05, 2.36, 0),
  ("Tensor", 1598000, 4, 553000, 24.68, 234.53, 2.37, 0),
  ("Tensor", 1598000, 4, 696000, 24.71, 230.15, 2.34, 0),
  ("Tensor", 1598000, 4, 799000, 24.87, 175.64, 2.34, 0),
  ("Tensor", 1598000, 4, 910000, 24.76, 228.23, 2.36, 0),
  ("Tensor", 1598000, 4, 1024000, 24.6, 228.37, 2.47, 0),
  ("Tensor", 1598000, 4, 1197000, 24.77, 201.12, 2.43, 0),
  ("Tensor", 1598000, 4, 1328000, 24.68, 202.37, 2.41, 0),
  ("Tensor", 1598000, 4, 1491000, 24.58, 199.78, 2.52, 0),
  ("Tensor", 1598000, 4, 1663000, 35.59, 210.2, 3.46, 0),
  ("Tensor", 1598000, 4, 1836000, 35.74, 315.02, 3.33, 0),
  ("Tensor", 1598000, 4, 1999000, 35.65, 285.37, 3.44, 0),
  ("Tensor", 1598000, 4, 2130000, 35.31, 256.84, 3.7, 0),
  ("Tensor", 1598000, 4, 2253000, 35.91, 255.65, 3.37, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 6, 500000, 24.78, 184.21, 2.34, 0),
  ("Tensor", 1598000, 6, 851000, 24.73, 175.69, 2.41, 0),
  ("Tensor", 1598000, 6, 984000, 24.68, 195.14, 2.43, 0),
  ("Tensor", 1598000, 6, 1106000, 24.65, 194.89, 2.46, 0),
  ("Tensor", 1598000, 6, 1277000, 24.63, 167.1, 2.49, 0),
  ("Tensor", 1598000, 6, 1426000, 24.7, 190.42, 2.45, 0),
  ("Tensor", 1598000, 6, 1582000, 24.79, 190.72, 2.39, 0),
  ("Tensor", 1598000, 6, 1745000, 24.73, 180.52, 2.44, 0),
  ("Tensor", 1598000, 6, 1826000, 24.72, 203.15, 2.4, 0),
  ("Tensor", 1598000, 6, 2048000, 24.82, 197.7, 2.39, 0),
  ("Tensor", 1598000, 6, 2188000, 24.7, 185.45, 2.47, 0),
  ("Tensor", 1598000, 6, 2252000, 24.83, 155.38, 2.35, 0),
  ("Tensor", 1598000, 6, 2401000, 36.0, 237.12, 3.25, 0),
  ("Tensor", 1598000, 6, 2507000, 35.89, 253.55, 3.34, 0),
  ("Tensor", 1598000, 6, 2630000, 35.76, 208.38, 3.45, 0),
  ("Tensor", 1598000, 6, 2704000, 35.7, 218.73, 3.46, 0),
  ("Tensor", 1598000, 6, 2802000, 35.65, 248.51, 3.47, 0),
  ("Tensor", 1704000, 4, 400000, 28.98, 234.84, 2.73, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1704000, 4, 553000, 29.01, 210.31, 2.66, 0),
  ("Tensor", 1704000, 4, 696000, 28.95, 300.74, 2.73, 0),
  ("Tensor", 1704000, 4, 799000, 28.77, 270.96, 2.79, 0),
  ("Tensor", 1704000, 4, 910000, 28.84, 284.84, 2.76, 0),
  ("Tensor", 1704000, 4, 1024000, 28.76, 251.86, 2.85, 0),
  ("Tensor", 1704000, 4, 1197000, 28.75, 256.3, 2.78, 0),
  ("Tensor", 1704000, 4, 1328000, 28.65, 246.88, 2.86, 0),
  ("Tensor", 1704000, 4, 1491000, 28.73, 267.07, 2.88, 0),
  ("Tensor", 1704000, 4, 1663000, 35.81, 266.03, 3.49, 0),
  ("Tensor", 1704000, 4, 1836000, 35.78, 274.06, 3.35, 0),
  ("Tensor", 1704000, 4, 1999000, 35.67, 268.14, 3.46, 0),
  ("Tensor", 1704000, 4, 2130000, 35.75, 273.4, 3.41, 0),
  ("Tensor", 1704000, 4, 2253000, 35.42, 276.92, 3.72, 0),
  ("Tensor", 1704000, 6, 500000, 29.1, 239.74, 2.65, 0),
  ("Tensor", 1704000, 6, 851000, 28.79, 216.53, 2.74, 0),
  ("Tensor", 1704000, 6, 984000, 28.9, 259.03, 2.76, 0),
  ("Tensor", 1704000, 6, 1106000, 28.71, 211.76, 2.82, 0),
  ("Tensor", 1704000, 6, 1277000, 28.79, 216.77, 2.8, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1704000, 6, 1426000, 28.94, 207.8, 2.71, 0),
  ("Tensor", 1704000, 6, 1582000, 28.96, 232.83, 2.67, 0),
  ("Tensor", 1704000, 6, 1745000, 28.67, 237.37, 2.85, 0),
  ("Tensor", 1704000, 6, 1826000, 29.0, 224.71, 2.71, 0),
  ("Tensor", 1704000, 6, 2048000, 28.86, 239.69, 2.73, 0),
  ("Tensor", 1704000, 6, 2188000, 28.88, 218.8, 2.76, 0),
  ("Tensor", 1704000, 6, 2252000, 28.87, 272.23, 2.76, 0),
  ("Tensor", 1704000, 6, 2401000, 35.74, 258.98, 3.33, 0),
  ("Tensor", 1704000, 6, 2507000, 35.74, 276.92, 3.4, 0),
  ("Tensor", 1704000, 6, 2630000, 35.71, 249.7, 3.45, 0),
  ("Tensor", 1704000, 6, 2704000, 36.01, 253.04, 3.29, 0),
  ("Tensor", 1704000, 6, 2802000, 35.91, 266.15, 3.4, 0),
  ("Tensor", 1803000, 4, 400000, 35.71, 342.95, 3.49, 0),
  ("Tensor", 1803000, 4, 553000, 35.76, 330.57, 3.41, 0),
  ("Tensor", 1803000, 4, 696000, 35.71, 355.0, 3.41, 0),
  ("Tensor", 1803000, 4, 799000, 35.67, 310.42, 3.45, 0),
  ("Tensor", 1803000, 4, 910000, 35.95, 309.22, 3.38, 0),
  ("Tensor", 1803000, 4, 1024000, 35.6, 303.94, 3.55, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 4, 1197000, 36.0, 346.31, 3.26, 0),
  ("Tensor", 1803000, 4, 1328000, 35.9, 300.16, 3.36, 0),
  ("Tensor", 1803000, 4, 1491000, 35.88, 215.33, 3.33, 0),
  ("Tensor", 1803000, 4, 1663000, 35.72, 284.35, 3.47, 0),
  ("Tensor", 1803000, 4, 1836000, 35.9, 289.0, 3.32, 0),
  ("Tensor", 1803000, 4, 1999000, 34.96, 293.38, 3.33, 0),
  ("Tensor", 1803000, 4, 2130000, 35.07, 359.86, 3.19, 0),
  ("Tensor", 1803000, 4, 2253000, 35.07, 295.24, 3.23, 0),
  ("Tensor", 1803000, 6, 500000, 34.68, 223.89, 3.4, 0),
  ("Tensor", 1803000, 6, 851000, 34.74, 261.39, 3.4, 0),
  ("Tensor", 1803000, 6, 984000, 35.08, 269.51, 3.26, 0),
  ("Tensor", 1803000, 6, 1106000, 35.06, 269.58, 3.21, 0),
  ("Tensor", 1803000, 6, 1277000, 34.87, 218.3, 3.39, 0),
  ("Tensor", 1803000, 6, 1426000, 34.86, 264.34, 3.36, 0),
  ("Tensor", 1803000, 6, 1582000, 34.9, 263.56, 3.36, 0),
  ("Tensor", 1803000, 6, 1745000, 35.09, 210.36, 3.29, 0),
  ("Tensor", 1803000, 6, 1826000, 35.06, 256.1, 3.34, 0),
  ("Tensor", 1803000, 6, 2048000, 35.18, 269.91, 3.16, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 6, 2188000, 35.16, 261.04, 3.25, 0),
  ("Tensor", 1803000, 6, 2252000, 34.84, 272.92, 3.49, 0),
  ("Tensor", 1803000, 6, 2401000, 35.2, 260.24, 3.38, 0),
  ("Tensor", 1803000, 6, 2507000, 34.89, 240.7, 3.58, 0),
  ("Tensor", 1803000, 6, 2630000, 35.21, 150.76, 3.42, 0),
  ("Tensor", 1803000, 6, 2704000, 35.2, 277.28, 3.44, 0),
  ("Tensor", 1803000, 6, 2802000, 35.12, 269.2, 3.62, 0),
  ("Tensor G4", 820000, 255, 610000, 3.3, 47.6, 1.04, 0),
  ("Tensor G4", 820000, 255, 820000, 6.77, 65.48, 1.17, 0),
  ("Tensor G4", 820000, 255, 970000, 8.61, 78.56, 1.28, 0),
  ("Tensor G4", 820000, 255, 1098000, 12.5, 92.7, 1.28, 0),
  ("Tensor G4", 820000, 255, 1197000, 15.24, 110.72, 1.46, 0),
  ("Tensor G4", 820000, 255, 1328000, 21.73, 134.04, 1.58, 0),
  ("Tensor G4", 820000, 255, 1444000, 26.89, 151.02, 1.75, 0),
  ("Tensor G4", 820000, 255, 1548000, 31.53, 164.93, 1.8, 0),
  ("Tensor G4", 820000, 255, 1704000, 43.86, 157.18, 2.24, 0),
  ("Tensor G4", 820000, 255, 1800000, 52.1, 137.62, 2.64, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 820000, 255, 1880000, 59.74, 145.28, 2.44, 0),
  ("Tensor G4", 820000, 255, 1950000, 71.34, 156.19, 3.12, 0),
  ("Tensor G4", 820000, 255, 2024000, 86.3, 155.05, 3.53, 0),
  ("Tensor G4", 820000, 255, 2120000, 112.45, 176.15, 4.74, 0),
  ("Tensor G4", 820000, 255, 2150000, 112.1, 155.11, 4.69, 0),
  ("Tensor G4", 955000, 255, 610000, 6.18, 56.03, 0.68, 0),
  ("Tensor G4", 955000, 255, 820000, 6.39, 74.22, 1.21, 0),
  ("Tensor G4", 955000, 255, 970000, 9.18, 82.2, 1.26, 0),
  ("Tensor G4", 955000, 255, 1098000, 12.62, 98.11, 1.34, 0),
  ("Tensor G4", 955000, 255, 1197000, 15.72, 117.95, 1.41, 0),
  ("Tensor G4", 955000, 255, 1328000, 21.94, 141.91, 1.57, 0),
  ("Tensor G4", 955000, 255, 1444000, 27.38, 162.99, 1.85, 0),
  ("Tensor G4", 955000, 255, 1548000, 31.94, 175.19, 1.72, 0),
  ("Tensor G4", 955000, 255, 1704000, 43.84, 130.38, 2.44, 0),
  ("Tensor G4", 955000, 255, 1800000, 52.67, 117.99, 2.5, 0),
  ("Tensor G4", 955000, 255, 1880000, 59.69, 145.08, 2.91, 0),
  ("Tensor G4", 955000, 255, 1950000, 73.33, 141.24, 3.23, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 955000, 255, 2024000, 86.96, 171.19, 3.7, 0),
  ("Tensor G4", 955000, 255, 2120000, 112.7, 188.38, 5.0, 0),
  ("Tensor G4", 955000, 255, 2150000, 111.86, 179.34, 5.53, 0),
  ("Tensor G4", 1098000, 255, 610000, 7.23, 66.6, 1.26, 0),
  ("Tensor G4", 1098000, 255, 820000, 8.04, 80.19, 1.21, 0),
  ("Tensor G4", 1098000, 255, 970000, 9.56, 90.34, 1.22, 0),
  ("Tensor G4", 1098000, 255, 1098000, 12.86, 109.5, 1.33, 0),
  ("Tensor G4", 1098000, 255, 1197000, 16.57, 120.41, 1.07, 0),
  ("Tensor G4", 1098000, 255, 1328000, 22.15, 145.31, 1.54, 0),
  ("Tensor G4", 1098000, 255, 1444000, 27.91, 163.9, 1.68, 0),
  ("Tensor G4", 1098000, 255, 1548000, 32.01, 174.89, 1.87, 0),
  ("Tensor G4", 1098000, 255, 1704000, 44.5, 139.63, 2.24, 0),
  ("Tensor G4", 1098000, 255, 1800000, 53.21, 140.32, 2.52, 0),
  ("Tensor G4", 1098000, 255, 1880000, 60.44, 157.97, 2.83, 0),
  ("Tensor G4", 1098000, 255, 1950000, 73.65, 169.76, 3.28, 0),
  ("Tensor G4", 1098000, 255, 2024000, 87.15, 182.83, 3.98, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1098000, 255, 2120000, 114.08, 187.49, 4.17, 0),
  ("Tensor G4", 1098000, 255, 2150000, 113.79, 189.6, 4.65, 0),
  ("Tensor G4", 1197000, 255, 610000, 8.34, 75.11, 1.27, 0),
  ("Tensor G4", 1197000, 255, 820000, 9.54, 84.82, 1.14, 0),
  ("Tensor G4", 1197000, 255, 970000, 10.37, 89.93, 1.18, 0),
  ("Tensor G4", 1197000, 255, 1098000, 12.81, 104.44, 1.37, 0),
  ("Tensor G4", 1197000, 255, 1197000, 16.36, 129.81, 1.39, 0),
  ("Tensor G4", 1197000, 255, 1328000, 22.4, 145.01, 1.64, 0),
  ("Tensor G4", 1197000, 255, 1444000, 28.1, 170.53, 1.61, 0),
  ("Tensor G4", 1197000, 255, 1548000, 32.23, 186.28, 1.91, 0),
  ("Tensor G4", 1197000, 255, 1704000, 44.93, 156.69, 2.32, 0),
  ("Tensor G4", 1197000, 255, 1800000, 53.17, 151.91, 2.43, 0),
  ("Tensor G4", 1197000, 255, 1880000, 60.94, 141.69, 2.72, 0),
  ("Tensor G4", 1197000, 255, 1950000, 73.72, 189.86, 3.42, 0),
  ("Tensor G4", 1197000, 255, 2024000, 87.87, 158.58, 3.7, 0),
  ("Tensor G4", 1197000, 255, 2120000, 114.16, 193.12, 4.81, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1197000, 255, 2150000, 113.59, 191.22, 4.8, 0),
  ("Tensor G4", 1328000, 255, 610000, 10.73, 90.03, 1.33, 0),
  ("Tensor G4", 1328000, 255, 820000, 11.88, 99.06, 1.31, 0),
  ("Tensor G4", 1328000, 255, 970000, 12.77, 106.72, 1.33, 0),
  ("Tensor G4", 1328000, 255, 1098000, 13.12, 110.06, 1.39, 0),
  ("Tensor G4", 1328000, 255, 1197000, 16.68, 127.98, 1.33, 0),
  ("Tensor G4", 1328000, 255, 1328000, 22.66, 154.27, 1.68, 0),
  ("Tensor G4", 1328000, 255, 1444000, 28.49, 174.25, 1.72, 0),
  ("Tensor G4", 1328000, 255, 1548000, 32.16, 191.25, 1.73, 0),
  ("Tensor G4", 1328000, 255, 1704000, 44.27, 129.41, 2.25, 0),
  ("Tensor G4", 1328000, 255, 1800000, 53.79, 154.61, 2.51, 0),
  ("Tensor G4", 1328000, 255, 1880000, 61.04, 163.47, 2.68, 0),
  ("Tensor G4", 1328000, 255, 1950000, 75.05, 189.16, 3.08, 0),
  ("Tensor G4", 1328000, 255, 2024000, 89.05, 204.54, 3.43, 0),
  ("Tensor G4", 1328000, 255, 2120000, 115.33, 210.24, 4.36, 0),
  ("Tensor G4", 1328000, 255, 2150000, 114.98, 206.93, 4.34, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1425000, 255, 610000, 13.32, 101.33, 1.43, 0),
  ("Tensor G4", 1425000, 255, 820000, 14.56, 111.02, 1.46, 0),
  ("Tensor G4", 1425000, 255, 970000, 15.11, 121.09, 1.47, 0),
  ("Tensor G4", 1425000, 255, 1098000, 16.25, 128.03, 1.41, 0),
  ("Tensor G4", 1425000, 255, 1197000, 16.68, 127.43, 1.45, 0),
  ("Tensor G4", 1425000, 255, 1328000, 22.57, 156.98, 1.68, 0),
  ("Tensor G4", 1425000, 255, 1444000, 28.81, 182.29, 1.72, 0),
  ("Tensor G4", 1425000, 255, 1548000, 33.08, 198.0, 1.83, 0),
  ("Tensor G4", 1425000, 255, 1704000, 45.21, 162.21, 2.12, 0),
  ("Tensor G4", 1425000, 255, 1800000, 54.37, 167.27, 2.5, 0),
  ("Tensor G4", 1425000, 255, 1880000, 61.48, 116.14, 2.89, 0),
  ("Tensor G4", 1425000, 255, 1950000, 74.85, 180.6, 3.49, 0),
  ("Tensor G4", 1425000, 255, 2024000, 89.32, 187.51, 3.6, 0),
  ("Tensor G4", 1425000, 255, 2120000, 115.2, 203.97, 4.57, 0),
  ("Tensor G4", 1425000, 255, 2150000, 115.53, 210.01, 4.25, 0),
  ("Tensor G4", 1548000, 255, 610000, 16.36, 123.83, 1.45, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1548000, 255, 820000, 17.5, 128.9, 1.62, 0),
  ("Tensor G4", 1548000, 255, 970000, 18.34, 139.52, 1.58, 0),
  ("Tensor G4", 1548000, 255, 1098000, 19.32, 149.77, 1.53, 0),
  ("Tensor G4", 1548000, 255, 1197000, 19.8, 152.01, 1.43, 0),
  ("Tensor G4", 1548000, 255, 1328000, 22.59, 159.55, 1.61, 0),
  ("Tensor G4", 1548000, 255, 1444000, 28.75, 198.79, 1.86, 0),
  ("Tensor G4", 1548000, 255, 1548000, 33.46, 211.95, 1.77, 0),
  ("Tensor G4", 1548000, 255, 1704000, 46.36, 169.26, 2.11, 0),
  ("Tensor G4", 1548000, 255, 1800000, 54.71, 177.24, 2.42, 0),
  ("Tensor G4", 1548000, 255, 1880000, 62.25, 145.44, 2.76, 0),
  ("Tensor G4", 1548000, 255, 1950000, 75.84, 191.27, 3.09, 0),
  ("Tensor G4", 1548000, 255, 2024000, 88.97, 198.32, 3.86, 0),
  ("Tensor G4", 1548000, 255, 2120000, 115.79, 232.48, 4.72, 0),
  ("Tensor G4", 1548000, 255, 2150000, 115.31, 222.76, 4.71, 0),
  ("Tensor G4", 1696000, 255, 610000, 19.61, 132.84, 1.68, 0),
  ("Tensor G4", 1696000, 255, 820000, 21.09, 151.29, 1.59, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1696000, 255, 970000, 21.92, 157.59, 1.75, 0),
  ("Tensor G4", 1696000, 255, 1098000, 22.76, 163.33, 1.59, 0),
  ("Tensor G4", 1696000, 255, 1197000, 23.53, 173.96, 1.67, 0),
  ("Tensor G4", 1696000, 255, 1328000, 24.28, 184.05, 1.58, 0),
  ("Tensor G4", 1696000, 255, 1444000, 29.47, 203.99, 1.77, 0),
  ("Tensor G4", 1696000, 255, 1548000, 33.94, 225.78, 1.7, 0),
  ("Tensor G4", 1696000, 255, 1704000, 46.92, 171.8, 2.16, 0),
  ("Tensor G4", 1696000, 255, 1800000, 55.32, 217.17, 2.38, 0),
  ("Tensor G4", 1696000, 255, 1880000, 62.55, 224.61, 2.77, 0),
  ("Tensor G4", 1696000, 255, 1950000, 76.98, 204.48, 2.82, 0),
  ("Tensor G4", 1696000, 255, 2024000, 90.13, 226.98, 3.76, 0),
  ("Tensor G4", 1696000, 255, 2120000, 116.77, 245.48, 4.52, 0),
  ("Tensor G4", 1696000, 255, 2150000, 112.69, 222.79, 6.43, 0),
  ("Tensor G4", 1849000, 255, 610000, 29.35, 176.28, 1.8, 0),
  ("Tensor G4", 1849000, 255, 820000, 30.31, 187.61, 1.94, 0),
  ("Tensor G4", 1849000, 255, 970000, 31.7, 202.99, 2.05, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1849000, 255, 1098000, 32.48, 207.22, 2.01, 0),
  ("Tensor G4", 1849000, 255, 1197000, 33.7, 222.81, 1.9, 0),
  ("Tensor G4", 1849000, 255, 1328000, 34.79, 229.5, 1.9, 0),
  ("Tensor G4", 1849000, 255, 1444000, 35.97, 228.13, 1.91, 0),
  ("Tensor G4", 1849000, 255, 1548000, 36.59, 235.62, 2.01, 0),
  ("Tensor G4", 1849000, 255, 1704000, 47.47, 233.89, 2.16, 0),
  ("Tensor G4", 1849000, 255, 1800000, 55.69, 211.69, 2.53, 0),
  ("Tensor G4", 1849000, 255, 1880000, 63.47, 225.85, 2.39, 0),
  ("Tensor G4", 1849000, 255, 1950000, 77.22, 209.34, 3.0, 0),
  ("Tensor G4", 1849000, 255, 2024000, 90.92, 230.3, 3.48, 0),
  ("Tensor G4", 1849000, 255, 2120000, 117.19, 247.78, 4.49, 0),
  ("Tensor G4", 1849000, 255, 2150000, 117.53, 239.55, 4.32, 0),
  ("Tensor G4", 1950000, 255, 610000, 40.27, 197.26, 2.54, 0),
  ("Tensor G4", 1950000, 255, 820000, 41.93, 221.2, 2.67, 0),
  ("Tensor G4", 1950000, 255, 970000, 43.45, 239.45, 2.56, 0),
  ("Tensor G4", 1950000, 255, 1098000, 44.27, 240.43, 2.64, 0),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1950000, 255, 1197000, 45.84, 259.94, 2.42, 0),
  ("Tensor G4", 1950000, 255, 1328000, 47.03, 273.66, 2.55, 0),
  ("Tensor G4", 1950000, 255, 1444000, 48.53, 267.32, 2.32, 0),
  ("Tensor G4", 1950000, 255, 1548000, 49.59, 232.85, 2.35, 0),
  ("Tensor G4", 1950000, 255, 1704000, 51.2, 234.87, 2.23, 0),
  ("Tensor G4", 1950000, 255, 1800000, 55.47, 205.6, 2.67, 0),
  ("Tensor G4", 1950000, 255, 1880000, 63.68, 201.13, 2.59, 0),
  ("Tensor G4", 1950000, 255, 1950000, 77.22, 201.28, 3.13, 0),
  ("Tensor G4", 1950000, 255, 2024000, 90.93, 230.61, 3.81, 0),
  ("Tensor G4", 1950000, 255, 2120000, 118.19, 233.8, 4.28, 0),
  ("Tensor G4", 1950000, 255, 2150000, 118.61, 240.57, 4.6, 0)
)
select * from data;

CREATE PERFETTO TABLE _device_curves_l3
AS
WITH data(device, freq_khz, other_policy, other_freq_khz, l3_hit, l3_miss) AS (
  VALUES
  ("Tensor", 300000, 4, 400000, 0.3989, 0.0629),
  ("Tensor", 300000, 4, 553000, 0.4119, 0.0656),
  ("Tensor", 300000, 6, 500000, 0.3298, 0.1029),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 574000, 4, 400000, 0.4894, 0.0239),
  ("Tensor", 574000, 4, 553000, 0.4991, 0.0960),
  ("Tensor", 574000, 4, 696000, 0.4949, 0.0971),
  ("Tensor", 574000, 4, 799000, 0.6116, 0.1266),
  ("Tensor", 574000, 4, 910000, 0.5897, 0.1385),
  ("Tensor", 574000, 4, 1024000, 0.5619, 0.0635),
  ("Tensor", 574000, 6, 500000, 0.5377, 0.1210),
  ("Tensor", 574000, 6, 851000, 0.5271, 0.1591),
  ("Tensor", 574000, 6, 984000, 0.5395, 0.1599),
  ("Tensor", 574000, 6, 1106000, 0.5552, 0.1393),
  ("Tensor", 738000, 4, 400000, 0.5825, 0.1271),
  ("Tensor", 738000, 4, 553000, 0.5751, 0.0396),
  ("Tensor", 738000, 4, 696000, 0.6433, 0.1050),
  ("Tensor", 738000, 4, 799000, 0.6401, 0.1293),
  ("Tensor", 738000, 4, 910000, 0.7069, 0.1252),
  ("Tensor", 738000, 4, 1024000, 0.6999, 0.1143),
  ("Tensor", 738000, 4, 1197000, 0.9076, 0.1960),
  ("Tensor", 738000, 4, 1328000, 0.9708, 0.1953),
  ("Tensor", 738000, 6, 500000, 0.6437, 0.2086),
  ("Tensor", 738000, 6, 851000, 0.6274, 0.1852),
  ("Tensor", 738000, 6, 984000, 0.6231, 0.2066),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 738000, 6, 1106000, 0.6256, 0.2199),
  ("Tensor", 738000, 6, 1277000, 0.6719, 0.2485),
  ("Tensor", 738000, 6, 1426000, 1.1072, 0.3483),
  ("Tensor", 930000, 4, 400000, 0.7812, 0.1727),
  ("Tensor", 930000, 4, 553000, 0.7343, 0.1846),
  ("Tensor", 930000, 4, 696000, 0.7551, 0.2006),
  ("Tensor", 930000, 4, 799000, 0.7330, 0.1864),
  ("Tensor", 930000, 4, 910000, 0.8250, 0.1451),
  ("Tensor", 930000, 4, 1024000, 0.7331, 0.2092),
  ("Tensor", 930000, 4, 1197000, 1.0791, 0.4804),
  ("Tensor", 930000, 4, 1328000, 1.0172, 0.0844),
  ("Tensor", 930000, 4, 1491000, 1.0396, 0.2614),
  ("Tensor", 930000, 4, 1663000, 1.6492, 0.3497),
  ("Tensor", 930000, 4, 1836000, 1.5561, 0.3407),
  ("Tensor", 930000, 6, 500000, 0.8530, 0.4182),
  ("Tensor", 930000, 6, 851000, 0.8694, 0.2854),
  ("Tensor", 930000, 6, 984000, 0.8620, 0.2568),
  ("Tensor", 930000, 6, 1106000, 0.8763, 0.2336),
  ("Tensor", 930000, 6, 1277000, 0.8717, 0.3756),
  ("Tensor", 930000, 6, 1426000, 1.1774, 0.5021),
  ("Tensor", 930000, 6, 1582000, 1.1264, 0.5799),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 930000, 6, 1745000, 1.2303, 0.5421),
  ("Tensor", 930000, 6, 1826000, 1.2330, 0.4498),
  ("Tensor", 1098000, 4, 400000, 0.9744, 0.2106),
  ("Tensor", 1098000, 4, 553000, 0.9980, 0.0500),
  ("Tensor", 1098000, 4, 696000, 0.9500, 0.1928),
  ("Tensor", 1098000, 4, 799000, 0.9132, 0.2391),
  ("Tensor", 1098000, 4, 910000, 0.9922, 0.2576),
  ("Tensor", 1098000, 4, 1024000, 0.9607, 0.2397),
  ("Tensor", 1098000, 4, 1197000, 1.1253, 0.6195),
  ("Tensor", 1098000, 4, 1328000, 1.1609, 0.0960),
  ("Tensor", 1098000, 4, 1491000, 1.1783, 0.0851),
  ("Tensor", 1098000, 4, 1663000, 1.6941, 0.4295),
  ("Tensor", 1098000, 4, 1836000, 1.7152, 0.4610),
  ("Tensor", 1098000, 4, 1999000, 1.7941, 0.4293),
  ("Tensor", 1098000, 4, 2130000, 1.6758, 0.4437),
  ("Tensor", 1098000, 6, 500000, 1.0485, 0.4038),
  ("Tensor", 1098000, 6, 851000, 1.0510, 0.2815),
  ("Tensor", 1098000, 6, 984000, 1.0785, 0.4137),
  ("Tensor", 1098000, 6, 1106000, 1.0909, 0.3933),
  ("Tensor", 1098000, 6, 1277000, 1.1533, 0.3811),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1098000, 6, 1426000, 1.2718, 0.3814),
  ("Tensor", 1098000, 6, 1582000, 1.3463, 0.4100),
  ("Tensor", 1098000, 6, 1745000, 1.3065, 0.5207),
  ("Tensor", 1098000, 6, 1826000, 1.3456, 0.4903),
  ("Tensor", 1098000, 6, 2048000, 1.3466, 0.7218),
  ("Tensor", 1098000, 6, 2188000, 1.3132, 0.4923),
  ("Tensor", 1197000, 4, 400000, 1.0507, 0.2411),
  ("Tensor", 1197000, 4, 553000, 1.0387, 0.2875),
  ("Tensor", 1197000, 4, 696000, 1.0173, 0.2232),
  ("Tensor", 1197000, 4, 799000, 1.0160, 0.2418),
  ("Tensor", 1197000, 4, 910000, 1.0555, 0.0966),
  ("Tensor", 1197000, 4, 1024000, 1.0663, 0.0987),
  ("Tensor", 1197000, 4, 1197000, 1.1885, 0.2852),
  ("Tensor", 1197000, 4, 1328000, 1.2442, 0.2724),
  ("Tensor", 1197000, 4, 1491000, 1.2474, 0.3269),
  ("Tensor", 1197000, 4, 1663000, 1.8142, 0.3429),
  ("Tensor", 1197000, 4, 1836000, 1.7692, 1.0737),
  ("Tensor", 1197000, 4, 1999000, 1.7939, 0.1120),
  ("Tensor", 1197000, 4, 2130000, 1.8126, 0.3744),
  ("Tensor", 1197000, 4, 2253000, 1.7413, 0.5198),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1197000, 6, 500000, 1.1288, 0.6817),
  ("Tensor", 1197000, 6, 851000, 1.1779, 0.5681),
  ("Tensor", 1197000, 6, 984000, 1.1835, 0.3389),
  ("Tensor", 1197000, 6, 1106000, 1.2115, 0.4506),
  ("Tensor", 1197000, 6, 1277000, 1.1726, 0.8719),
  ("Tensor", 1197000, 6, 1426000, 1.3825, 0.5140),
  ("Tensor", 1197000, 6, 1582000, 1.4179, 0.3585),
  ("Tensor", 1197000, 6, 1745000, 1.3804, 0.3197),
  ("Tensor", 1197000, 6, 1826000, 1.3379, 0.5614),
  ("Tensor", 1197000, 6, 2048000, 1.3335, 0.5443),
  ("Tensor", 1197000, 6, 2188000, 1.4382, 0.5255),
  ("Tensor", 1197000, 6, 2252000, 1.3961, 0.5423),
  ("Tensor", 1328000, 4, 400000, 1.2307, 0.5565),
  ("Tensor", 1328000, 4, 553000, 1.2186, 0.2366),
  ("Tensor", 1328000, 4, 696000, 1.2243, 0.4145),
  ("Tensor", 1328000, 4, 799000, 1.2620, 0.0973),
  ("Tensor", 1328000, 4, 910000, 1.2462, 0.5669),
  ("Tensor", 1328000, 4, 1024000, 1.2787, 0.2332),
  ("Tensor", 1328000, 4, 1197000, 1.4364, 0.3260),
  ("Tensor", 1328000, 4, 1328000, 1.3636, 0.3354),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 4, 1491000, 1.3733, 0.0512),
  ("Tensor", 1328000, 4, 1663000, 1.9295, 0.4588),
  ("Tensor", 1328000, 4, 1836000, 1.8278, 0.9316),
  ("Tensor", 1328000, 4, 1999000, 1.9043, 0.4921),
  ("Tensor", 1328000, 4, 2130000, 1.9144, 0.1139),
  ("Tensor", 1328000, 4, 2253000, 1.9550, 0.0603),
  ("Tensor", 1328000, 6, 500000, 1.3772, 0.5737),
  ("Tensor", 1328000, 6, 851000, 1.3985, 0.6368),
  ("Tensor", 1328000, 6, 984000, 1.3933, 0.5311),
  ("Tensor", 1328000, 6, 1106000, 1.3932, 0.4567),
  ("Tensor", 1328000, 6, 1277000, 1.3984, 0.6616),
  ("Tensor", 1328000, 6, 1426000, 1.5067, 0.5776),
  ("Tensor", 1328000, 6, 1582000, 1.5167, 1.0309),
  ("Tensor", 1328000, 6, 1745000, 1.5021, 0.6845),
  ("Tensor", 1328000, 6, 1826000, 1.4775, 0.6285),
  ("Tensor", 1328000, 6, 2048000, 1.5237, 0.5402),
  ("Tensor", 1328000, 6, 2188000, 1.5349, 0.7490),
  ("Tensor", 1328000, 6, 2252000, 1.5436, 0.7984),
  ("Tensor", 1328000, 6, 2401000, 2.1755, 1.0387),
  ("Tensor", 1328000, 6, 2507000, 2.2320, 0.7382),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1328000, 6, 2630000, 2.2489, 1.1762),
  ("Tensor", 1401000, 4, 400000, 1.3279, 0.2793),
  ("Tensor", 1401000, 4, 553000, 1.3065, 0.3853),
  ("Tensor", 1401000, 4, 696000, 1.3290, 0.3016),
  ("Tensor", 1401000, 4, 799000, 1.2483, 0.3683),
  ("Tensor", 1401000, 4, 910000, 1.4059, 0.2825),
  ("Tensor", 1401000, 4, 1024000, 1.3702, 0.3389),
  ("Tensor", 1401000, 4, 1197000, 1.3920, 0.3614),
  ("Tensor", 1401000, 4, 1328000, 1.3752, 0.3310),
  ("Tensor", 1401000, 4, 1491000, 1.4015, 0.6546),
  ("Tensor", 1401000, 4, 1663000, 1.8982, 1.0324),
  ("Tensor", 1401000, 4, 1836000, 1.9447, 0.5336),
  ("Tensor", 1401000, 4, 1999000, 2.1219, 0.0662),
  ("Tensor", 1401000, 4, 2130000, 1.9576, 0.5584),
  ("Tensor", 1401000, 4, 2253000, 2.0221, 0.1254),
  ("Tensor", 1401000, 6, 500000, 1.5283, 0.5764),
  ("Tensor", 1401000, 6, 851000, 1.5211, 0.5643),
  ("Tensor", 1401000, 6, 984000, 1.5574, 0.7558),
  ("Tensor", 1401000, 6, 1106000, 1.5492, 0.7862),
  ("Tensor", 1401000, 6, 1277000, 1.5389, 0.7523),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1401000, 6, 1426000, 1.6449, 0.5993),
  ("Tensor", 1401000, 6, 1582000, 1.5953, 0.5512),
  ("Tensor", 1401000, 6, 1745000, 1.5672, 0.5489),
  ("Tensor", 1401000, 6, 1826000, 1.5639, 0.5507),
  ("Tensor", 1401000, 6, 2048000, 1.5878, 0.7536),
  ("Tensor", 1401000, 6, 2188000, 1.5562, 0.5431),
  ("Tensor", 1401000, 6, 2252000, 1.5908, 0.6087),
  ("Tensor", 1401000, 6, 2401000, 2.2693, 0.8953),
  ("Tensor", 1401000, 6, 2507000, 2.3182, 1.2289),
  ("Tensor", 1401000, 6, 2630000, 2.3090, 1.0687),
  ("Tensor", 1401000, 6, 2704000, 2.2751, 0.9966),
  ("Tensor", 1401000, 6, 2802000, 2.3278, 0.9065),
  ("Tensor", 1598000, 4, 400000, 1.7424, 0.8926),
  ("Tensor", 1598000, 4, 553000, 1.7003, 0.4482),
  ("Tensor", 1598000, 4, 696000, 1.6099, 0.5281),
  ("Tensor", 1598000, 4, 799000, 1.8018, 0.9634),
  ("Tensor", 1598000, 4, 910000, 1.7615, 0.3445),
  ("Tensor", 1598000, 4, 1024000, 1.7317, 0.3396),
  ("Tensor", 1598000, 4, 1197000, 1.7293, 0.5079),
  ("Tensor", 1598000, 4, 1328000, 1.8771, 0.4685),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 4, 1491000, 1.8724, 0.4693),
  ("Tensor", 1598000, 4, 1663000, 1.9587, 1.2295),
  ("Tensor", 1598000, 4, 1836000, 2.2287, 0.5220),
  ("Tensor", 1598000, 4, 1999000, 2.1786, 0.1494),
  ("Tensor", 1598000, 4, 2130000, 2.1631, 0.4924),
  ("Tensor", 1598000, 4, 2253000, 2.1703, 0.5427),
  ("Tensor", 1598000, 6, 500000, 1.9632, 0.9534),
  ("Tensor", 1598000, 6, 851000, 1.9820, 0.9433),
  ("Tensor", 1598000, 6, 984000, 1.9745, 0.8002),
  ("Tensor", 1598000, 6, 1106000, 1.9514, 0.8323),
  ("Tensor", 1598000, 6, 1277000, 1.9796, 1.1016),
  ("Tensor", 1598000, 6, 1426000, 1.9432, 0.8556),
  ("Tensor", 1598000, 6, 1582000, 2.0700, 0.8211),
  ("Tensor", 1598000, 6, 1745000, 2.0052, 0.9492),
  ("Tensor", 1598000, 6, 1826000, 2.0165, 0.7016),
  ("Tensor", 1598000, 6, 2048000, 2.0881, 0.6641),
  ("Tensor", 1598000, 6, 2188000, 2.1239, 0.8702),
  ("Tensor", 1598000, 6, 2252000, 2.0952, 1.1728),
  ("Tensor", 1598000, 6, 2401000, 2.4810, 0.9498),
  ("Tensor", 1598000, 6, 2507000, 2.4644, 0.9131),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1598000, 6, 2630000, 2.4030, 1.3728),
  ("Tensor", 1598000, 6, 2704000, 2.4271, 1.2680),
  ("Tensor", 1598000, 6, 2802000, 2.4761, 0.9789),
  ("Tensor", 1704000, 4, 400000, 1.9466, 0.9753),
  ("Tensor", 1704000, 4, 553000, 1.9336, 1.0846),
  ("Tensor", 1704000, 4, 696000, 1.9280, 0.2116),
  ("Tensor", 1704000, 4, 799000, 1.9616, 0.4219),
  ("Tensor", 1704000, 4, 910000, 1.9627, 0.1957),
  ("Tensor", 1704000, 4, 1024000, 1.9763, 0.5599),
  ("Tensor", 1704000, 4, 1197000, 1.9514, 0.4326),
  ("Tensor", 1704000, 4, 1328000, 2.0093, 0.4861),
  ("Tensor", 1704000, 4, 1491000, 1.9438, 0.1584),
  ("Tensor", 1704000, 4, 1663000, 2.3012, 0.6019),
  ("Tensor", 1704000, 4, 1836000, 2.2896, 0.5019),
  ("Tensor", 1704000, 4, 1999000, 2.2292, 0.6076),
  ("Tensor", 1704000, 4, 2130000, 2.2087, 0.5726),
  ("Tensor", 1704000, 4, 2253000, 2.2317, 0.4878),
  ("Tensor", 1704000, 6, 500000, 2.3606, 0.7822),
  ("Tensor", 1704000, 6, 851000, 2.2564, 0.9656),
  ("Tensor", 1704000, 6, 984000, 2.2618, 0.9988),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1704000, 6, 1106000, 2.2796, 0.9681),
  ("Tensor", 1704000, 6, 1277000, 2.2224, 0.8812),
  ("Tensor", 1704000, 6, 1426000, 2.2368, 1.0353),
  ("Tensor", 1704000, 6, 1582000, 2.3125, 0.8402),
  ("Tensor", 1704000, 6, 1745000, 2.3199, 0.7728),
  ("Tensor", 1704000, 6, 1826000, 2.3633, 0.8597),
  ("Tensor", 1704000, 6, 2048000, 2.2779, 0.6885),
  ("Tensor", 1704000, 6, 2188000, 2.2575, 1.0289),
  ("Tensor", 1704000, 6, 2252000, 2.2798, 0.9689),
  ("Tensor", 1704000, 6, 2401000, 2.5202, 1.0626),
  ("Tensor", 1704000, 6, 2507000, 2.4070, 0.8463),
  ("Tensor", 1704000, 6, 2630000, 2.5998, 1.0795),
  ("Tensor", 1704000, 6, 2704000, 2.6273, 1.0329),
  ("Tensor", 1704000, 6, 2802000, 2.6179, 0.7569),
  ("Tensor", 1803000, 4, 400000, 2.2197, 0.4673),
  ("Tensor", 1803000, 4, 553000, 2.3144, 0.5120),
  ("Tensor", 1803000, 4, 696000, 2.2720, 0.1952),
  ("Tensor", 1803000, 4, 799000, 2.3472, 0.5479),
  ("Tensor", 1803000, 4, 910000, 2.3035, 0.5622),
  ("Tensor", 1803000, 4, 1024000, 2.2129, 0.6828),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 4, 1197000, 2.3176, 0.1645),
  ("Tensor", 1803000, 4, 1328000, 2.3127, 0.4992),
  ("Tensor", 1803000, 4, 1491000, 2.1449, 1.4705),
  ("Tensor", 1803000, 4, 1663000, 2.3243, 0.6256),
  ("Tensor", 1803000, 4, 1836000, 2.1328, 0.6293),
  ("Tensor", 1803000, 4, 1999000, 2.3165, 0.5265),
  ("Tensor", 1803000, 4, 2130000, 2.2775, 0.6412),
  ("Tensor", 1803000, 4, 2253000, 2.4124, 0.5151),
  ("Tensor", 1803000, 6, 500000, 2.5536, 1.5678),
  ("Tensor", 1803000, 6, 851000, 2.5831, 1.1737),
  ("Tensor", 1803000, 6, 984000, 2.6063, 1.0591),
  ("Tensor", 1803000, 6, 1106000, 2.6951, 0.9158),
  ("Tensor", 1803000, 6, 1277000, 2.5400, 1.5096),
  ("Tensor", 1803000, 6, 1426000, 2.6623, 1.1037),
  ("Tensor", 1803000, 6, 1582000, 2.6996, 1.0774),
  ("Tensor", 1803000, 6, 1745000, 2.6692, 1.6543),
  ("Tensor", 1803000, 6, 1826000, 2.7288, 1.1255),
  ("Tensor", 1803000, 6, 2048000, 2.6649, 1.1010),
  ("Tensor", 1803000, 6, 2188000, 2.6489, 1.1485),
  ("Tensor", 1803000, 6, 2252000, 2.6389, 1.0942),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor", 1803000, 6, 2401000, 2.6256, 1.0997),
  ("Tensor", 1803000, 6, 2507000, 2.6630, 1.2641),
  ("Tensor", 1803000, 6, 2630000, 2.7385, 2.3263),
  ("Tensor", 1803000, 6, 2704000, 2.6901, 1.0629),
  ("Tensor", 1803000, 6, 2802000, 2.7476, 1.0673),
  ("Tensor G4", 820000, 255, 610000, 0.4824, 0.8357),
  ("Tensor G4", 955000, 255, 610000, 0.4801, 0.852),
  ("Tensor G4", 1098000, 255, 610000, 0.4988, 0.8219),
  ("Tensor G4", 1197000, 255, 610000, 0.5025, 0.8369),
  ("Tensor G4", 1328000, 255, 610000, 0.516, 0.8928),
  ("Tensor G4", 1425000, 255, 610000, 0.5266, 0.8895),
  ("Tensor G4", 1548000, 255, 610000, 0.5286, 0.915),
  ("Tensor G4", 1696000, 255, 610000, 0.5288, 1.0169),
  ("Tensor G4", 1849000, 255, 610000, 0.5326, 1.1313),
  ("Tensor G4", 1950000, 255, 610000, 0.5495, 1.1839),
  ("Tensor G4", 820000, 255, 820000, 0.4815, 0.8114),
  ("Tensor G4", 955000, 255, 820000, 0.5055, 0.9356),
  ("Tensor G4", 1098000, 255, 820000, 0.5168, 0.9567),
  ("Tensor G4", 1197000, 255, 820000, 0.5228, 0.8653),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1328000, 255, 820000, 0.5228, 0.8895),
  ("Tensor G4", 1425000, 255, 820000, 0.5309, 0.9692),
  ("Tensor G4", 1548000, 255, 820000, 0.5461, 0.9987),
  ("Tensor G4", 1696000, 255, 820000, 0.564, 1.053),
  ("Tensor G4", 1849000, 255, 820000, 0.5649, 0.9087),
  ("Tensor G4", 1950000, 255, 820000, 0.5737, 1.0893),
  ("Tensor G4", 820000, 255, 970000, 0.4923, 0.852),
  ("Tensor G4", 955000, 255, 970000, 0.5014, 0.8357),
  ("Tensor G4", 1098000, 255, 970000, 0.4952, 1.0169),
  ("Tensor G4", 1197000, 255, 970000, 0.5284, 0.8594),
  ("Tensor G4", 1328000, 255, 970000, 0.5332, 0.8521),
  ("Tensor G4", 1425000, 255, 970000, 0.5424, 0.8612),
  ("Tensor G4", 1548000, 255, 970000, 0.5641, 0.883),
  ("Tensor G4", 1696000, 255, 970000, 0.5524, 0.915),
  ("Tensor G4", 1849000, 255, 970000, 0.5685, 0.8765),
  ("Tensor G4", 1950000, 255, 970000, 0.5527, 0.8164),
  ("Tensor G4", 820000, 255, 1098000, 0.5084, 0.947),
  ("Tensor G4", 955000, 255, 1098000, 0.5177, 0.8058),
  ("Tensor G4", 1098000, 255, 1098000, 0.5284, 0.763),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1197000, 255, 1098000, 0.596, 0.8633),
  ("Tensor G4", 1328000, 255, 1098000, 0.596, 0.8633),
  ("Tensor G4", 1425000, 255, 1098000, 0.5373, 0.7504),
  ("Tensor G4", 1548000, 255, 1098000, 0.5186, 0.8604),
  ("Tensor G4", 1696000, 255, 1098000, 0.5772, 89.73),
  ("Tensor G4", 1849000, 255, 1098000, 0.5758, 0.9588),
  ("Tensor G4", 1950000, 255, 1098000, 0.5904, 1.1074),
  ("Tensor G4", 820000, 255, 1197000, 0.5105, 0.866),
  ("Tensor G4", 955000, 255, 1197000, 0.5241, 0.8533),
  ("Tensor G4", 1098000, 255, 1197000, 0.5347, 0.8569),
  ("Tensor G4", 1197000, 255, 1197000, 0.524, 0.8318),
  ("Tensor G4", 1328000, 255, 1197000, 0.5298, 0.8374),
  ("Tensor G4", 1425000, 255, 1197000, 0.5201, 0.9479),
  ("Tensor G4", 1548000, 255, 1197000, 0.497, 0.9093),
  ("Tensor G4", 1696000, 255, 1197000, 0.5007, 0.8765),
  ("Tensor G4", 1849000, 255, 1197000, 0.6107, 0.8682),
  ("Tensor G4", 1950000, 255, 1197000, 0.5888, 0.9738),
  ("Tensor G4", 820000, 255, 1328000, 0.534, 0.9162),
  ("Tensor G4", 955000, 255, 1328000, 0.5551, 0.9499),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1098000, 255, 1328000, 0.556, 0.954),
  ("Tensor G4", 1197000, 255, 1328000, 0.5711, 0.9117),
  ("Tensor G4", 1328000, 255, 1328000, 0.5372, 0.956),
  ("Tensor G4", 1425000, 255, 1328000, 0.5482, 0.934),
  ("Tensor G4", 1548000, 255, 1328000, 0.5615, 0.7495),
  ("Tensor G4", 1696000, 255, 1328000, 0.53, 0.9145),
  ("Tensor G4", 1849000, 255, 1328000, 0.5504, 0.9478),
  ("Tensor G4", 1950000, 255, 1328000, 0.6243, 0.9335),
  ("Tensor G4", 820000, 255, 1444000, 0.5437, 0.9403),
  ("Tensor G4", 955000, 255, 1444000, 0.5635, 0.9997),
  ("Tensor G4", 1098000, 255, 1444000, 0.5711, 0.919),
  ("Tensor G4", 1197000, 255, 1444000, 0.5595, 0.9455),
  ("Tensor G4", 1328000, 255, 1444000, 0.5772, 0.9415),
  ("Tensor G4", 1425000, 255, 1444000, 0.5507, 0.9582),
  ("Tensor G4", 1548000, 255, 1444000, 0.5535, 0.8986),
  ("Tensor G4", 1696000, 255, 1444000, 0.507, 0.9369),
  ("Tensor G4", 1849000, 255, 1444000, 0.628, 0.8878),
  ("Tensor G4", 1950000, 255, 1444000, 0.658, 1.0974),
  ("Tensor G4", 820000, 255, 1548000, 0.578, 0.8322),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 955000, 255, 1548000, 0.603, 0.9371),
  ("Tensor G4", 1098000, 255, 1548000, 0.6163, 0.962),
  ("Tensor G4", 1197000, 255, 1548000, 0.6105, 0.9323),
  ("Tensor G4", 1328000, 255, 1548000, 0.589, 0.8355),
  ("Tensor G4", 1425000, 255, 1548000, 0.5924, 0.9416),
  ("Tensor G4", 1548000, 255, 1548000, 0.5611, 0.8911),
  ("Tensor G4", 1696000, 255, 1548000, 0.5792, 0.905),
  ("Tensor G4", 1849000, 255, 1548000, 0.6021, 0.9761),
  ("Tensor G4", 1950000, 255, 1548000, 0.6579, 1.0438),
  ("Tensor G4", 820000, 255, 1704000, 1.5584, 1.2388),
  ("Tensor G4", 955000, 255, 1704000, 1.5287, 1.104),
  ("Tensor G4", 1098000, 255, 1704000, 1.6412, 1.2419),
  ("Tensor G4", 1197000, 255, 1704000, 1.9947, 1.318),
  ("Tensor G4", 1328000, 255, 1704000, 1.6701, 1.178),
  ("Tensor G4", 1425000, 255, 1704000, 1.5944, 1.3017),
  ("Tensor G4", 1548000, 255, 1704000, 1.6769, 1.6058),
  ("Tensor G4", 1696000, 255, 1704000, 1.7215, 1.8),
  ("Tensor G4", 1849000, 255, 1704000, 1.9143, 2.0842),
  ("Tensor G4", 1950000, 255, 1704000, 1.932, 2.8572),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 820000, 255, 1800000, 1.575, 1.5401),
  ("Tensor G4", 955000, 255, 1800000, 1.6833, 1.5087),
  ("Tensor G4", 1098000, 255, 1800000, 1.5571, 2.0737),
  ("Tensor G4", 1197000, 255, 1800000, 1.6815, 1.8473),
  ("Tensor G4", 1328000, 255, 1800000, 1.7828, 1.666),
  ("Tensor G4", 1425000, 255, 1800000, 1.8061, 1.8018),
  ("Tensor G4", 1548000, 255, 1800000, 1.9956, 1.64),
  ("Tensor G4", 1696000, 255, 1800000, 1.8592, 1.701),
  ("Tensor G4", 1849000, 255, 1800000, 1.5758, 1.5364),
  ("Tensor G4", 1950000, 255, 1800000, 1.9823, 1.7952),
  ("Tensor G4", 820000, 255, 1880000, 1.7249, 1.7787),
  ("Tensor G4", 955000, 255, 1880000, 1.7635, 2.0677),
  ("Tensor G4", 1098000, 255, 1880000, 1.805, 1.5907),
  ("Tensor G4", 1197000, 255, 1880000, 1.7293, 2.0645),
  ("Tensor G4", 1328000, 255, 1880000, 1.918, 1.9844),
  ("Tensor G4", 1425000, 255, 1880000, 2.0013, 1.5541),
  ("Tensor G4", 1548000, 255, 1880000, 2.0504, 1.9877),
  ("Tensor G4", 1696000, 255, 1880000, 1.9603, 1.8955),
  ("Tensor G4", 1849000, 255, 1880000, 2.1168, 1.9674),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1950000, 255, 1880000, 2.2047, 2.4697),
  ("Tensor G4", 820000, 255, 1950000, 1.9756, 1.4938),
  ("Tensor G4", 955000, 255, 1950000, 1.90147, 1.8144),
  ("Tensor G4", 1098000, 255, 1950000, 2.1539, 2.0811),
  ("Tensor G4", 1197000, 255, 1950000, 2.2192, 1.8968),
  ("Tensor G4", 1328000, 255, 1950000, 2.2974, 2.1572),
  ("Tensor G4", 1425000, 255, 1950000, 2.3865, 2.2972),
  ("Tensor G4", 1548000, 255, 1950000, 2.4361, 2.3942),
  ("Tensor G4", 1696000, 255, 1950000, 2.8677, 2.2737),
  ("Tensor G4", 1849000, 255, 1950000, 2.6123, 2.5181),
  ("Tensor G4", 1950000, 255, 1950000, 2.7293, 2.5798),
  ("Tensor G4", 820000, 255, 2024000, 2.0136, 1.7557),
  ("Tensor G4", 955000, 255, 2024000, 1.9834, 1.6844),
  ("Tensor G4", 1098000, 255, 2024000, 2.1129, 1.8735),
  ("Tensor G4", 1197000, 255, 2024000, 2.5894, 2.2185),
  ("Tensor G4", 1328000, 255, 2024000, 2.6949, 2.1905),
  ("Tensor G4", 1425000, 255, 2024000, 2.8143, 2.7641),
  ("Tensor G4", 1548000, 255, 2024000, 2.8513, 2.6064),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1696000, 255, 2024000, 2.663, 2.3265),
  ("Tensor G4", 1849000, 255, 2024000, 2.6618, 2.595),
  ("Tensor G4", 1950000, 255, 2024000, 2.7227, 2.7533),
  ("Tensor G4", 820000, 255, 2120000, 2.5414, 2.6693),
  ("Tensor G4", 955000, 255, 2120000, 2.7682, 2.7252),
  ("Tensor G4", 1098000, 255, 2120000, 3.1524, 2.8636),
  ("Tensor G4", 1197000, 255, 2120000, 3.0192, 2.6325),
  ("Tensor G4", 1328000, 255, 2120000, 2.9797, 3.1899),
  ("Tensor G4", 1425000, 255, 2120000, 3.176, 3.069),
  ("Tensor G4", 1548000, 255, 2120000, 3.1105, 2.2982),
  ("Tensor G4", 1696000, 255, 2120000, 2.9221, 3.2752),
  ("Tensor G4", 1849000, 255, 2120000, 3.2659, 3.0112),
  ("Tensor G4", 1950000, 255, 2120000, 3.1351, 3.5576),
  ("Tensor G4", 820000, 255, 2150000, 2.9947, 2.6827),
  ("Tensor G4", 955000, 255, 2150000, 2.9357, 2.5455),
  ("Tensor G4", 1098000, 255, 2150000, 3.1562, 2.8923),
  ("Tensor G4", 1197000, 255, 2150000, 3.0068, 3.2811),
  ("Tensor G4", 1328000, 255, 2150000, 3.1187, 3.0526),
  ("Tensor G4", 1425000, 255, 2150000, 3.2907, 2.9659),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("Tensor G4", 1548000, 255, 2150000, 2.9841, 3.347),
  ("Tensor G4", 1696000, 255, 2150000, 3.2313, 3.1632),
  ("Tensor G4", 1849000, 255, 2150000, 3.091, 3.1305),
  ("Tensor G4", 1950000, 255, 2150000, 3.326, 3.0211)
)
select * from data;


)_d3l1m1t3r_"
;

const char kWattsonCurvesEstimates[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.cpu_split;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.curves.w_cpu_dependence;
INCLUDE PERFETTO MODULE wattson.curves.w_dsu_dependence;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- One of the two tables will be empty, depending on whether the device is
-- dependent on devfreq or a different CPU's frequency
CREATE PERFETTO VIEW _curves_w_dependencies(
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ts TIMESTAMP,
  dur DURATION,
  freq_0 LONG,
  idle_0 LONG,
  freq_1 LONG,
  idle_1 LONG,
  freq_2 LONG,
  idle_2 LONG,
  freq_3 LONG,
  idle_3 LONG,
  cpu0_curve DOUBLE,
  cpu1_curve DOUBLE,
  cpu2_curve DOUBLE,
  cpu3_curve DOUBLE,
  cpu4_curve DOUBLE,
  cpu5_curve DOUBLE,
  cpu6_curve DOUBLE,
  cpu7_curve DOUBLE,
  l3_hit_count LONG,
  l3_miss_count LONG,
  no_static LONG,
  all_cpu_deep_idle LONG,
  dependent_freq LONG,
  dependent_policy LONG
) AS
-- Table that is dependent on differet CPU's frequency
SELECT * FROM _w_cpu_dependence
UNION ALL
-- Table that is dependent of devfreq frequency
SELECT * FROM _w_dsu_dependence;

-- Final table showing the curves per CPU per slice
CREATE PERFETTO TABLE _system_state_curves
AS
SELECT
  base.ts,
  base.dur,
  -- base.cpu[0-3]_curve will be non-zero if CPU has 1D dependency
  -- base.cpu[0-3]_curve will be zero if device is suspended or deep idle
  -- base.cpu[0-3]_curve will be NULL if 2D dependency required
  COALESCE(base.cpu0_curve, lut0.curve_value) as cpu0_curve,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  COALESCE(base.cpu1_curve, lut1.curve_value) as cpu1_curve,
  COALESCE(base.cpu2_curve, lut2.curve_value) as cpu2_curve,
  COALESCE(base.cpu3_curve, lut3.curve_value) as cpu3_curve,
  -- base.cpu[4-7]_curve will be non-zero if CPU has 1D dependency
  -- base.cpu[4-7]_curve will be zero if device is suspended or deep idle
  -- base.cpu[4-7]_curve will be NULL if CPU doesn't exist on device
  COALESCE(base.cpu4_curve, 0.0) as cpu4_curve,
  COALESCE(base.cpu5_curve, 0.0) as cpu5_curve,
  COALESCE(base.cpu6_curve, 0.0) as cpu6_curve,
  COALESCE(base.cpu7_curve, 0.0) as cpu7_curve,
  IIF(
    no_static = 1,
    0.0,
    COALESCE(static_1d.curve_value, static_2d.curve_value)
  ) as static_curve,
  IIF(
    all_cpu_deep_idle = 1,
    0,
    base.l3_hit_count * l3_hit_lut.curve_value
  ) as l3_hit_value,
  IIF(
    all_cpu_deep_idle = 1,
    0,
    base.l3_miss_count * l3_miss_lut.curve_value
  ) as l3_miss_value
FROM _curves_w_dependencies as base
-- LUT for 2D dependencies
LEFT JOIN _filtered_curves_2d lut0 ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  lut0.freq_khz = base.freq_0 AND
  lut0.other_policy = base.dependent_policy AND
  lut0.other_freq_khz = base.dependent_freq AND
  lut0.idle = base.idle_0
LEFT JOIN _filtered_curves_2d lut1 ON
  lut1.freq_khz = base.freq_1 AND
  lut1.other_policy = base.dependent_policy AND
  lut1.other_freq_khz = base.dependent_freq AND
  lut1.idle = base.idle_1
LEFT JOIN _filtered_curves_2d lut2 ON
  lut2.freq_khz = base.freq_2 AND
  lut2.other_policy = base.dependent_policy AND
  lut2.other_freq_khz = base.dependent_freq AND
  lut2.idle = base.idle_2
LEFT JOIN _filtered_curves_2d lut3 ON
  lut3.freq_khz = base.freq_3 AND
  lut3.other_policy = base.dependent_policy AND
  lut3.other_freq_khz = base.dependent_freq AND
  lut3.idle = base.idle_3
-- LUT for static curve lookup
LEFT JOIN _filtered_curves_2d static_2d ON
  static_2d.freq_khz = base.freq_0 AND
  static_2d.other_policy = base.dependent_policy AND
  static_2d.other_freq_khz = base.dependent_freq AND
  static_2d.idle = 255
LEFT JOIN _filtered_curves_1d static_1d ON
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  static_1d.policy = 0 AND
  static_1d.freq_khz = base.freq_0 AND
  static_1d.idle = 255
-- LUT joins for L3 cache
LEFT JOIN _filtered_curves_l3 l3_hit_lut ON
  l3_hit_lut.freq_khz = base.freq_0 AND
  l3_hit_lut.other_policy = base.dependent_policy AND
  l3_hit_lut.other_freq_khz = base.dependent_freq AND
  l3_hit_lut.action = 'hit'
LEFT JOIN _filtered_curves_l3 l3_miss_lut ON
  l3_miss_lut.freq_khz = base.freq_0 AND
  l3_miss_lut.other_policy = base.dependent_policy AND
  l3_miss_lut.other_freq_khz = base.dependent_freq AND
  l3_miss_lut.action = 'miss';

-- The most basic components of Wattson, all normalized to be in mW on a per
-- system state basis
CREATE PERFETTO TABLE _system_state_mw
AS
SELECT
  ts,
  dur,
  cpu0_curve as cpu0_mw,
  cpu1_curve as cpu1_mw,
  cpu2_curve as cpu2_mw,
  cpu3_curve as cpu3_mw,
  cpu4_curve as cpu4_mw,
  cpu5_curve as cpu5_mw,
  cpu6_curve as cpu6_mw,
  cpu7_curve as cpu7_mw,
  -- LUT for l3 is scaled by 10^6 to save resolution and in units of kWs. Scale
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  -- this by 10^3 so when divided by ns, result is in units of mW
  (
    (
      IFNULL(l3_hit_value, 0) + IFNULL(l3_miss_value, 0)
    ) * 1000 / dur
  ) + static_curve as dsu_scu_mw
FROM _system_state_curves;

-- API to get power from each system state in an arbitrary time window
CREATE PERFETTO FUNCTION _windowed_system_state_mw(ts TIMESTAMP, dur LONG)
RETURNS TABLE(
  cpu0_mw DOUBLE,
  cpu1_mw DOUBLE,
  cpu2_mw DOUBLE,
  cpu3_mw DOUBLE,
  cpu4_mw DOUBLE,
  cpu5_mw DOUBLE,
  cpu6_mw DOUBLE,
  cpu7_mw DOUBLE,
  dsu_scu_mw DOUBLE
) AS
SELECT
  SUM(ss.cpu0_mw * ss.dur) / SUM(ss.dur) AS cpu0_mw,
  SUM(ss.cpu1_mw * ss.dur) / SUM(ss.dur) AS cpu1_mw,
  SUM(ss.cpu2_mw * ss.dur) / SUM(ss.dur) AS cpu2_mw,
  SUM(ss.cpu3_mw * ss.dur) / SUM(ss.dur) AS cpu3_mw,
  SUM(ss.cpu4_mw * ss.dur) / SUM(ss.dur) AS cpu4_mw,
  SUM(ss.cpu5_mw * ss.dur) / SUM(ss.dur) AS cpu5_mw,
  SUM(ss.cpu6_mw * ss.dur) / SUM(ss.dur) AS cpu6_mw,
  SUM(ss.cpu7_mw * ss.dur) / SUM(ss.dur) AS cpu7_mw,
  SUM(ss.dsu_scu_mw * ss.dur) / SUM(ss.dur) AS dsu_scu_mw
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _interval_intersect_single!($ts, $dur, _ii_subquery!(_system_state_mw)) ii
JOIN _system_state_mw AS ss ON ss._auto_id = id;

)_d3l1m1t3r_"
;

const char kWattsonCurvesIdleAttribution[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE wattson.curves.estimates;

-- Get slice info of threads/processes
CREATE PERFETTO TABLE _thread_process_slices AS
SELECT
  sched.ts,
  sched.dur,
  sched.cpu,
  thread.utid,
  thread.upid
FROM thread
JOIN sched USING (utid)
WHERE dur > 0;

-- Helper macro so Perfetto tables can be used with interval intersect
CREATE PERFETTO MACRO _ii_table(tab TableOrSubquery)
)_d3l1m1t3r_"
R"_d3l1m1t3r_(RETURNS TableOrSubquery AS (SELECT _auto_id AS id, * FROM $tab);

-- Get slices only where there is transition from deep idle to active
CREATE PERFETTO TABLE _idle_exits AS
SELECT
  ts,
  dur,
  cpu,
  idle
FROM _adjusted_deep_idle
WHERE idle = -1 and dur > 0;

-- Gets the slices where the CPU transitions from deep idle to active, and the
-- associated thread that causes the idle exit
CREATE PERFETTO TABLE _idle_w_threads AS
WITH _ii_idle_threads AS (
  SELECT
    ii.ts,
    ii.dur,
    ii.cpu,
    threads.utid,
    threads.upid,
    id_1 as idle_group
  FROM _interval_intersect!(
    (
      _ii_table!(_thread_process_slices),
      _ii_table!(_idle_exits)
    ),
    (cpu)
  ) ii
  JOIN _thread_process_slices AS threads
    ON threads._auto_id = id_0
),
-- Since sorted by time, MIN() is fast aggregate function that will return the
-- first time slice, which will be the utid = 0 slice immediately succeeding the
-- idle to active transition, and immediately preceding the active thread
first_swapper_slice AS (
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  SELECT
    ts,
    dur,
    cpu,
    idle_group,
    MIN(ts) as min
  FROM _ii_idle_threads
  GROUP BY idle_group
),
-- MIN() here will give the first active thread immediately succeeding the idle
-- to active transition slice, which means this the the thread that causes the
-- idle exit
first_non_swapper_slice AS (
  SELECT
    idle_group,
    utid,
    upid,
    MIN(ts) as min,
    MIN(ts) + dur as next_ts
  FROM _ii_idle_threads
  WHERE utid != 0
  GROUP BY idle_group
),
-- MAX() here will give the last time slice in the group. This will be the
-- utid = 0 slice immediately preceding the active to idle transition.
last_swapper_slice AS (
  SELECT
    ts,
    dur,
    cpu,
    idle_group,
    MAX(ts) as min
  FROM _ii_idle_threads
  GROUP BY idle_group
)
SELECT
  swapper_info.ts,
  swapper_info.dur,
  swapper_info.cpu,
  thread_info.utid,
  thread_info.upid
FROM first_non_swapper_slice thread_info
JOIN first_swapper_slice swapper_info USING (idle_group)
UNION ALL
-- Adds the last slice to idle transition attribution IF this is a singleton
)_d3l1m1t3r_"
R"_d3l1m1t3r_(-- thread wakeup. This is true if there is only one thread between swapper idle
-- exits/wakeups. For example, groups with order of swapper, thread X, swapper
-- will be included. Entries that have multiple thread between swappers, such as
-- swapper, thread X, thread Y, swapper will not be included.
SELECT
  swapper_info.ts,
  swapper_info.dur,
  swapper_info.cpu,
  thread_info.utid,
  thread_info.upid
FROM first_non_swapper_slice thread_info
JOIN last_swapper_slice swapper_info USING (idle_group)
WHERE ts = next_ts;

-- Interval intersect with the estimate power track, so that each slice can be
-- attributed to the power of the CPU in that time duration
CREATE PERFETTO TABLE _idle_transition_cost AS
SELECT
  ii.ts,
  ii.dur,
  threads.cpu,
  threads.utid,
  threads.upid,
  CASE threads.cpu
    WHEN 0 THEN power.cpu0_mw
    WHEN 1 THEN power.cpu1_mw
    WHEN 2 THEN power.cpu2_mw
    WHEN 3 THEN power.cpu3_mw
    WHEN 4 THEN power.cpu4_mw
    WHEN 5 THEN power.cpu5_mw
    WHEN 6 THEN power.cpu6_mw
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    WHEN 7 THEN power.cpu7_mw
    ELSE 0
  END estimated_mw
FROM _interval_intersect!(
  (
    _ii_table!(_idle_w_threads),
    _ii_table!(_system_state_mw)
  ),
  ()
) ii
JOIN _idle_w_threads as threads ON threads._auto_id = id_0
JOIN _system_state_mw as power ON power._auto_id = id_1;

-- Macro for easily filtering idle attribution to a specified time window. This
-- information can then further be filtered by specific CPU and GROUP BY on
-- either utid or upid
CREATE PERFETTO FUNCTION _filter_idle_attribution(ts TIMESTAMP, dur LONG)
RETURNS Table(idle_cost_mws LONG, utid JOINID(thread.id), upid JOINID(process.id), cpu LONG) AS
SELECT
  cost.estimated_mw * cost.dur / 1e9 as idle_cost_mws,
  cost.utid,
  cost.upid,
  cost.cpu
FROM _interval_intersect_single!(
  $ts, $dur, _ii_table!(_idle_transition_cost)
) ii
JOIN _idle_transition_cost as cost ON cost._auto_id = id;

)_d3l1m1t3r_"
;

const char kWattsonCurvesUtils[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.curves.device;
INCLUDE PERFETTO MODULE wattson.device_infos;

-- 1D LUT
CREATE PERFETTO TABLE _filtered_curves_1d_raw AS
SELECT cp.policy, freq_khz, active, idle0, idle1, static
FROM _device_curves_1d as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.policy = cp.policy;

CREATE PERFETTO TABLE _filtered_curves_1d AS
)_d3l1m1t3r_"
R"_d3l1m1t3r_(SELECT policy, freq_khz, -1 as idle, active as curve_value
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 0, idle0
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 1, idle1
FROM _filtered_curves_1d_raw
UNION
SELECT policy, freq_khz, 255, static
FROM _filtered_curves_1d_raw;

CREATE PERFETTO INDEX freq_1d ON _filtered_curves_1d(policy, freq_khz, idle);

-- 2D LUT; with dependency on another CPU
CREATE PERFETTO TABLE _filtered_curves_2d_raw AS
SELECT
  cp.policy as other_policy,
  dc.freq_khz,
  dc.other_freq_khz,
  dc.active,
  dc.idle0,
  dc.idle1,
  dc.static
FROM _device_curves_2d as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.other_policy = cp.policy;

CREATE PERFETTO TABLE _filtered_curves_2d AS
SELECT freq_khz, other_policy, other_freq_khz, -1 as idle, active as curve_value
FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 0, idle0
FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 1, idle1
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _filtered_curves_2d_raw
UNION
SELECT freq_khz, other_policy, other_freq_khz, 255, static
FROM _filtered_curves_2d_raw;

CREATE PERFETTO INDEX freq_2d
ON _filtered_curves_2d(freq_khz, other_policy, other_freq_khz, idle);

-- L3 cache LUT
CREATE PERFETTO TABLE _filtered_curves_l3_raw AS
SELECT
  cp.policy as other_policy,
  dc.freq_khz,
  dc.other_freq_khz,
  dc.l3_hit,
  dc.l3_miss
FROM _device_curves_l3 as dc
JOIN _wattson_device as device ON dc.device = device.name
JOIN _dev_cpu_policy_map as cp ON dc.other_policy = cp.policy;

CREATE PERFETTO TABLE _filtered_curves_l3 AS
SELECT
  freq_khz, other_policy, other_freq_khz, 'hit' AS action, l3_hit as curve_value
FROM _filtered_curves_l3_raw
UNION
SELECT
  freq_khz, other_policy, other_freq_khz, 'miss' AS action, l3_miss
FROM _filtered_curves_l3_raw;

CREATE PERFETTO INDEX freq_l3
ON _filtered_curves_l3(freq_khz, other_policy, other_freq_khz, action);

)_d3l1m1t3r_"
;

const char kWattsonCurvesWCpuDependence[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.cpu_split;

-- Find the CPU states creating the max vote
CREATE PERFETTO TABLE _w_cpu_dependence
AS
WITH max_power_tbl AS (
  SELECT
    *,
    -- Indicates if all CPUs are in deep idle
    MIN(
      no_static,
      IFNULL(idle_4, 1),
      IFNULL(idle_5, 1),
      IFNULL(idle_6, 1),
      IFNULL(idle_7, 1)
    ) as all_cpu_deep_idle,
    -- Determines which CPU has highest vote
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    MAX(
      static_4,
      static_5,
      static_6,
      static_7
    ) as max_static_vote
  FROM _w_independent_cpus_calc
  -- _skip_devfreq_for_calc short circuits this table if devfreq is needed
  JOIN _skip_devfreq_for_calc
)
SELECT
  ts,
  dur,
  freq_0, idle_0,
  freq_1, idle_1,
  freq_2, idle_2,
  freq_3, idle_3,
  cpu0_curve,
  cpu1_curve,
  cpu2_curve,
  cpu3_curve,
  cpu4_curve,
  cpu5_curve,
  cpu6_curve,
  cpu7_curve,
  l3_hit_count,
  l3_miss_count,
  no_static,
  all_cpu_deep_idle,
  CASE max_static_vote
    WHEN -1 THEN _get_min_freq_vote()
    WHEN static_4 THEN freq_4
    WHEN static_5 THEN freq_5
    WHEN static_6 THEN freq_6
    WHEN static_7 THEN freq_7
    ELSE 400000
  END dependent_freq,
  CASE max_static_vote
    WHEN -1 THEN _get_min_policy_vote()
    WHEN static_4 THEN policy_4
    WHEN static_5 THEN policy_5
    WHEN static_6 THEN policy_6
    WHEN static_7 THEN policy_7
    ELSE 4
  END dependent_policy
FROM max_power_tbl;

)_d3l1m1t3r_"
;

const char kWattsonCurvesWDsuDependence[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE intervals.intersect;
INCLUDE PERFETTO MODULE linux.devfreq;
INCLUDE PERFETTO MODULE wattson.cpu_split;
INCLUDE PERFETTO MODULE wattson.curves.utils;
INCLUDE PERFETTO MODULE wattson.device_infos;

CREATE PERFETTO TABLE _cpu_curves AS
SELECT
  ts, dur,
  freq_0, idle_0,
  freq_1, idle_1,
  freq_2, idle_2,
  freq_3, idle_3,
  lut4.curve_value as cpu4_curve,
  lut5.curve_value as cpu5_curve,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  lut6.curve_value as cpu6_curve,
  lut7.curve_value as cpu7_curve,
  l3_hit_count, l3_miss_count,
  no_static,
  MIN(
    no_static,
    IFNULL(idle_4, 1),
    IFNULL(idle_5, 1),
    IFNULL(idle_6, 1),
    IFNULL(idle_7, 1)
  ) as all_cpu_deep_idle
FROM _w_independent_cpus_calc as base
-- _use_devfreq_for_calc short circuits this table if devfreq isn't needed
JOIN _use_devfreq_for_calc
LEFT JOIN _filtered_curves_1d lut4 ON
  base.freq_4 = lut4.freq_khz AND
  base.idle_4 = lut4.idle
LEFT JOIN _filtered_curves_1d lut5 ON
  base.freq_5 = lut5.freq_khz AND
  base.idle_5 = lut5.idle
LEFT JOIN _filtered_curves_1d lut6 ON
  base.freq_6 = lut6.freq_khz AND
  base.idle_6 = lut6.idle
LEFT JOIN _filtered_curves_1d lut7 ON
  base.freq_7 = lut7.freq_khz AND
  base.idle_7 = lut7.idle;

-- Get nominal devfreq_dsu counter, OR use a dummy one for Pixel 9 VM traces
-- The VM doesn't have a DSU, so the placeholder value of FMin is put in. The
-- DSU frequency is a prerequisite for power estimation on Pixel 9.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _dsu_frequency AS
SELECT * from linux_devfreq_dsu_counter
UNION ALL
SELECT
 0 as id,
 trace_start() as ts,
 trace_end() - trace_start() as dur,
 610000 as dsu_freq
-- Only add this for traces from a VM on Pixel 9 where DSU values aren't present
WHERE (SELECT str_value FROM metadata WHERE name = 'android_guest_soc_model')
  IN (SELECT device FROM _use_devfreq)
  AND (SELECT COUNT(*) FROM linux_devfreq_dsu_counter) = 0;

CREATE PERFETTO TABLE _w_dsu_dependence AS
SELECT
  c.ts, c.dur,
  c.freq_0, c.idle_0,
  c.freq_1, c.idle_1,
  c.freq_2, c.idle_2,
  c.freq_3, c.idle_3,
  -- NULL columns needed to match columns of _get_max_vote before UNION
  NULL as cpu0_curve,
  NULL as cpu1_curve,
  NULL as cpu2_curve,
  NULL as cpu3_curve,
  c.cpu4_curve,
  c.cpu5_curve,
  c.cpu6_curve,
  c.cpu7_curve,
  c.l3_hit_count,
  c.l3_miss_count,
  c.no_static,
  c.all_cpu_deep_idle,
  d.dsu_freq as dependent_freq,
  255 as dependent_policy
FROM _interval_intersect!(
  (
    _ii_subquery!(_cpu_curves),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    _ii_subquery!(_dsu_frequency)
  ),
  ()
) ii
JOIN _cpu_curves AS c ON c._auto_id = id_0
JOIN _dsu_frequency AS d on d._auto_id = id_1;


)_d3l1m1t3r_"
;

const char kWattsonDeviceInfos[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE android.device;

-- Device specific info for deep idle time offsets
CREATE PERFETTO TABLE _device_cpu_deep_idle_offsets
AS
WITH data(device, cpu, offset_ns) AS (
  VALUES
  ("Tensor", 0, 0),
  ("Tensor", 1, 0),
  ("Tensor", 2, 0),
  ("Tensor", 3, 0),
  ("Tensor", 4, 0),
  ("Tensor", 5, 0),
  ("Tensor", 6, 200000),
  ("Tensor", 7, 200000),
  ("monaco", 0, 450000),
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  ("monaco", 1, 450000),
  ("monaco", 2, 450000),
  ("monaco", 3, 450000),
  ("Tensor G4", 0, 0),
  ("Tensor G4", 1, 0),
  ("Tensor G4", 2, 0),
  ("Tensor G4", 3, 0),
  ("Tensor G4", 4, 110000),
  ("Tensor G4", 5, 110000),
  ("Tensor G4", 6, 110000),
  ("Tensor G4", 7, 400000)
)
select * from data;

CREATE PERFETTO TABLE _wattson_device_map
AS
WITH data(device, wattson_device) AS (
  VALUES
  ("oriole", "Tensor"),
  ("raven", "Tensor"),
  ("bluejay", "Tensor"),
  ("eos", "monaco"),
  ("aurora", "monaco")
)
select * from data;

CREATE PERFETTO TABLE _wattson_device AS
WITH soc_model AS (
  SELECT COALESCE(
    -- Get guest model from metadata, which takes precedence if set
    (SELECT str_value FROM metadata WHERE name = 'android_guest_soc_model'),
    -- Get model from metadata
    (SELECT str_value FROM metadata WHERE name = 'android_soc_model'),
    -- Get device name from metadata and map it to model
    (
      SELECT wattson_device
      FROM _wattson_device_map map
      JOIN android_device_name ad ON ad.name = map.device
)_d3l1m1t3r_"
R"_d3l1m1t3r_(    )
  ) as name
)
-- Once model is obtained, check to see if the model is supported by Wattson
-- via checking if model is within a key-value pair mapping
SELECT DISTINCT name
FROM soc_model
JOIN _device_cpu_deep_idle_offsets AS map ON map.device = name;

-- Device specific mapping from CPU to policy
CREATE PERFETTO TABLE _cpu_to_policy_map
AS
WITH data(device, cpu, policy) AS (
  VALUES
  ("monaco", 0, 0),
  ("monaco", 1, 0),
  ("monaco", 2, 0),
  ("monaco", 3, 0),
  ("Tensor", 0, 0),
  ("Tensor", 1, 0),
  ("Tensor", 2, 0),
  ("Tensor", 3, 0),
  ("Tensor", 4, 4),
  ("Tensor", 5, 4),
  ("Tensor", 6, 6),
  ("Tensor", 7, 6),
  ("Tensor G4", 0, 0),
  ("Tensor G4", 1, 0),
  ("Tensor G4", 2, 0),
  ("Tensor G4", 3, 0),
  ("Tensor G4", 4, 4),
  ("Tensor G4", 5, 4),
  ("Tensor G4", 6, 4),
  ("Tensor G4", 7, 7),
  -- need 255 policy to match devfreq
  ("Tensor G4", 255, 255)
)
select * from data;

-- Prefilter table based on device
CREATE PERFETTO TABLE _dev_cpu_policy_map
AS
SELECT
  cpu, policy
)_d3l1m1t3r_"
R"_d3l1m1t3r_(FROM _cpu_to_policy_map as cp_map
JOIN _wattson_device as device
ON cp_map.device = device.name
ORDER by cpu;

-- Policy and freq that will give minimum volt vote
CREATE PERFETTO TABLE _device_min_volt_vote
AS
WITH data(device, policy, freq) AS (
  VALUES
  ("monaco", 0, 614400),
  ("Tensor", 4, 400000),
  ("Tensor G4", 0, 700000)
)
select * from data;

-- Get policy corresponding to minimum volt vote
CREATE PERFETTO FUNCTION _get_min_policy_vote()
RETURNS LONG AS
SELECT
  vote_tbl.policy
FROM _device_min_volt_vote as vote_tbl
JOIN _wattson_device as device
WHERE vote_tbl.device = device.name;

-- Get frequency corresponding to minimum volt vote
CREATE PERFETTO FUNCTION _get_min_freq_vote()
RETURNS LONG AS
SELECT
 vote_tbl.freq
FROM _device_min_volt_vote as vote_tbl
JOIN _wattson_device as device
WHERE vote_tbl.device = device.name;

-- Devices that require using devfreq
CREATE PERFETTO TABLE _use_devfreq
AS
WITH data(device) AS (
  VALUES
  ("Tensor G4")
)
select * from data;

-- Creates non-empty table if device needs devfreq
)_d3l1m1t3r_"
R"_d3l1m1t3r_(CREATE PERFETTO TABLE _use_devfreq_for_calc AS
SELECT TRUE AS devfreq_necessary
FROM _use_devfreq as d
JOIN _wattson_device as device
ON d.device = device.name;

-- Creates empty table if device needs devfreq; inverse of _use_devfreq_for_calc
CREATE PERFETTO TABLE _skip_devfreq_for_calc AS
SELECT FALSE AS devfreq_necessary
FROM _use_devfreq as d
JOIN _wattson_device as device
ON d.device != device.name;

)_d3l1m1t3r_"
;

const char kWattsonSystemState[] = R"_d3l1m1t3r_(--
-- Copyright 2024 The Android Open Source Project
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     https://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

INCLUDE PERFETTO MODULE wattson.cpu_split;

-- The final system state for the CPU subsystem, which has all the information
-- needed by Wattson to estimate energy for the CPU subsystem.
CREATE PERFETTO TABLE wattson_system_states(
  -- Starting timestamp of the current counter where system state is constant.
  ts TIMESTAMP,
  -- Duration of the current counter where system state is constant.
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  dur DURATION,
  -- Number of L3 hits the current system state.
  l3_hit_count LONG,
  -- Number of L3 misses in the current system state.
  l3_miss_count LONG,
  -- Frequency of CPU0.
  freq_0 LONG,
  -- Idle state of CPU0.
  idle_0 LONG,
  -- Frequency of CPU1.
  freq_1 LONG,
  -- Idle state of CPU1.
  idle_1 LONG,
  -- Frequency of CPU2.
  freq_2 LONG,
  -- Idle state of CPU2.
  idle_2 LONG,
  -- Frequency of CPU3.
  freq_3 LONG,
  -- Idle state of CPU3.
  idle_3 LONG,
  -- Frequency of CPU4.
  freq_4 LONG,
  -- Idle state of CPU4.
  idle_4 LONG,
  -- Frequency of CPU5.
  freq_5 LONG,
  -- Idle state of CPU5.
  idle_5 LONG,
  -- Frequency of CPU6.
  freq_6 LONG,
  -- Idle state of CPU6.
  idle_6 LONG,
  -- Frequency of CPU7.
  freq_7 LONG,
  -- Idle state of CPU7.
  idle_7 LONG,
  -- Flag indicating if current system state is suspended.
  suspended BOOL
)
AS
SELECT
  s.ts,
  s.dur,
  cast_int!(round(l3_hit_rate * s.dur, 0)) as l3_hit_count,
  cast_int!(round(l3_miss_rate * s.dur, 0)) as l3_miss_count,
)_d3l1m1t3r_"
R"_d3l1m1t3r_(  freq_0,
  idle_0,
  freq_1,
  idle_1,
  freq_2,
  idle_2,
  freq_3,
  idle_3,
  freq_4,
  idle_4,
  freq_5,
  idle_5,
  freq_6,
  idle_6,
  freq_7,
  idle_7,
  IFNULL(suspended, FALSE) as suspended
FROM _idle_freq_l3_hit_l3_miss_slice s
JOIN _stats_cpu0 ON _stats_cpu0._auto_id = s.cpu0_id
JOIN _stats_cpu1 ON _stats_cpu1._auto_id = s.cpu1_id
JOIN _stats_cpu2 ON _stats_cpu2._auto_id = s.cpu2_id
JOIN _stats_cpu3 ON _stats_cpu3._auto_id = s.cpu3_id
LEFT JOIN _stats_cpu4 ON _stats_cpu4._auto_id = s.cpu4_id
LEFT JOIN _stats_cpu5 ON _stats_cpu5._auto_id = s.cpu5_id
LEFT JOIN _stats_cpu6 ON _stats_cpu6._auto_id = s.cpu6_id
LEFT JOIN _stats_cpu7 ON _stats_cpu7._auto_id = s.cpu7_id
-- Needs to be at least 1us to reduce inconsequential rows.
WHERE s.dur > time_from_us(1);

)_d3l1m1t3r_"
;

struct FileToSql {
  const char* path;
  const char* sql;
};

const FileToSql kFileToSql[] = {
  {"android/auto/multiuser.sql", kAndroidAutoMultiuser},

  {"android/battery/charging_states.sql", kAndroidBatteryChargingStates},

  {"android/cpu/cluster_type.sql", kAndroidCpuClusterType},

  {"android/frames/jank_type.sql", kAndroidFramesJankType},

  {"android/frames/per_frame_metrics.sql", kAndroidFramesPerFrameMetrics},

  {"android/frames/timeline.sql", kAndroidFramesTimeline},

  {"android/frames/timeline_maxsdk28.sql", kAndroidFramesTimelineMaxsdk28},

  {"android/gpu/frequency.sql", kAndroidGpuFrequency},

  {"android/gpu/memory.sql", kAndroidGpuMemory},

  {"android/gpu/work_period.sql", kAndroidGpuWorkPeriod},

  {"android/memory/heap_graph/class_summary_tree.sql", kAndroidMemoryHeapGraphClassSummaryTree},

  {"android/memory/heap_graph/class_tree.sql", kAndroidMemoryHeapGraphClassTree},

  {"android/memory/heap_graph/dominator_class_tree.sql", kAndroidMemoryHeapGraphDominatorClassTree},

  {"android/memory/heap_graph/dominator_tree.sql", kAndroidMemoryHeapGraphDominatorTree},

  {"android/memory/heap_graph/excluded_refs.sql", kAndroidMemoryHeapGraphExcludedRefs},

  {"android/memory/heap_graph/heap_graph_class_aggregation.sql", kAndroidMemoryHeapGraphHeapGraphClassAggregation},

  {"android/memory/heap_graph/helpers.sql", kAndroidMemoryHeapGraphHelpers},

  {"android/memory/heap_graph/raw_dominator_tree.sql", kAndroidMemoryHeapGraphRawDominatorTree},

  {"android/memory/heap_profile/callstacks.sql", kAndroidMemoryHeapProfileCallstacks},

  {"android/memory/heap_profile/summary_tree.sql", kAndroidMemoryHeapProfileSummaryTree},

  {"android/memory/dmabuf.sql", kAndroidMemoryDmabuf},

  {"android/memory/process.sql", kAndroidMemoryProcess},

  {"android/startup/startup_breakdowns.sql", kAndroidStartupStartupBreakdowns},

  {"android/startup/startup_events.sql", kAndroidStartupStartupEvents},

  {"android/startup/startups.sql", kAndroidStartupStartups},

  {"android/startup/startups_maxsdk28.sql", kAndroidStartupStartupsMaxsdk28},

  {"android/startup/startups_minsdk29.sql", kAndroidStartupStartupsMinsdk29},

  {"android/startup/startups_minsdk33.sql", kAndroidStartupStartupsMinsdk33},

  {"android/startup/time_to_display.sql", kAndroidStartupTimeToDisplay},

  {"android/winscope/inputmethod.sql", kAndroidWinscopeInputmethod},

  {"android/winscope/viewcapture.sql", kAndroidWinscopeViewcapture},

  {"android/winscope/windowmanager.sql", kAndroidWinscopeWindowmanager},

  {"android/anrs.sql", kAndroidAnrs},

  {"android/app_process_starts.sql", kAndroidAppProcessStarts},

  {"android/battery.sql", kAndroidBattery},

  {"android/battery_stats.sql", kAndroidBatteryStats},

  {"android/binder.sql", kAndroidBinder},

  {"android/binder_breakdown.sql", kAndroidBinderBreakdown},

  {"android/broadcasts.sql", kAndroidBroadcasts},

  {"android/critical_blocking_calls.sql", kAndroidCriticalBlockingCalls},

  {"android/desktop_mode.sql", kAndroidDesktopMode},

  {"android/device.sql", kAndroidDevice},

  {"android/dvfs.sql", kAndroidDvfs},

  {"android/freezer.sql", kAndroidFreezer},

  {"android/garbage_collection.sql", kAndroidGarbageCollection},

  {"android/input.sql", kAndroidInput},

  {"android/io.sql", kAndroidIo},

  {"android/job_scheduler.sql", kAndroidJobScheduler},

  {"android/job_scheduler_states.sql", kAndroidJobSchedulerStates},

  {"android/monitor_contention.sql", kAndroidMonitorContention},

  {"android/network_packets.sql", kAndroidNetworkPackets},

  {"android/oom_adjuster.sql", kAndroidOomAdjuster},

  {"android/power_rails.sql", kAndroidPowerRails},

  {"android/process_metadata.sql", kAndroidProcessMetadata},

  {"android/screenshots.sql", kAndroidScreenshots},

  {"android/services.sql", kAndroidServices},

  {"android/slices.sql", kAndroidSlices},

  {"android/statsd.sql", kAndroidStatsd},

  {"android/suspend.sql", kAndroidSuspend},

  {"android/thread.sql", kAndroidThread},

  {"android/version.sql", kAndroidVersion},

  {"callstacks/stack_profile.sql", kCallstacksStackProfile},

  {"chrome/android_input.sql", kChromeAndroidInput},

  {"chrome/chrome_scrolls.sql", kChromeChromeScrolls},

  {"chrome/cpu_powerups.sql", kChromeCpuPowerups},

  {"chrome/event_latency.sql", kChromeEventLatency},

  {"chrome/event_latency_description.sql", kChromeEventLatencyDescription},

  {"chrome/graphics_pipeline.sql", kChromeGraphicsPipeline},

  {"chrome/histograms.sql", kChromeHistograms},

  {"chrome/interactions.sql", kChromeInteractions},

  {"chrome/metadata.sql", kChromeMetadata},

  {"chrome/input.sql", kChromeInput},

  {"chrome/page_loads.sql", kChromePageLoads},

  {"chrome/scroll_interactions.sql", kChromeScrollInteractions},

  {"chrome/speedometer.sql", kChromeSpeedometer},

  {"chrome/speedometer_2_1.sql", kChromeSpeedometer21},

  {"chrome/speedometer_3.sql", kChromeSpeedometer3},

  {"chrome/startups.sql", kChromeStartups},

  {"chrome/tasks.sql", kChromeTasks},

  {"chrome/vsync_intervals.sql", kChromeVsyncIntervals},

  {"chrome/web_content_interactions.sql", kChromeWebContentInteractions},

  {"chrome/scroll_jank/predictor_error.sql", kChromeScrollJankPredictorError},

  {"chrome/scroll_jank/scroll_jank_cause_map.sql", kChromeScrollJankScrollJankCauseMap},

  {"chrome/scroll_jank/scroll_jank_cause_utils.sql", kChromeScrollJankScrollJankCauseUtils},

  {"chrome/scroll_jank/scroll_jank_intervals.sql", kChromeScrollJankScrollJankIntervals},

  {"chrome/scroll_jank/scroll_jank_v3_cause.sql", kChromeScrollJankScrollJankV3Cause},

  {"chrome/scroll_jank/scroll_jank_v3.sql", kChromeScrollJankScrollJankV3},

  {"chrome/scroll_jank/scroll_offsets.sql", kChromeScrollJankScrollOffsets},

  {"chrome/scroll_jank/utils.sql", kChromeScrollJankUtils},

  {"counters/global_tracks.sql", kCountersGlobalTracks},

  {"counters/intervals.sql", kCountersIntervals},

  {"export/to_firefox_profile.sql", kExportToFirefoxProfile},

  {"graphs/critical_path.sql", kGraphsCriticalPath},

  {"graphs/dominator_tree.sql", kGraphsDominatorTree},

  {"graphs/hierarchy.sql", kGraphsHierarchy},

  {"graphs/partition.sql", kGraphsPartition},

  {"graphs/scan.sql", kGraphsScan},

  {"graphs/search.sql", kGraphsSearch},

  {"intervals/intersect.sql", kIntervalsIntersect},

  {"intervals/overlap.sql", kIntervalsOverlap},

  {"linux/cpu/utilization/general.sql", kLinuxCpuUtilizationGeneral},

  {"linux/cpu/utilization/process.sql", kLinuxCpuUtilizationProcess},

  {"linux/cpu/utilization/slice.sql", kLinuxCpuUtilizationSlice},

  {"linux/cpu/utilization/system.sql", kLinuxCpuUtilizationSystem},

  {"linux/cpu/utilization/thread.sql", kLinuxCpuUtilizationThread},

  {"linux/cpu/frequency.sql", kLinuxCpuFrequency},

  {"linux/cpu/idle.sql", kLinuxCpuIdle},

  {"linux/cpu/idle_stats.sql", kLinuxCpuIdleStats},

  {"linux/cpu/idle_time_in_state.sql", kLinuxCpuIdleTimeInState},

  {"linux/memory/general.sql", kLinuxMemoryGeneral},

  {"linux/memory/high_watermark.sql", kLinuxMemoryHighWatermark},

  {"linux/memory/process.sql", kLinuxMemoryProcess},

  {"linux/perf/samples.sql", kLinuxPerfSamples},

  {"linux/perf/spe.sql", kLinuxPerfSpe},

  {"linux/block_io.sql", kLinuxBlockIo},

  {"linux/devfreq.sql", kLinuxDevfreq},

  {"linux/threads.sql", kLinuxThreads},

  {"pkvm/hypervisor.sql", kPkvmHypervisor},

  {"prelude/after_eof/casts.sql", kPreludeAfterEofCasts},

  {"prelude/after_eof/slices.sql", kPreludeAfterEofSlices},

  {"prelude/after_eof/tables_views.sql", kPreludeAfterEofTablesViews},

  {"prelude/after_eof/views.sql", kPreludeAfterEofViews},

  {"prelude/before_eof/tables.sql", kPreludeBeforeEofTables},

  {"prelude/before_eof/trace_bounds.sql", kPreludeBeforeEofTraceBounds},

  {"sched/latency.sql", kSchedLatency},

  {"sched/runnable.sql", kSchedRunnable},

  {"sched/states.sql", kSchedStates},

  {"sched/thread_executing_span.sql", kSchedThreadExecutingSpan},

  {"sched/thread_executing_span_with_slice.sql", kSchedThreadExecutingSpanWithSlice},

  {"sched/thread_level_parallelism.sql", kSchedThreadLevelParallelism},

  {"sched/thread_state_flattened.sql", kSchedThreadStateFlattened},

  {"sched/time_in_state.sql", kSchedTimeInState},

  {"slices/cpu_time.sql", kSlicesCpuTime},

  {"slices/flat_slices.sql", kSlicesFlatSlices},

  {"slices/flow.sql", kSlicesFlow},

  {"slices/hierarchy.sql", kSlicesHierarchy},

  {"slices/slices.sql", kSlicesSlices},

  {"slices/time_in_state.sql", kSlicesTimeInState},

  {"slices/with_context.sql", kSlicesWithContext},

  {"stack_trace/jit.sql", kStackTraceJit},

  {"stacks/cpu_profiling.sql", kStacksCpuProfiling},

  {"time/conversion.sql", kTimeConversion},

  {"v8/jit.sql", kV8Jit},

  {"viz/summary/counters.sql", kVizSummaryCounters},

  {"viz/summary/processes.sql", kVizSummaryProcesses},

  {"viz/summary/slices.sql", kVizSummarySlices},

  {"viz/summary/threads.sql", kVizSummaryThreads},

  {"viz/summary/threads_w_processes.sql", kVizSummaryThreadsWProcesses},

  {"viz/summary/trace.sql", kVizSummaryTrace},

  {"viz/summary/tracks.sql", kVizSummaryTracks},

  {"viz/flamegraph.sql", kVizFlamegraph},

  {"viz/slices.sql", kVizSlices},

  {"viz/threads.sql", kVizThreads},

  {"wattson/arm_dsu.sql", kWattsonArmDsu},

  {"wattson/cpu_freq.sql", kWattsonCpuFreq},

  {"wattson/cpu_freq_idle.sql", kWattsonCpuFreqIdle},

  {"wattson/cpu_idle.sql", kWattsonCpuIdle},

  {"wattson/cpu_split.sql", kWattsonCpuSplit},

  {"wattson/curves/device.sql", kWattsonCurvesDevice},

  {"wattson/curves/estimates.sql", kWattsonCurvesEstimates},

  {"wattson/curves/idle_attribution.sql", kWattsonCurvesIdleAttribution},

  {"wattson/curves/utils.sql", kWattsonCurvesUtils},

  {"wattson/curves/w_cpu_dependence.sql", kWattsonCurvesWCpuDependence},

  {"wattson/curves/w_dsu_dependence.sql", kWattsonCurvesWDsuDependence},

  {"wattson/device_infos.sql", kWattsonDeviceInfos},

  {"wattson/system_state.sql", kWattsonSystemState},
};

}  // namespace stdlib
}  // namespace trace_processor
}  // namespace perfetto
